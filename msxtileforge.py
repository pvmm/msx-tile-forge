#!/bin/env -S python3
# -*- coding: utf-8 -*-

# --- Version info ---
APP_VERSION = "<unreleased>"

# --- Application Icon ---
ICON_IMAGE = r"iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAIAAAAlC+aJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxEAAAsRAX9kX5EAABLlSURBVBgZBcFbrLb5XRbg6/49z7vWt9b3TWemLUaMrZWwObAFQdnJTIgWmxgNPZAoUA3GuDswcRMSNcoJxsR4oNEYowIaxd2Bm8RaIAgyVYjEJhTbsdAWbKt2Q6fMTKfzbdZa7/O/va60BYAPfehDP/uzP/fiR1588vjJzKyWJpnMtm+ka7VNkpm2bdsm2bYNbZNs2xbJOI7Vrm3bk6y1utZqkSSTSUjbmahjLYjjfKy12iZJRI61juP8lre+9du+5Vufe/6566trANq2bfvRj370O9/9nfvpks2+2Xenk9PJ6eR0sp+cTk4np92+23anCxcXLk4uTi5OTrvT7nSy7/bdvtt3p93p5LQ7nZxOTienk9PJ6WQ/2Xenk323n+y7fbPvTrvT7rQ77fbdxcnF7uLk4mQLfutXvO1Hf/Sft23bNm3xwgsvvOeP/pHPfPqzD55+YzxxvgttGwjayKFOl7PdW+u8bl4PCACUQNpmc/3UiMcPe75tsmIiFbCiNdHVubx2uuxx5/YRSdISUUJh27NfPXr4+Pzk0Q/+9R/8gb/2A0jbj33sY9/2/HOvvPrqg6eecvtk3vSVx5velkiUIJRycernP37+/KdO95+5+JpvXRIiaIuQZIXZ8vi1xx/7udze3nvbN3jTW7vOK1WTaBuSgpnt+MQv3n3hU556s7f+9jnOkcWKaNY2lay++pnjc780++lYXv/iK//yX/2L7/2e9+z4y3/lr3zhpZeeefaNDtvzf+r4mnedL69KamkMmkbn6unL//YP7j75oYsv/6oHf/hv3eUix1k0qApJVqyLexef//jN3/6uu9uXL779u7dveo/HX1RFS4NEldPV/cf/7C88+eSHt9/8tf2Ov3ycH1praYNmbTFNtnU7H/3p/rd/vMfp3uVf/YEfePd3vnv/Xy+++N73vvepZ59Zd4/3b/uT52/4nruHr6ybV7cOk5xnbUs60mxr1u1Nxznr/ORVveg6N11pEoG2xPneevKlmtrON4/z8It98pqqma44yqKtZOvZ+Sax1jmPXlnrti0FqVXBXWZ/xx+4WMf5/f/o6qkHn/zVT/zUT//U/PhP/MT57i495+nffPfV7zy//rKeN1vNombNGKPSYxYBkklIyWZLJ2tmZczWGTOhq12WSFo6XbSmIZKJrYaEqSQQSUCJSs1ax8PXjq/+9vkNb3N7a+aFn/kv89Ff/mWzOd/mzW9Z965Wj6iFJh2JNe20egwRgK6oAJGoSAe1tClIqYolqyqLpEPoDANZJTS0SEgFIF3ni4u+6a093+bi4uO/8olZXRKt/bKyAoICCowqAMSSZgAqWgAiU5BVS0ppAiBgtUe1EUBaIagQRKQWW3Kimbm7O4YI0pU0W0Ih0SKgKtEQ0TZEo6QqJREKRSUkNUoZHVLThiYVOkwhtZAIAaWoqkRbJdNODMHKdiRiihxRGgor7UBFBEl1LCpN2i6WtADlCJFmirQhrFgJWbV0mCncjQjQaKCxohxDSdGQtGsaoEmQhWFJ01SLRiGoVtB2JQ1UDKMCkhDaopU2ESmgSAxJIDTaVW2Vtg0ESUSoVEobGYJowHJoR9IUSQlTSUQFqEgEqSGqUlClkEoKZLHQDhQBa6mapaWoFgDorCpMVENjMhGpVmPlYGVFIxACUBgNmKbLAqpttVSpikppmMCCToAsliwpRSCFAAACAkqjyWr3oLQya8ZsxxqiIlgtlJEZ6aRdXVLTCQ1AiaDZOvukYzVptmaTrC5pSFJbKM0mg8x0RqeI0LYlQpnOZEsmlUrtCaxkX93W+Wj1kHZFIICmszUpzVbXp4s7SQ8dGQolUfZ9iwPNvm0XF6d13mRmKQ1Mq8qWuTWLyTrNth1pjyxBHbGIbivRSSVpVqzYg9bldT/zwfm3f2nr0XWW1QZdzSSKZDIXx+NX++ANt6+99OoP/Yl2KdUGdcgKSJK7J+2d+888/OkffvI//l2PM6ZKQ6WN0Mb55c/vTz3Tlz+Vf/sXs861SApbulEiS7JlPXrZ5VVubqN7wcx+PH7l/NL/awAZrS4ZCgmVe1fb/evj7uHnP/RzEhkttBSMVtg2pyvNo0983HEHgIASCnVxfe/e/cvePHry678okGghAFica7935fI6lWZX4jjf7m96y+l3fP1aQRy1IKPN2iLdZNvP//cjjz/7S09dXb37d/3Ge109QiWRZMnato2EsMJpsz1dQVOMpKrRqMl+sb/wS48//ulX7z3zG+593e9fOc/oCptGliwNeyNb1yc+fPuF/9O06d4i6+bhxW/5hus/9vfW45toFSpJ24hmwv2n7977N1/91V/48jdc/fDvu3+1LYtVKkMplUgAX/YGp00rJEJRHTkIPHX6M//45Rc/9rnrr3rbG77v757vbqKFqGpADLNd3X/8r7//9tMfSS7S7G21WybHuQ+/tB4/GktU0lQr1cSxMsPd7ZZoX//S3eXJLSEVR8Gh00pA5/o8p7ZN2oJAmqQEY27uFsk6r0df7N1ttRYUCgVbetfzjSiSgcTCQqOBFJVFo9U1bTsoSNYES1csUCIUEVoaUjQ6VEpaKVXJArMaCE1FEgAhTbqppZp2ulcRSJIWU6LSNoVJIXSJANq2IwEFKZkkutpEUpHVTtJWlAglQJW2bYs2xKoAiYiKCmKaLLvCiiICkgUGgYWYskYjAYRQAkCJVsOKJSlomwRtBQkLOoVGta1WyEqiU6q6himoTssAJQkQWlAEiSpEAwVIoVEACSQSVBeLCIAkQAEZQScRkITQEFQptAULyR5EgJZQokEsKZLpaiAgQAMpUBIkWlKYSbRV0VaoJFUCEEIkSYRKhtCkEWYth2pFUHsDoKSKpEUlhw5TlTVtCqWkEIBKAEraiWRpNESbKImCILRV0KVtQ5UGKdEIhMaCYKBSQBQampQQIpFEKSiiaFuKFmiLKmlTaasVrVBBRAAFkRHQJDGSVgs0kySTZBJVE9AotAURoEOksVApgKi0JW21pW0BkpCYSgMhSQkBSiFKRUBV21qFUG21kqRSmuhOQO0XuXp6ukNWtDZNkKNdsff62ZzuVSMpmkSbRBsIEFoCILSVQImCFAQ0c1y/wX6TnkM6FTmgg2RcPdX9pItW9yTIdlqvfe78wR9bNw+LREWbQJsgvbi6++xHsl02tFldNUnWIiu0oRqhrYmZDdpYktCWTZYaEUR2r7+y/uf7so602rKSpppIsyTne/ePVz+X7SKHyA5t7l3ffPx/PPnQ+0sSWRGpQiWAuri3XV5L1jP37ce+GtB2S9piokWTnO/O280dkqysVCVpOgrSWcdx1On6/NL/efmH/gyrXUmQJGgrOkSOnK7m8v56/HDpngStzGm7N61kWJFKJUloD1rpNo4l+/7gak7nfVVUEmhXlwRg5val19brN8kco4SANgQsT069PWwj3U7Xpg2VFlOoiRTO3YZGsEuwnjx88Nve+czv//N3T15f6TBNk2XTGWddku36qZuf/def/pl/xjOOZavVBl1QJdpMiaNrxLbLJE1JpkUDkDFbevbk4eXb3vH0H/rB3N6RIm1bqGIltssHr/3UP3z9gz+WJrVnAuvcB0/fvPXrb19/fdISaZcsAaSzPXhTn3rBsRLTs1gjhWpjJG3jGFqmbUqoASuhKaRVmNCjF1d3v+lr1/mO1jLt2jjkiFTI6erZXH9Ze145mezbtkHi6Hr8MDevJ0AGKgU02e+t4w4tKtNWK0KatiKqoAUCUAAEiVZpJdaR20c9n6XTtgsJqkmysD103Kokmn0SraIJsBATKaEV07ZdTYOqIJVAiwZVEoQkaRoNjWpEBUBAhlYQtCpJFISoIa0ATTIpkmDRJk0CpHIUNkIaBQgUpQhAIiFVCpa0sYA2SCApVEmPFEhJl1WApjSqAIVp0NAOk0gnNrSN0aE0DBQ0qCoiIUAbhaq0dDSpadJQaCVtUwQIibK0NQZoo8MUCQkp7W4tgMXSxJKGNm3AamgUUWQFJNq2SVaIVFsqoiBEVlRDgLZBYIGtaYmYWDQlE6rStgAky5quEoBESwsRohCaNiiqQoQI2gIUSVCiAYBAkgIUIbQIWkTaklYFtSigLdUdULGREkELVJA2Ie00AgTtigBRS6Joq5EW1UYkbcNqgdKwCkmjAW2RaYNY0q4RbYWk6ci+UiGagwXKSsowLZq0jSxZBQUoEqSVUJRAGCRtpgEUJcqUSgERSdtotEHbWpGJQhU02bsKLZtsaJACXWVajSgkEiKsHalqC20S0RZ0go622EK7gJYYTJJIJAcaslARSbWSYmunGjNtVnegqzPbfnHZ4zJbdKpaghFV3S8fnLeTJJmL681pzwpECgACZS4uz8oWoqiSCGi1Lk/bdtZmZru+3p/cagsQra4WNXNxSg5tE7FD9er+za/+wvEjf7o9R9ITrcVoSXXYcnF+6Vcuru9/8fH6gz/02V3XCj0iM1urWV0FrY7T2Wk5tCRHYJaRUknqcvLhX7u79+DB8WufePRP/mzPZ2s1aXR1LFkFqybb+txH5t5lb1eTXSJmuzi//Om7z3wELUvIAAqCxfVpv3zm9vb8kx/4Na0UIKCAFbO5um/GzUN3txIIgECqtJfX9y+u7h0PX3n48/++pBpAgKGgcnU/F/emj6b2ohzneerZ7S1f156jRSMrlrYlYXO67Jc+fbz6uVxcP/v1377PmEk2VaIokszm5vHjT/3iOj+5+sq3zzNffqxziKDQUJBsd5/55btXP7tdPbu/9bc7Gm0bU4FoGyTddq98yuu/vmKlexW5fTRf/Vy+4/vXkxtDDm2rUjBWy4Nn95//0bsX/uHFs7/pmT/+97Nfr3WQVBWIrLBf3vvCJ2//znfdPn7p4nd/39U3/pHbx68gghJK2sp+9eDJj/65u/f/y/zGd6zv/Bu5fURRaYUSSqr3rk8//fduP/wf2Rp7AOnhdh09brtApZWswNDV3t7uh61pHE+erKTOSbQECc3SdXFst0+6JHO+u729edibh6oNkbZJaCtrJscatL27Oc7nKqFpVQklne202iXRpNkpGtOmbQsxIVaaCohSaSOsHmuqWJmVTrUkM42WipA2bTVE6ihJaq0pk5SsMGRFtdKibZC2jeYcBxthRXcFFZllEdVUJUpboBBJ0zYitBFrk4bSCkmE0k6CrEHTEqokVShttc1qW4WAggSkkTSpadOOjsBCIKVKCQipBApNEhBSSSlJJwmrLVg100GR0giCSqMCbSkUipAkSUDQQbNoqexpFegRVFKVpARJiyZoV1UikJIuDRHRrmRJWXIwqbQJFqEoCUyiLUEsmhIBgIJowCLHRLofKkKCEhWKKEFSqlZTSdoCjcgUaiUSRENiElWJVgCtRCvRIslkIEfTpMoaU6GSAO1aQovErC5U05kGpSEQQlnRAlpBpQqkshLQ6BCSTpSmKgxIEiQBBCA5otpAqgCloDHbtiKLZi4vTloznjyEQKFolAYmAQCBQOughCkEqClEBA2h1VIFDRogEYEYUqBptaFy3D6JtOv+9fV87dvfbq3sl+ulj+X1l7pdVqJZVWppV2c1KgC0GkTCMJRq2tWuqqy2kgLRKkHbFpGWdi1d3SRJyNJFazWVZsqctpsv9nMvzn7qze073vH2eefveed+cXFO+vCl7ef/zeni1NO9NElIJMkIUxNDQBKqaGJb1VqtkCWA0FjZmmm6Ypllmk22JYdtdWtWAufJyqzkmKzJmqxJzYq1X+7Xb5gP/of1yv/rdiH7u971rv2rv+Zrfu+7vuPH/9OPPf3GNx8f+Ym4u/c737Pe8Gwz7cQ52goh+2Q0Msnl9Wm7n54ng65DyNSsrG273Perha49czpta0+0ZCVNRhOU0z7nLjX7tl3c00dtktAWtWW18+il7b//09sPv2+799Rrr3zxm7/5G7/lW35X2r744ovPPff864+fXD91vW4fbpdvyhvfku0CHEoLbSbr4RfOX/q17erB5Vd8U7q3qyptA2nKhG1uHz363x9wfnLx5rduD97cdcjRNmvS2NJCyGw3v/7J40u/7uqZ/Y1vyfmWJEFZmqTntV779PHo5e3e07dPHjmO//yTP/n888+nLd73vvd+93d/z+sPHz71zJuj63yTnpOsDMmChpxnLrpd6tmT13VInVeSBOhaA8zM5f2Y4/xkrXMS0lYhEwCwXWTbrJW7G0ESaFsQ6X6qefjF1+5dnH7kR374e7/3PdC2bdsPfOAD73znO+d0kpjNbGYzm9lkzGbbbbvZZDNjxmy2zbbbd9tmNtvYNjNms222zbbZNttmxowZMzK2zbbZNttm22y7bTOb2cxmNttm2227bbftZkNOp+eff+79L7zQtm3btAWAD37wF/7r+//rx37lYy2VIBAlQK00UlVIVGMIAYBBuqyWTkJXII0godBE2qIIaaRdZbJ95Vf81uee+7Zv/MZvBoD/DyChWZsA3b65AAAAAElFTkSuQmCC"
SPLASH_IMAGE = r"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7ExF0pPm+RHuJTeXm6291r7/ve/9hb/wf/hd/61/ii8HK74E/v1////2j/0X/0tzzMroIDcz68RMUYdO5/sfnleevvP0XQ+YuRwHdwGB3AhEwCgQLwkhNw1YeTBjwxxHnd/91i8+4eR4sjx9sufw0al7ec933pvY8wRUFF9CiJuJ1ypeCQKFUIHkJggQkQVk4Hru+7/ok57TO+fzetquu/P0vd75VXs9dYCIGRXZXW6UgAAVqEAB+RQFlodwPI5j9+z5FXWG8xkffvvicc4hz6Gb8zx752v7zg/oXrqy7enMcVwuFLBtkahJRWAmAR4MjKs+lw8h4/p8n73/QfP86ZNzPJ75XnN9ss/sqbwQnLvn5cmT737nOz/4g1//9/76X/+RH/71fAlY8ab75je/+RM/8RN/5xd+Qb26xIGADrhOccyeH3ywPf3qj/6WJ7/hd3z4a3/z/sAP4swxvCIExmsqX8RECAbG4OT4NfOt/++/8S9/9I2fP45jefqkc3j+wfsf/ab/+j/3tX/qX/rF731wEOFMtbuAysPKnbywBRg3EzfGjXcESdyFEDhzfHTd//Tx7Z/71/7Qt37uZ9559x24bk/E59/79g//47/36//d//E3vv3dyxhUjHjXLp8Xcad8incVd0JBIVFgx+U/xTf/H3/iD3/3//1/f/fdY30mF+rZ+99978d+19Pf+S99+P53jj4SZHCIiKiWuBkD4kYEjcIOUaATV27c/XD/9v/r6d/66e/93L/ns293OeW4dF5njgUE4axVgW/94jf/2d/7z/5v/43/DXfyRrvwpqt+6qf+5V/4xn+M02AixAu1nM/c/YjLO7/hx7/2E7/n8oP/4LPzUry/524snxQkN/FZQrwQLDe1CqKMX336DvNONT2XINjW03e/9fydv/3+s6eXAVRgdwGVh5VP2pKHGBAEEVCTmyCLh/KYZ2dfO7527T08yJ3JRbn4kfzi9fIfn0+eMtyEiwpUPAQVIB+LQF4RHHllN4VA9gw5n/sD735t96vWR5w7vntN6DxPLt999s4HHz196tgVegFQyYVEzWq5Ccyyw71wE3jEAagz7z79kR/3H/jtX//P/zPv//V/87t/8y8efe/yzlfJGAkW1AOC/p6v/z1//n/35//if+8v/K7/5n+bN92FN93P//zP/6v/6r/2la9+ddvltUltjqP2+r1974f+if/B/Jbf+e0Pnz97//vwffQYBrkTAuRGaksU0EpEtlRY7uK1TM+a8wqjwsKZFMycm3udfT7noSN3U4AKAcHwKRXhGASCoBJBEDfxiu22l2TfeT4eoxynKeew7XFen57n091qvEGsBQmkgAgIEBM2REQ+o6Acb4DzegJXfHqsC+5l3ymW5zM2uuflfPbkfP50TrjC1lLcCWwFYls0TkEYcA4fciPJglJ7MNcP+uau73z1a/+1n/z6j/7D3/w//ckPPvo7T7/yDtcjz9SEEzNgdH7qp/6Vf+K//F957ytf4402vNGqf/73//7Lk8v1+py40dFpZngnL9fnfnT8mh/6p//QR/+5f/LvvP/+82ffPw48Zu1012uccUIWUefJybF4LqcgD8EYLJOTRx552PH0nMs6er0+367cuRw5KPLc67Mni6dd50hPOccdV05ZvTLXnet6Xa/rdefKZXuy67W5Nted6znXq8+vPj95vjyP53Wta13rWmedy7UnOzbIXmKWOc+u8OwYc9TLkZ5wSnOsNtNcmmM9moO5OAej4qFjU7bWlGVNTE1rJ7s2T8Yn42Uc5Ip7cB2uSZpubDt9WM9OOnE5di7r5WxOZj3i2CYucDnXzW1OPPHqXt2re1rD0uK1Ghy7fvTNb3zjw3/wt/3w7/lD85Vf/fzD73cMNxkkwQrjez/wtb/xf/m//h//rX+LN93wRvuZn/mb/+d/+9++HBeVjyW10bMPL1/5+n/jD5w/+o98+J3vf8XjIGvigKMOGnbao52a7YChId1j6Hw+7bS2U7ZDQ0ND1tRRR7k75Z6jMafHcsnB8myAgBEIgiAIiiCoKcsYMqwJcXBwgCAIqq2FIAgioDwNG3DiCOMm5SaoBE3SlaWthTRZSe4EQVQ02TorXVhYWIuilWAJixeusUHKyIMEhUG6kTBuL3EXEMyMogMlSXIXKggGzCgX/eA73/v2D/z6X/fP/I/42g/t+d0LPNlDNkse1DmeXP71P/Nnnj//COLNNby5qj/+P/mfvvPuu7tb1tZyo6fnHM+///3v/72/9b/67Df+jm9959k7Z+d1lyMHxhlmYPBwDr04l5lDj2MuBQ0NHjA04yFz3cLNzc2cmLI8z505CArFuBPjZoGZ4+AmvlDFJ1TEzCCvOTo6Os5xc4FDjxl5uBwXrlsh8TFhcCHYcwEdmd2z3Qi56Q62vWlfqyi5sbqe132ljYf2rt025UHBcHO33YoAeVARsNLZjU9Q0S1fQFHkrhsM4m6BS+dX9/zgu9/5xV/9m3/oH/8D++zJ1X12OZjRi170gGDf+1Xv/dV/59/5uZ/7f/JGG95c3/ve9/7Nv/gXv/KVr8SnBNfhw2fvP/3V/9Dxj/zO7337e3PlxKuly5zOyaxzzrHO6Vz11NO5zlxhZ845Vjsu5xw78yyexfH03Z3jdJrLznEyp/N85vQ4PU4PlLsgXhJQZ+aY2V3kBeUhRRREQO5GkYrXogfiRm5SERS8gfhCUQvdcFPQjTdAQYqg+DlBN4DOjQ/jHKMCgTcjivJafCEV2D1nJgJm5uk77xzHoajA6J57OY5zT5DPkdcEtnYvXt79xe9+6/kP/5Ynv/EfOz98lqQQBQI+fPD++3/pL/0lkDfX8Ob66Z/+6e9897uXyyVNVl6ovVx79uy9v/e3/e4Pjh/Yj54P5x6LS2vJTsxynEzMBlRntUu5uFCSkh6Hl7Hz2ez1YKfzoOmEs2PH50+OOc9t5S4+lloLlpWKG6dj4woMOV6mGQ453GHHdXZmZ3ZmZ/LAgzHd4cRlaqJSHKuJm2u7nLW1FaUWMk+OJ4RhO3jMEBR7jtnCAmFMDKhwjFALzByjIs1wyEHTSkOSLTfeIQiE4MM4MsDutlup2+55VmBxUwHn7ijEQ3FjuByMi2EY4POZxSd7/V5f+fqP/ZNX33Gfs2e7dLMlzMExzM/+7M9AvLmGN9ef+3N/7jiOjz76SEV5KfL46PrVX/Wr9x/4Le9/+P1KuUsFT1lZNsPlrgBNMiy6AYKFrbN9fhnkHLK1PUwWVpJAPhavhXfcKTAzl+O4Xq+Vzkag8iB3FfFC3MVrCirITbxWAcZnhRB3ctcd1W7HcYgCxSeoQBBUwHhDBaijfAH5uzn3rC6XSyUEQm1QKi8o8inyUi038oKABIjYh+8//aEfufzIb+z6XYGo+IT3vvLef/Af/M2/87d/HpY31PCGavff/Xf/2nvvfeUskFd2d/S6zg/9mg+evnuep7p0UstDPMyMI/JKNxAF3s2AoKLMTOxwGInjzVZQbakw3AVBvBQcu+zuzADVpnPwMLq7QaBWM3McBwpUM6PTS8vnNTSAYRjDp1QuKtAW3QBtFAWhASr0sBUf64aX2tGjArwBZ4DjuDhAQSBMTEx8knKzuyogdzpys5UPvKJW6oBxM8exLQ8+FDfqzLTvf3Mul9/wDx/tMRc55EIDCNs+fffp3/pb/59vfOPbFG+o4Q31wfc/+I9+/j+aOZ5cLvIptR8N7/76f0h9otBKgEQgDxUvFCykgCigKLsnrLwSN5W6D5fjGLlrFbXiCyymBEgSqEB7dzkOHtS4q4AA2b3uPr9c5s6Rz3FxeZAvohzR4uYOChSixAkLidWCyt3OgAGCSgQzx8xcr1deKO6C1eVGgmR5CJG/m6goPm93Z44KrHhFBPbcrdGZaSM6+tZen/x9P/LMp9d9jovLQ5Bed59dn//iN7+JwxtqeEN98P73rs+vemx8ij6xw+P8Vb/2OU3cJIlgzMP1eq12F3DGm1GDZkYN2mbkpmVjO7gAansHnOfz8zwvx0UHQdr4nEpx2D2LVl7TmTl3KeA8z9HObVeYSePG2aWmjhIIMCDiBRkgvoCcLRLES8ocMLRBinJTYU4z7m6l7kIzHsNxvZ7QzCxsLWGYWs3IQ7wUq+650XG5IOeuWrxWiUCtyksKxqA1GanA7vKaVErFjTBP9iPe/erf59Ovs9XW4iYpzLPnPX+2v/AL3+DNNbyhrtfnKrgbn7Gnl6e+9wOczyVwJXmwbXeP4/AGuSmoXT6moGAQMM4xx7knEFGjPKgFyJ18sZVEIE1PWJC763leLhdAECpkZoBuQNEiIEJ5qHA1bpQIIYH4pAR2TDfiJfc8252LwN5wHZmxAnZP2Bl3O44Jqt198uRJJchdG1DNwRxcz+dIgiAvKJR67rm7Ty9PCuVO5SYgmuOoVF6pgLYb77gZR91WPY7Dmet5xioP4uChFxUW4rWZ4+nFOT763ge0EG+i4Q11nssy3vEZhbPH0+lciNKFAKkAFVCJCnK4cabildYSiHZXpKERBwFnjuNybRcMWpVPkRuNuHPJsQS5KRWIu/EO2Ipu6IYas9Y78AZILO4ibjIEw/gMQdiWF3yBdgFFjLgL1AELJQKCaHdjQkBQvOM8zz1X5ZUgeUEeQqwQEOjcuJkImBmgc9kgcHwYgQkWBKl8OM+TGgfiJoV5+oSRtj194JVuHPB6Lg7xRhreWIERxKfJXTKFgiivZLwSId7xWrwgn5ZFwDycu8Bu57nHHNwU4cinBd4goAhtx3EE0cwcM9frlYe4S/wEQF6qeCF0tjtAuQtiUD6jRCiQuJGPySdUzkTgzBQRoVIzRyGviDPX6/Pzeu2G+CVZ+bAFREAUAeIxQ4hyY7C7M0cPyrnLTewu0ANQIa8VbQgYnxMsD4K8oS68sWRIFpBPCtthdQ/uGg1USOShEpVgV+6i1akEb4gHcWbO88QtzpZRORpod6MGvBknYbeolnIG7QaQbQ9ShwGE8a4S1DrRluO4bFsnIswc5/XqcVQCKWLI7o4HUHk3Qpx8wnKnyFYyIAhxJ8ldrSC0hdJEkEoJEeAkVHMchJIHLJ8Qd8Yxc+LezMbMuHFzHBfucot0BLRdobqeV+A4jt1NHAczQAVmBljkLkASCCSkARQDWXbgyUzFXSBvnOGNFRDIKyFyk4BOTKDUHsdBUAIRzQwSnyGgIhGvbHtez2OOcYhCLW7UyFHkl2DxSgVUcqcG6u7Kp+jwkoAKRDcqysM453mCCsQvwbSocQAdSIEAb3hNFIgAERCBoAi8Q7lRxJuQkk8JiNciHiqVuwIE4i6gOo5jnMvlos7MeZ7EcRzdEFABYncQEHcSbXyR4kbuNt5gw5tKd+Pcw5l4mA0Yog3lZhMnORtFeRArXvETKkDdc7kJ8W489+yGu5nxAUYgYPgccWt3j+NQgcGLx4HGubuF7u4oEG3LwxwTEOPIFO0ecwjtVjxsS4wWd+O5Z3yWcDjHHOf1yl1FAenAAcODNzA6jh5ghY4KCqR2xwsRdLOpB3EjL8VnORNsq1O0Szh33MShRrW7vBSyuxWwu2p1Pa8qoCIgyAtBfMbgnE0i6wnxhhreUDZQgq7cSYqsolAgGN4ABQQZ3XBSknxGtbuXy6W4qbjRlRWG4ziuz58TIQjyy4i7FvKhFhYW2Nrd47gAsbUQUl2v1/M8I+4W4jXlE9SKG0UCJD5mWIDxOe7ueT13l0+ojdVgedhd7pph9znEK/KSAQIGIXc7BiEiChQhNykq0AM3srUEVEDbHJckcWbPc2Z6mJmzTZACgpA7QW7iYwKKVLC8uS68sQqCuEsoFWhgPdsPWS/HtOcGjXMtRWwIRCCgeEUHuiMIXPbcjpnRbQFl5ohEXkmQ1wQi9XIA53nu5DHtuWCix3Gc5+kYJyYE1Sii8VI0QDzUzFQ8yEuxYjcQJJ8SXbfpyZPL2YIiAQoYr7UYUu2eM3McR7vneR6HzlQ+dIcMDxJKEcLEQnAenO7BqluDFaAChXITn5AUME7UUFsgFbC7ziQVd+2uHLBQWqd8LEFuzpoZa8+TN9rwBlMUeUkXTm5EgeQFQdh2HCAIdIIT4k7loQJ02mZULsflclzQs3VGpaAgUm6C+CLyQkBAooKLy4MIcZem8UoFqLgYyMPuxl2Q8pqAScMn+QCpFCA3FjeVD3xKiljBRu+8+84cUxth2wne8DGBCpCPpSuIeMedWgEKyCcECXKzLQ8Bg8jNTFKJaDMriNwEidwZdyvxijzI3fLmGt5QhY56Xk9e6IADDhBBD91dTgxjEgIEEdZRUYs7BW+K3Q0KYncjUI/I0ZmKiHYjDrB4SR4iNgrwZqSMSRvWdsfhY5I63MR5boFW3CUJqDO8EBRQHXPsbnJTxMd2A2amG16RKNCBgUlQtAABxxvohS2VoIFBKh6CccAbXhHkIcDdrQ1mppY7i1oQ3AIEFAS8mQF5oZAZRXFGIJYbqUCQm3htQj5rpeTNNbypFKiQFyIeAgpvBogQkOJOoPa87nlutbvHMYHouHvyWqRABalFMRpUIMSDCmxL8oo3yINIvBQvyY0K7O7MUXGjT548uRwHQXyeUKm8IEKBd7xSvNANHzv37nK58JK8VKHuLqACFbK7PKi1o+3yggqBKJ9TKISI0A2f4rbbHjMQUIvcqLurIDfB6HmeKg8zyvCgvBABkjB8XsGgDMgbaniDRaASBCyccsIW3vBSW60ODYwe1RyjqznNTLsVMTNQNGNDtHR4VOxOGOf1HJ1RAgQUB6TtwVeAHjZ2bZWJhEDY3ZqwgNSacs89N1KPzRigAtoNVER01Dl3EUqnNhYEREWtuJNmPEbbHT33hBNWFlYDZqaohcphCBoQ2O08Fw49AEGtjTNyBqgIRwQibqIXuNHzPAHlRtwCK3V3k6VgNxZKqY7jiJbd2u1AzlgdY7kpPiZgGIaxBBw68QYb3lAqd4FAorwU2KgzIJ8g1t4cxwVQubOIFwJ0juO4nicQgduOAt2tI3eBQMQrFa8pN/I5sezuzGw50zaoVCAPcadujUPceAPe8FC8Fl9M4s6HbnhpH55cLtzFSwFByJ0iDwIBPnlymeMQKeDc3TqOoztugrgTWEQWobipuCnIoRICojsIlQdFmVEEi24AoYgblZcEKRWUX5o3QCBvouGNZcQLIi8NDBE0Jnch4Nm5Jd5UlDHN5O55zDHjeZ7cLTEzhXdUgHroIODd+Eq1RTmCICBQBknDK8Ucl/GgRtEsBw6almpmxHHO8wQqwQe+SO3N5TjUWl4KaBOSJImACvBhd7lRXqmFBDnK+CTJXWUiFBgFdheIEGTlxhAMKD6mVjPTGfEQdKPUqrzk1u7OTKWAdwwKtDs4uBsJJrXHjForHxOOFLY4Dog31PCGUm7C5HMCggiLojixOCHuQnmoAOVGB9CpbYN2K2YsKj5FPq2UgwbkIZK75GY0WVqX4aUiKh7m4Xq9AhWvBNfzLr6AitzIpyiIWOmg8aAoAuFisLziDd5sAfKg3IXVWQtUQKDpYhpUvCB38ilihQIRCsidCqgVD8Exh855nspLcbfNCEGxkALLXZDciPJKgAK1yUO8iYY3VxAByQvDXby02yiGJYiTA60xAVY6QLXbjFu7oTPezA0YA8NrchcEogIFB/uET3FbbnRPLpcLkl2vVyANBkbZnZluYHfn/0ce3Otau6iHWb7v5x3ft/aPt0MSEaCJ0lCGkoOg4hjgAEA0nAMI0VLSIVFBiYREkS4RBUIRFkUSgUIc49iJ7WzvteZ4n5t3jDnnWt/62cGioJi+rhmejuOQB2FmAPlOEQFtt+O43+9nOcMPaKBEhKDSwmJ4YQsIa2BoZACVVy0uFj2tIMTl3NYZAQHbk1cxYRCvfNqWEmYm4gs9OcOTVAupXUClLMEYp21GsQJswN2lGM42SZIkHhZe7i8gH9TwUSmQJD9lwQ0tWYq2VbZzjqmAYYAKrJRqHC6Fxm8TD4FAkUBc5EmQJyGa4/B2vLy8VHM4N1/2zlM8KRetZoYK4ju7Wx3HEVR8SS7JiiEP8p32nJk9V4aLVrxr77v34xhAEIpLxU+Ido7h4mI8yWUxeYgfUi5qEQ9qWMj3zNN5v/N91cwIu6fKU8VFuoAC8cpSLIjfTj6k4YMSZuZwOpcvGMZDs7GEYci2ezYe7VIENRyDkBqgkIL2BHGJb0WHM1hUUIJzgWABkzfpdBpC8RBEirypgN0VRqlAoIftwRl1a3fjnTwU48u9T8fn0c41jIkJI8cmLGYOiAqcAXyi5RKBiAYCxVPIk8KivBJ8oF1heZAf0YoCasejgmp1iieBLjAzfI9gUcxMxFNPKiGEOPGgA7Ydjvwk+biGj0qLi/KTFFHkTcdxzDH3l/u5zXFDLsVPC+pw+LFou/CURhCkLCtIPIntzgyXeJKAuBTvBBW6ONbyTt7Iw+12mxkg4o1dAOUh+Y5K8SCvYmZ0zvvJg0ARIHLpQvE98WCIUPyUCBiGb4mvkIdUJKh0dtcZQKiAdoGKdxWizMzuihf8EsTFIF7JGBQ/IPJKko/oxgc1WtuuM8ZPcY6jlxfelXs2M+h5Lm+2UAH5jlzcLRomIl61cMSDKG8SkA2ZsXhzv99nl4ovTbRuxUXUAiPMppMTQR6kBanO00+fbvfzJGAmpjl5GnBhEQoWdDrPu4NyKWAKaDwoBAy6ECBPuqFogFA50wY7TqDEAjo8CEICsjBAXApHR6EQ5CKk0IKRjg/xrgJU4DxPHCEKKi67MDAHGNAQIRCvDHljoAbFxzV8WBq/TaDMWPHGV7sVKl+KnxYiIPKFogB5StiFZYAVJGgh4ikuyaV4kop3lfIg1fiGizwMyINFCMpFi1cRJQPJG0UgUP5igiB+aGbOc8eHeCgClXdFwcgXHBEdkDepfE+AXOKpAipeFSrRw3bhQemBNwKCGD8kD/IUH9iND0qBxAnkB4Td9txzd4YndxN0dvd2u1X8v3Fsi5AfEIgUqVmeDBYCBHbbvIz8UIYjXwqVi4AQIPIFD4FaEQWNVzltnB06EQgS595ut11YnVEq/kLCeJCnakaeoot4OXcFRxACJgIheSNKux07HhEPAcqrYGvwPM/jOLYOnZnoAngBZijBcXdVbk5DK46zrSMyY8qXQukCyAd244NSEPme5EEIUBZOFIEwCoIUIb5jJN9TgDwEBPJjQkBLxYDAsawGxOCBgxAXLxUBpfIt+ULEgzwEyLviW4G8CZhpTCkeBIkw5V2FqBQ/RVCBIJA38tN2UcHlIlGEPAWRxYyIyHCpoLgIhsr26fh07vn5+LS7gBgkl0IERDaRIC4iIQJBaLE1fCtZERLiA7vxUYkSC4eQvApMz8/1lfdv6H7ntmkrBlsy53151XDZkPgBnzCKuEgProDO7JAzc5thd+/CVxAMBQSz3O7HnBOldU5AGtDKgyA/aYeH4UG+ExQJaHGMnLtz/Hr6PN7uwejI3M/tNl8fOyvLihK0q5KiICrGyhI/EII8GIIEinJsscfqy/lSBzt0JBCIYOfBN8fPAwk5a1vBBORpE8j2uJ/AEazcB0IIKJ6OuK1AEDPEuLX24uevb191m/G2hQLJGwkwKJAP6MYHJU+JgTwtBIvSX5mvz9/5a7++z6eONZrh2LxwcSEgHnZDUOgCCohKXHTlElCNgjpwwMDEp9/lN388L3rGLA7Fw1efPv2VX/081DucRzvxKgLBFCa+FCxCw0MIDUIhxEUE1Pueze2vf+L/uP/6cCGMuAQ/P27/xi9/fnz98jmE5BJQKqEYokWs7PCgARVNCIZAyJOCy557LuTxb/7y578/59fOcKxnCmzcPvnLn3+6ff35Zu4Ji+CoNJHxShCI3VWDHRoKiHeiNYtKrqKOtsB+/vSrr+ePj0/Op+EbvhDfCkL5iG58VMqPDA87HMe//NO/+9989bt/47jrfiPnnpx1P7+WE4FgIaDtYhwzwXme6Cg+8E4CYgqVB53D26fWOT79EV/f//wPP932hY3Pn0M8Pn31x//4H8zf+29ffvObzru7nqsD2AMBwyXlIk8RrJ4EnhBGYLAwdAME24A92/5Jf/71v/z9z81CAxwve+7t02/+6T/89f/4Xx8v93MgqAi8UFzCItptN0nU0S7EdsbFIB6EUGnXha+7zPy+vfz6D29ffQbyDhrHp6/u//j3Xv77/+x42dvY+XLuC24tFbRLKW4qcdlArAADk3gKeVgUwhDC1LE9bn94/ul8/X/jkvzlc+ODkt+qOYb503/wd//kHh54MhzcunDfTr4TjYoCteAl2nMBlXeyQhHoQCKXcrnNdPvkp4mX9Ygo7Pb58x/83v/8+//r/3S7HWzbtukAQUQQYIgQCvHgwhmLPAkSIAYrcSlDOPC83X72q19+ddy+2bIo+eqXv/Mn/+jv/7P/7e+d7Hy6ZWy8CuRiVMZFZQQ2YsEHnkIgILV4iIgIcDg+3b762S+Og10IBOa43f/FP/nDf/qPBj5zrLwcPAQjChrQcJGHwB4QhlC+FUG8SUEoGbkJuH396dM0n9tA3gnGh3fjLwfjkjxp/OzTp24btUcwEpcb3PhWIBc1HioiYAIceScXJUCHixAQINYUdcwY9yQdz5997vj8+Qh0LYYHofhORSCXLZCH5QujJIhBvBsF1LDtHlo07DBsnz9//uqrqZBLRfyQiMol5KGAoBCVy4aoIMSDbR633VXIc889mymz8GGcX/zql+xWB4y0bQE6yEDxHVG5CPFUISCgECBPswmhdh4s3G4d7D2DeNC4HEgOH9yND6p48IGf0AYYREQC8gPyTnkTGSAg8n0h34ongRAk9Bg2FoaHRTa5xGLKG/lC8RCXjXfD98irBHmXAoVcZCy+U0sgSBAVP0UlviCXqACRqACRB3kKJjYEShwuC/GuItD4HkEg4reIdyrfiqe4RCBQC3ShyWF4iHcCcTFeycd04+MquiyOPBk/ICLI//9yYfhXauOdI+9m+f9AviPIJTz5AVH5sWjjx8SRaEMciTa+EJznySUuYkRbyFNEFwhEfBpAVH4s2viLCXKhuPRAb0YYvhUIFa/kg7rxQcUlAflW8qaEGCielIeInxSpQYG8kYsYEBC/VYDGX4B8Jx4EIaBAQN5EFIgPFa8CUQERiLgEBBHfSuRNvJE38SZQeRXv4o0Qb4R4iu/Eg5SAEN+KgHiwkIsgKA8R8Z3kWxP/SvJ9axYPRvImLvFGEOIjuvFRFchTgHzrDHY5//zwc3ZGGIjKG5eHIC4REAqIvDnjsqPYUO0GjgEuTzrIy2+++dnPfuEx5zIGA8hufnPH2PPOPEEBERjYZTdQvi+sdrdjjtvt8/3lTlBb4qGCutu2o84gSdsWMDNIhUKkUmDxkPJKTHkw3lhxEWEjQaCAAEG30D33/s39F7/zO7J6khHBSHU/kdo2DaJABQSK3UBSUHkog6D41hggaIJcXEg63btKN37h3pqXGBAX2xomAfm4bnxQ8ROWByFu84u/fsznkz36DBOJyrsgjAoqYAQVk91CKpgARTgURjSBTS4C9Yt/7dNv/uifef7an82JLpecn83+rb96zH3rWOQ8gYqHIWodb7cjkouAiEGx6gzgcfDp088s4zgONnYBRdBDuO82BNuCS1uCPCklAlEKRLxSNmFGggLijQJHrTQ+zAw+rAbR6Kef/+7f/4d/9M+/2U+3DBBwO/1qfud3d9eaCVdlhoJYYoY5FIYHL0CEG+AqxNMQOUAMwQBJsXAeHbMv/frXnK0I8k5gIT60Gx9ViDwJ8Z0b56+PX/7b/+F/cfubf/vPvvlT+Nnh4cglnoJFYHkqhK0ZxQTkIcJsuc2tIpBxIlwQ2PP85uxv/sLf+6/+0z/4vb/zO6d35tzGfv3N/u2/+bP/7j/+d+5/9kfLsPvV11y0gAIMJBBB8MLFIAhPkVdDgqDLQ+CFN1s7BMGv/upfSe7l6O1AtrgooQZIQijBoLDboRRPjj0sMIYRlzBQErTWvX/61//2v/ef/A9/53//vz7ffjU757wov/mzP/nr/+6//7f+g//8j//FnxzHrKfapAYCCYYgDJeIjKcGciFeJUimOOSKbCbLed69/Vvf/J//y3/5H53/4g+mAZG/VG58UBXIT6n23je33/2z8/Yn96/sZ4fHzIHRBQSCIEApKkAFFYhLXEzimNsWS+JoNQXWWb8591enzS9mZuWuR6HpcT//2td/+M2v/yBvbp9fhCAeBlCr3VMBAZWnWAEDipakTJJvqXxJoRf4xc8WuQTt4lSYSiCXYEUuRoJQDBCRF2ZbCtEUdgEVjJLLFuc38+lv3NhxIIonq/n8x/7qn0v3l2jkIiCXErwQMEBRAcq2kPIFRYLQAUHapqHOlz8/vvr5y8/HT8wR8SPyLpCP58YHVah8oS0JjnbMffl8v/9i5LzbzvkiIYFRodjWOObuOkNQgBrsrjDK5bwHW5MukGtU3MRjbgfVDZk5YHgqtT35zXyar+DcWtEBd091FiSmkIeQdwsiuHuuOw4MYAvyNMgXxEp29zYHlrKnzqRS57l13G7W1uHMMW3RbogIQYJreTs+OUSdd0ahdjzAc9chkuaYPWfvZzrikSOwxRjn8fLrz8e5QgehUrFxkeVJCCjmcM8FHAtCeZA2LwPIpUFcNDib22zTcd/TQzlFAhRBk+TjuvFBVfwWgoqEYAQLBpi153ocWDxEOoE8VGo8BGq8ioe2Ph2zG0hAohLIKydfARWt6BogryKk3bOAUaDCBwqIh3aDGcMI4iFABSJ+QGphxeWcRtKg8zxjb8dRZ1BpBCRoCcRDQDRzO/dOC81hnTXHcfTkuJxRFMubQL5HVJAKCATiTaQitAWi3O/34zjU3S4qBl6WeBMIcTFgAi9UEA/yJBgKCvJx3figogcgoMLx4GGU5M3wpQqO41gqkUMBYbRdntTzPGfmmKm2eDeKbA8OIpgU24p7ZoZAxaawK54trLBwDOwKjCZP6vCwxZMQoANEKJctkJEDl8JI3uy5h3769MkRJSpnttDdPn/1qbC4yG67d0DFB6ASBy/33dGN45hKTM9z0eO43e8vjui598EtiAIC4zIhQSANxhcCUagIBSmUmYM4d2cEgV2gGS88FRAgF6uFChZWkO/Z9nBmhPi4bnxUgfwWw0W0TvmBQgtl6dwAwyeetrsjbg1fclGghplzV9CpAB3EkmB5pfSgbCCX0T1PNRqH4t0WX4jvVDOzrahcWu57OmZqBagztmfbnksK6kZx3Obz8Rmi5QvqFhLt/RwfgvuewnHcdteZiieBETlfXuYw4smZnLgUPxAE8SDvhHijbkHgSHGJV8YCxzHF7gIzAymlPCxIDg8C8X1BIsQlLvIh3figIqBSQMFI4mlXTsa6ywGsPAgIzbjnOvKk8srlwXEqyssMnDzIg6mFApFPo5QIQoCK7GIG8SSUT8RuyrvknQKdp0+AY8IyDkQboUIiI5eVB+f29fny6RihZrcZancTK0UItjxk8YkaGORpPLILpBIgyKtyolLgmFvdgeSNTFwmCAgCuSTv5NIF50JBvFOqbW/Hcb+fF3COaR9UKFoUBUSZkTjPF+QiBigEBKgDnDXKxzN8VCW/nUgqeKn4vt11JJRx+J7GtgUcsNoC0ngoz7XkohKVrKxgDPFKAYm4JN8nxLuNleVhd6vjdlN5atvd23G0UMCICojxoO4uBDtjW6AiK0i1LVBUgAI2Ig9xHDfAeBAxTgwQRaCCYJV4im/FQxBfCpanXvFDFrsVUEBAdRzH6MvLfcaZQz3vJ164iFwUSQIEwjJ+JEgQDEI+pOGDiovjdyo2NjZ06zxPmXZ1eKqUiwooLKNBXOJhKrlUe+Gp2KWleDCetqK2ccQaGuJSyUWdh2MugA8D7p5qBajUIIVS1O7yFITkuSmXMHSmmpiiqPGCwa4iD4Ib4Rw6lYAT3m43ngIk2V10i41NHo7jaDfaFlCBmhLkW02QXJLAMAxBAmH08DhUkKfd1DkOdUbA8Smd3eUihaLODAFeAh15CJIHU4HdBSO5xLuA+MCGD0qInyCvpidneGNEXOKNehzH/X4CIshDKG/UIVQQ5CIXFQjUSGUD+RFB7AKVCtTunjPD0z7NMdXM7HnebjeU4qIVoiNCPO22u3McQKUC8aZAeeUTUlzkMjO7+/Jy3/ME1EIdBeZ2cCl5aFO5KF6gZoR4UkFCfqtACCoKiC48tQHRbqC8Gh4EbnMo9/tZ8W53K6DiS+UF+RHBoHiQD+rGR1VQIG/GiXhSx1m43Y6zdhdEhqMzBQx2S5iJBWYmFDYqkFRQQnBqpzAuoxEwjsAucRGEQA2qbbkUw25ewAeKCeegWM4acObcRQNqdDSgU1ALYebYUtG9n7poW4nCcOkChowWEE51nucoShkVQiTEnqtwHOcuTvFKakPA4iJEW87gIsVGRQ9AtW1Px+3Gdj/vgUrMHLLA/b7hKLi7yu6qEBhd5jhoJCCgdaRRIV5FCzW6xjvj4jJixEU+qOGDih+q+E7O3G63l5eXSuUS1KjI08zsrhcQI3F3AXlTqDxYXORNpbYLqBWFAxjfEoSAIl71hsoZioeEChAon87z5EnlySdwlCeNV10AC8IZpOJpfACCygvMMVsIoRAq4MzuCZI81ToT6HApEBCBCLoA8hOE6ptvvjnvd3WUCvZcZ1BAnnrFzFQqUBSEAgKjnz5/PubgnSAQKD9FHrxwiY9r+KB64HvkXbs7M+2qfEnjTZfdmaHmcthuD1RyHB48qcB2EQWEUYFSKcOodVx+oMtoCgxQQIXosFvxdMzcZuRdoc7wqniqtqKg3XZBLhUotbfbgcSDIFERXoCO4+hCxO12iECBVDNDiZCH+BC1jVSAT4yXccBLl+1wjOGnKJKg6O4GuwuMjlZbOhE0I08+HGC7EFCd9/vuAsKEYUbAUvwEn7isoHxMw8clyPckyULFk8qPxDsXF4PO86yO26EW35qZPc8KiGAxoFcEVOfucbuhXCT5gjNznudtjiLiSSUofOCp2uJVqYEa36dAJaiAytPoee552UV3T9gZA8Z4CNsuiLh7fvP1N4DKu4p4JbTbdjtuUKFyieq8n/fzrOSNgghBgjTy5MMglco7L6RAuLh1ivxAcVGUN+FiECDIgyIgPxCc9XK/b4EgH9SND0qe5FXypaBC+YI8VLTz6Tii5KHCGdbzHswx7q6lVipuGxVzAXfXGQLqmPBrznR34UiIVwpYe+6phMbEgwoUEqDC7o4CzuyuEKhAvBFQLrolT0oXRhzX2HOkOEklLhV1HEe7HjPOeeaMM+2qkcpFamXagKQClFcRoDgD7J4HqAdy7sQpDypQXHqYmX2i1FEiigXEGXdXAUkgoFAK7QlXqCA7VECwkItFQiCQPAwwIPKBDR9XxPctLO8UqHgXD+Mcx+1+v++uBstTNTNA8WRAARFvAvbSOccAQtBFVhAVWPmCDpdKvq94CBC2Pds5DqCnmfGJH+mJVxVUKoLejuM8z0rRgK2ksRGpnNlzX+4vu6vyTuSpmhkILyBbPFipPKkgFwXlKV6tJKvJK+U8z5npAqNohPbktHvHeIqnindFYRAkQcirangVD/J9AYJ8bMNfTnX4UPGtEKLa23EUu5Sl42i7cml35+IElRo4zAxQAbXV0oXNTazkt3HGBeJbglSgSyi6bTTH0WU3CIJ4p/GmGmXGp93t6dw9bjcIxVH3UsioeInUcRxH2wUq3nnBSm2jgMIZntTdBSFAjPiR7bIo73QAeVCr5WGOGQcGZs/U3QUC9HbcyjAICBBEHiJAeZAHFzCQLziDboF8XMMHlU6Mw08RUb7PsQdACihmpiKIy+76RIDFK5Hvq9TR2+12jFwEUfmRNhUE5Hu2ZmZ3QUGoxPM8Zya+R42HincV39JxhJ44jrbz5d7up0+fZuZ+v5/3k0txEUSNgFrkW/t03A5gQR3H8bzfgVp+mgHyA0GgghXlBc7d6jYHDwK7CxzHEag8Cff7XefCk8pDgMiD7R5zbNGFJ/mB4kkE4mO68YHp7skxyKvhQXGmOs8TpXiq1OGpkTy4qHDUVvjApYVuN6HdU0fkoeOYkqAW2B2nC6hbfF/FRXYX42lFENQtnyqhOOl2zG6jQHxnlKeZ4VUPwMxQiUzbuScLOsdx7sl5BsccwO7qyHe2dUaPWmTP9V274DHTFiFqNTO7O8cAW15mOLkIMr5iAR31djtUHgIDdZSCCFZg5ElWkVfheBy8vNznQAjGoeJNbdu6nQtCgPKlIDhohLjIxzR8UMaDgvx2Ij+gQeDYdp47M+16mVEqngKkUCGeZqYHXlXbgsqTFD9FRH5IUUR+SKe24lI8BY61t9sNkDcqT+ru8kZioTput4iLCgLFu0qsgD3PtuM4fOBLCsRFHpTxvJ/gzDie9zuggPw0d8/aYwZQA0HlXVzkx0S4v7zcboeAihQgoFwC6SJbXEr5KYJ8aMNHVvx2UkEgT4JQARUBIwMGuytUIAWIe24tXziX1t4JEwP/D3twr3PpuiZWeYz7mbV2txu3hI1AMiIDiYicjIQACSEhcSgkhBwJJ0DCKRA4IiMAtYSEACOwbOOfdnuvVfO9B++cVbX+9toGEX7NdQ3yxyhaKx6Hb4J2A/W6rt3lTZ2Z5/OpgzqDUrwV4l5XtdUuUKm8qd3gPI7jY86cT2cex3nolHXOQbblbXedEfb5nDlq9Xw+d3sjips64swA13VZ5xxktJoZAdkF5NfcDQRRtFLTIEBRsIBD8jPxMmd2FxCJHwloEi9zDrELyC8JA0a7fGjDRyU3+ZeTb1QUpQS1gnW4rmc1M5Wg4cY6KSoQVCDhG2/qnLmeT6GCUH5Fkg2i4ue03XYfnz6pfGNRQu3tzMivyZtyKwoI5Iu49bLX572eMiAIVATFeNWcaV/mHBVQHt99mnN4kzeBgOfnZ+LLBNfz+fnzZ/mqkPi1hFgcZIs3gVIBeTMMLlh+IVxpxmJ3Qd6iG5Dc4iWSgG78gigf3/BxhfHHhcZLKnDm8I2Th8rhNtoNEAhEdhckSRs5xTli2nZhsLQK8Yg2lT8QIMPLxBfC6Ci34ptuMOeg47R7XRcqqO3yFsyMCqjddoXA2zTGsD0VZNsbJe7my7CNirc5A9RWu7HtdQFzBpTa4mXOGeTN2zme2V1kd4k55MWvSLAWbFFCNVrxEl2Q3Ax5i3C1oih2ISMaUgQj4psoh6jlliQ/CoLkAxs+OIGKPxCBt2B3r2t/+OGHds85wL6d43XtOQfWoTZC4oLFIiDkm77a8zjyUiE/UrnFVxE0QDeVn6kAdYs3Z5yp+EL5mUDlmwoIKt5298zZdhxuRWHI7oVy8yVeave6di++UWuBdmdG3efFWwQC8iIklHXm6BC3CETjF4J4SRyBCqjUCkioiJdiI16ElFjo0+PhyxRfaPySii8LK/ELQvKxDR+WFASIRcVvCmVGxtvuRupIMdoNtsYhKrk1ImBCUIklGOxuBA1YM7MV8UcUxQDyh+Sl2t2Kt4pfsvhGpShuCgRqBVSIpNO6zx2lgMoXfJlzzswB9tptYXRmdEQqlBdvFFDxxYY6s7vxpuz2vGQA4ychCAYbMDOAClQg4A0jaNtaEQIrFdgCQeUWRQLyTYohJL8SBePwoQ0fV9zkjxMqZ3Sq4wSoyIt8FdKuI7dCxV1+JKi8qSDfeIMK5Y+J0XPmuq6KP04FZqaamUrlt1S8yZtyU0hASCK6OYIRUD2fz72Wn6lUoHZmdtNpuan8km+VMxAtbyoQJA2/IgiCfBUvu1udc5A3gdGZ+fT49DgPiJ8IbHELChBF3hwZd1OHoVSInytApPi4HnxYIQNGNAoSN+MXKuJNoBcaB9gYCvac2X2ig7uF45D8yJe9Lh2FeHGCNs9SIr8it14QhAJ50TbeAm/QF7voXhcaqBWg8tYN5pzdBc45u9uumpbH87w+f+eBZiCQYYCZUfkm4m30uTlsC92UYkvwhsgXEQQBhdILtxk9j6uWKEgdRx1HFNDexheUInQAXw5QUSFRqS3iSK3CEMHKQQ1BuUJGAs6gw88YtvbCx/Xg/0d8Fbg1MwQtQqjg7upEgUqB/FwFo9JNjf+3AgVSgfhJvKhAIFQqEFCj8RN1d2emej6fM1M9n09KvXapOad6PB7FjGGtCATtRoRvfCHxIkYqP1KgUvlR6Oy1KhggFbtnHlARyM8ENQi9gMo3WwKBbHU9e5u3Mi5qnIBSMQiiAnSGvbbl0+PxPQkUys8FKF/IxzV8UPL/RTUKxM2yGgdQIflKTsUXiqKAursgOt64nZm9WP6IAuacrQ3lFu1uvFQzI+wudWZGz0wFBBTgbWYrQNGZ8QuYGWfUmanQdtkL1CkXL8oWnFEptGgTgTNTqcUXjgMjMwNUjoAKOMM3IjAze10SLDBhvAUY7Y6OjgrbCyVfiebtvAG7S3ucM6cbbcXN3RX1QNRu8TIKtYH8TBswWtw0Pq7hw5MfJclK8oUgVkAwylcB2jl+fv7ALxU3kV/bWI8z7nUVt60ERZD4Dep4IF7kFl+Mnpnn84kvvQHX7swA3TQIPn/+XM3M9XxWM7O7gsrbaDDatsXjsbttMwOpxJxpF3Vmr0uYM/wx8U03x3aB3pSfyFdh3OSreJOVJL6K+ANb3ngRfAFFItyRT49P6m7nHL6SN1+IgJSGTeRtzkGv61IgPrThg0rFa1+AIPlREhDG0syoRBDUarG8nTOQN04rnJavFAeCrY0ganeLcleckEEFuy5u8lU4iM/nEwL5RhC2l9F21SDYXYoSUEHYXfVxDqVSu6vyVgHXLrBFPc6hKJW4VUiboDjOGWWvBVRA3Q2Jr9Tg+bwcwSXkjwlmFORFkC8sEGa2rl4AxQkXN3a76vJ47QJbgoq7XbuXb8/rqQLXxS7dCJjRbtyShj1ee3ELg11jzgGfuxjEBzV8UPKiqHyzsJCixW9Q3ioIFlYDt7bmnN09jwe/YemCrQXnHBUobgG+8McExEuAWvFL1aiAL3xTATNzznleF6CiFBBfqbxVijdeNiJEvkhtu57XXgv49rwu3uSLbnzlC1CmyBfxkzgzo8/nBQxO3IKVBEuXVhKQl/hJM874+fPncSqggHjJEaiFa/dZnTl8E73wFiAOIIL8JH4SH9fwcUXjiHwzMCAI2wLi4O5GSLvqzKnUbrtbwCiwuzOz18LAUBKBKAoE3UYpx24YlrwFyY+KL8YZabsBcx4oEC8LM6MGanxlCQsCJQTozACCvOi06w0qZ3SASnGGSMGXOY4RUKCVUiHxFmh0g+bMbjfFGWTO1DqjXNezVuxanWCUbw4a7W4bMI6OCtGNNxUIxhu30WC33RVn3NoCCvXaS4QjpwQBNZCk2QVi+Zna6MyAfFzDB6USAfIbxAEEoVFzcJSt3U+P78RxvDFiF6NCJXIrandnxgTJ1plz5lzPCxW5FRcWAuGG8Sa3Cvki3lSCVMoZeamECqj4RtheVGDfnOGbbSuhmpnn87qh3Iq4zdvnz5+v5+fKN24VjTcISuQlcduizfGGfv78Q7t7XUFtcc4DEAgNEIH4mWADBEFRFPmFiaMDA8IZocecGa/nJQgoKMhLu7SPM9KIsIUTVsqL/IYE+aAefFCj/IxAJF9UPH73/Xd/4y//xfVglDlnoVYEPmMOxZsOD8DbdV0ex6EX5POmj8jhVswMhysU5tNz94dncqDL67s+sb+D3/sGVDrxMrpCbTi+ZOUNUEBAVwI2lLcgApzZ3a5rzvGG1/U8muBEc8xuM+NM1yW+wO8+/Um1NSLUYqAzIqiDEdf1PI9P09nrOudRwFYzjFPcWm4jONd+xnUIalH0sAsCT56f53se80zX4/HYiSDCuClxswIcL+cZJD5wQBkEjMupECTHQu3xu3/e/J5P++nT/tV14kcCcZMP7sFHpfxIfk4859OfXc8/ezz/9NO/EKHd9QvYAnwZ3iTEjHwYgWIEEQih8qbyM7v7+fCvzOdr/9l1FpoSkLdUFOLn5FadOdvKixpfKQXyFqiUEKCmvCWjaCAIKERxK74I5AsVQm7OPJ97jK+8YV50LToz4e7lMFpeu6MzB+zlel7X+e4M5/O1aUFgAbtbD59/58/2d99/PoWd422iG1BIvKwmFXFOzzYQBAu0lZdl10VA8FY7M7l/zvWvXZ//t/M43/0pG8hfMw8+LhUCTSUwbtc084//p//qv3C9Lg9Le+0qhIoKKBAY7EVtATODFGpvykt8VWjEm3FL/k+4/sVf/vmnP6HJXb6qIPGcR3t78kWhBMM4e12oIF/txhdt3JKBdJTdVXkzzjm7O0qhQjUQL5FYC/ImL7Vgy4y7KwMVU3EbQd0FdmY80/UMRovruc5UwKhrF+JAzBWGbPD40z/7p3/xd//H//I/ua6lyHEEN+QWFC+yEAG+rRQYaWmUectWw8oX2pwb5/zuH3z+nr/8P1zjDwjxsT34oORFBDHektvq49r+wd+PH/ZabNnKGW+wG0JABOMLBMoVt70uZ0BHIKBQboFQvC1fhefTd2CLrbwEwZPq+uGHC5hpSVCvfY7sM2DG4vlcRwrYUVCBXuCcCq6WGamtNjAah4gGyacXc1OHS4pRh6+iQFQKK5ptH4/ZrtFcdc6DK7Td63mdx2PYjXEKah6HFro+Px+PxzkPIIibQjCPx37+q9//vb9AxQI0+Rk3vhEQdAFpeZEsoogABQHXvFE7zg+P69ke5nEe2yfn4psgGUk+tgcflVZbU1CKfDENS/PEc9vlNgqowJwrXkTeHAH5Js6DWwXEm8pLpPKNyFt2W2qkIQPB7x7zt/+886lnhjxnNIRAaDPmzNYJa4s6SjkD7XMdb9Ve16gzgGeIrgt0qEBkn9fvfven3+/1/P0Ph2N9Oqf2qtFzHt12GaP2Gc6MKX7+fEWJrBBPGoHAntdypQc+r4nAtdec2etzy/N57dWmjC0yuDl+6rvvwKs0rfaGqODwhUAEqIAgmLwEVGDchkBAUG4hw/lE1OZ48U3yZnC1GMQH9eCDUgGBQL5YGG4mmAmIAnGTN5VfMP6fFW+C/Fy8BQIhxM2uPY7zePzJd/3u8jtt4Ui8+BKRujUjCPtpTqW21fIWL3KTl0DPtMut2pyBopnR85f/+J9d//QvD8N2xe3aXbjAkZmlYA5dy5zdRsWtoFk3EY8hXnuJM6dSoC0E/byXD/fz93/1/AfR+fRAB9FQRMVAvghTEAWKL+JHIhBv8ZN4EUJ5CYpbN0BuIhDIz0lZQBDIR/Tgg6pU1KH4FRUQuSnf6HAzfqnit6i8FF8oLxV/oMhOxcZX13XtXnaja2vHDVRoaRR47tVIWerz+RlQg1G0uJ6fedNBKKCLF1GXZrdSq1E+X3/jfPKZ0gT+yfluu2rPOd1ouTlziKFx2h2HMWd4iZfhPGaQIn2cacMadsPM8/jdDz7cVKSQlwoCwxASVIabyi/FS8UtXuJHKoiCNPxCuPxcEMhfNw8+KDX+KJkpETd5CVAhvioEVEKoBUR+JN74SVQQASoRccvRS7HZ2an1FslNIRBvUeQMdJUwZ9oAgzhOvHR7XswL2A0GCBBBjN2ih0biMO1yWPn+en43h11RWGIm+f66ZgwCtuXF4xYDhBDJj7YcijkS31+XN9oWYU5w7TOCdpebL8RNUMQAX8AoEvkleQnkRVC+ChCM4aYUvyLFiy4RBMMXxl8HDz4olZdAfmbB4Dm///3z2u+Z77kCakCUCGlpyXFUpMAHEKGAgCOxKQQW1bYXMGeCvbrpw0/fffrTefxu2GKd8WUQKEJpA0qcuEBe2nhLgUugQvAxxLVPZyC2BgISqXBmlAIFFlDo4XQ1Zy41AoWIucmL5czuzox6Xc+HB2gh5BcKoQ2InNkoxZlpY2caIlgY+sL4/nk9v//hpA3SSEQJDG/uUuB4EIo/FBEvGgEGobwEwRVwPv3p3/y0XsdP3EJeJojhg3vwQYm8yB/a64fOv/Uf/mef/ta/0Q9X/gBRKA1vIvNgaRcYIZIEJgcGxDFsNdkoFoEUzwF2oziPP3uc/+W//W/+6h/+z9/NQ4d4qaAXBBRQx7l2GfmiUJQtiQArvPYSnAPt7uPx2F1EplIooAC5ye4m383MLp6KkQKBCpUXEW07M9d1oY/Hg2sB4zbRWKGUEBCQCMhNsNjdxwxF0FeK8vn3v/+b//a/93f+/f/o9//0L49jcqaAUWlQgr1ka3dDK35Gvqp4kywgQt4CvK7FP5nv/+Lv/tc9v3/wXcSbfGV8bA8+KJXfEjzo8/n0r/4H/+n+6//O/v7xeZ8cEcbtQi7CfrfA4oS8TE7AAsJpAQnFLlhYCqwQZxB3Z3zi3/5d/+h/+O//yf/+F+dvzOZAt73aiAGikhiLt8BKRSMI5BYqcJzd5OY4uytCW6MyCMU3lSNQy0w1ZzRnCtABlrfamWl3PzczzFTyk+R2lXXO2evCG+CBrlXDiwZnpn1KQ7YQYDDy/OHP/81/98//4//889//h59adwcQMCDDgMmH3fYCK37GN2p7QcSZia0VX4bdJ3732d/9rd//r4//7u8+f//3OvwRgnxQDz6qMflNQpx/8i/O53+6nz8/r72QWGRZIFd8LCksJG8abiEgBewmCwhiochBc2CxkWf8yTXfXw8xggPLi4AiGwbJLQN5m5nd9QaRGCBtEHjOqbhJ5cvARnwhPwqKr66dM9ziRwGFAjrXdc3MY2Zpo5IXFagoYWau61KBQF7kK3mpKEC+iLfUmd9///x7/+if/1//+K/+dObsJas4AsbWkoOPUxC3AgIhoNpWHQWBvbXqmBrMzHU9H/R5zp98/9n1wYknIC/xMoKAIMRH9OCDUuOPMHjq0zNnnwhYEsfDrQECk5cgbiEdoWABRwSHWxDI24IUUBLD44AyDhEhKjOQxmZiaqUi1ZwjRbQ6zuwuDtQIji4YtaDQrueIiXGLAHULmJlrN1n5NNOy7Tgit+JtAhoHjLgJuqWiFXGbmQpQqa3AG291tBuNtyMcndGrN+l2Pfz8Jz0fHmfTpAIzX0J2nypKKtfVOVN7dY2McVMhmMMExttgdebB9ZQfhtuFn1EgvqnAGT60Bx+VAvHbtNjY7bkNSNxEXgSUbyy+iYD4IiozAkcr5C0QEMU4sBC3QL7wNkhULLTEGKiT1/PzzHmcx7YUorO7jkD1+bpGhXGAcsbres6cYAERtygV2L1Ggdrn86mPM4ddlDdn2AX5ooKUWwTUdV3eZtjkq90VRgMqkHgrzpyJ3YufKRrilnZgBFypVLQFwYEFb0VtOTPXc+dh13LkrRuo3OSmFgviDXMUgSwU5Kv4a2H4oM6M3OI3CLMLuFfttgsLCws7LSwsLCysCPJbfJsZpUJ+g9TnblDrqMOb3FyWlr18DAoBvTkH5a0iFJWghJlxRq0cKWpmgkq5RTeBApxTieB1XU4BGnELCA2CeCvLa61RYObMDFABKjDqDArMTbsCqtEKmRn5iRBvQbwUb75RM96AfSN6XgQK4VbnHJWb+FaWJc2uetqE53VFQvQFv6IrzwL5uIYP6swA8RsUHBCmeIvf0I23QG7xx0SF/KZxuMktBOSrACkQlHgTaGMm2Ov25E2tuEm8qIAz217PS4lAYGa2t+2cw4tAu2ognnP2KgJEEOIWPwpQQAUqFKiomamASqX4Roz4mc/f/1CrtvEmEDdLufXGr4TweJzxfP78BCPeVEqpAJE3UZS3Eih+5Au/Rd4C5ON68EHNOdogfyiBkgRUwHgpYIFAoQ3psEAg8nLilt1QqgH5pgG2gJnt6vho4yamdEMqljeVbiJv2nUJeKMNuJ7PAHk8HhXQhm4JniloZ4atayVfho2AgMHd9QSM45xrLxzH67nnzO7KLyka3Xb3nEcsxUwlFTOzu3NOBTyfzzkvW8Duqp8ej8/LbQkQHeWrAnEOBd2AmeFWpJdDcx7ksnSdORtKKUdto1BuIuoU13OZCR6P49WzF8ByQ3B4SRw8KPJxDR/UjPxLhAqStSogqLx5IxUSX0BeuvEWN0XxjT8gENs+r+sxBvFrgTcQix8pEKDyhcynT4/H48y5nhc/M1JQ4232Wt5GjZ8IUY0jt/hKbiUvIj+jArXcdM65rqe3GaHSAeSr3aUenz4BAYoCgi/8IUF+TQV2t0Loha24HWf0ui55EQSKmxAvcbuuKxg1bt2IX4j4mQTlYxs+LCkofm1rt3FAHZjdgAh2piO0u5f2MNlrN1B3m5nadh1v6HVdu9sNaGj4ooJgZuBiwHjJ+EnxtlgrXwm+UIGISAtUSG8qRZxz9o23btyMr7whb91A57qurfM4VxswXhuCxlfV7oK7Eeo5Dx3A7TjUKHrttiuo7QrxVkJvKnBmeImbbC0ganRdFz+z3VhyxnMAedlyRIqbKNT2JqOnVY94G5zsebW1C6goXwUBvenwoQ0flAKKQjd+ImkQbF0zIxRqRSgznse5ro1b6ta1OzPbjsxR41YgNyV+VM2MbwhagPwGbxC+8E0BcotAhajrWsdxKogXd5cvFOjGm0T8nCBodc5Q23pDSHaGW8UXcpFnIohbtD2fn9vlVsDutvv49AlQ+UZenAlWkhgygnIX0oUE3Gvb/fTpk7yIgECdOdd11Z4zuZAgQkrQDc45M/P49ADanRkFukmwIIX8RPkDysc2fFhqhDEOL/KF4G5PLXb3cmRYaHi2F117tR3d3XB0VJjTDM/r6VhUwHjGYyPTjRd1i2577e742a3lRX5U6LZRV3PkR9ILHqHdLcAzs9dGKFhBcwbw1svM+MYtXmRbQBT3unSqOeOw+9StBdqtFYSLrnAMuoEw3DoON+UbZ4ZfiDe92hTYXUdwL2AhvpC31Jmz1wbyMjgwus9rhuW6uoCIm+wuKDLyldd1xcZ19RxxoSLiMS863HoBAsMwXiSIj2z4wFJ+g6DUFdeM2I1vFEjd3UoFKkDdW83w/PzD7pO3CuXmGz/nDVCTm/yaWrQ7yC+p3OJH3QipZoY3dXeBM2cJiqhgt3MO0DYzvKkzKgVERWo1Rwy8BSgSRKiwe1WPc7whxdvMALvLLwUSb0lyk5sSbrLyIxWI5U2+avecqRWwdZdU6pwDERSwG1/IzFGfz6eTtLvIj0QUEOWXAkE+sOHDipeIiJcGDqAw4F6c8yD5Ro4+xNucuR0cCIovpHOOI/KVVtfeghPDm4oVx4lYfpNwZgCVK24lCI4zw63G8S0aFdoFVECsdnccHfClRitA3d1utG2wFYGjFTUzu8moQCQKhCGcc3TavZ5PShAEdIvirf5v8uBd17ZFTaxya38fa+9zURkXlrGEbBwQcAlJMCJASEQgkfAGOCLkRRBCgpSMBImUhJSABzCGwGAJAbIoX3DVOXuvNUf/G32MuW77Zp8inP6+gOM4KGBLrTUGWxbUeIiHZLug1s7Ik0AX0FhFp9x1nEJn5iiw6OLTjG2AoCKX2xyD53m22240oGzLD8WD8YYNb55PfKULMGAxc4AVTxV4IQRCniTiQUDU4Wm8ICiIfNSTolLKz4uLCkJ8Ut1f7vtwokF0IS4qoAK7C8RDPAj4wEVUoAvJRyKXQol4aEGBLR0IGC3ULZUfUWqUrwRbqFys1N1VeRrlRwrwAsWrik+K47ip57lAoJ7n+f79e5U65igu9/vLea4KATOz5zoDVGJ8IfIzlnjbbrxlprCFSiQoDKFTVCDkoLmKxFZYbql1+sBFBWHBdhDHwQyQjS8OpmVdlX+CQolLpAbozEA6xIzFtjPqALUIoXjh4Tzvx3ED9jxnRIlt1WMOXtXM4Xi/n984ZalDQBSmEkK0itM2xEWBQFiguBSvfOgJ2PKCW3Mc7UvEz0tJhOUhSB42IOBk690MUAHKcQyQ7qYE4w0QiUvAHOeuRhzHtLsz4vIwgVyCCQI1Pgrk7RneLMEgfiwoQBCEFHkqdQscZ2uOAXlSi/v9PM8VRWV3z/O83+88VRCfVApKyY9VQCTIj8mTQmoFOBLV7nIJYQsM4gvHgrg4BlGkArXn/X6b4StbM8NDvCpCFHRAvhJQKlDxUyU/UXxFPtMZio/kK/FwnufMRMAgoKNTCQRIiRcg/nyEoGjpibdreKNqKUq88GS4GBfTBHkwpAHaHRWoUUJSgfM8geMYFYbcOmbGB5SfUIkBwVD5CQWpkM96YNs5bkFtFIm7W6lATzMTUdRx3CIucamA9qSIy+6q48wcC+cuMU6lojh664zLjDOzuQ0gW1vxIKiVMMqroqjzPIPjOARhwO1w2oIkCYwJQwTalVcBXkA+OuZo1w46wi1gdx25yHjIIJd4CAKUp2Al+SR+SJlR2Vbi7RreqGpMiC48JQmGLQtBPImf8ZmLi/HkF7xS40GFYHFxgWoUWDDB+CWmERCveqCZaXdmQKCn27t3Khe5BAsn6+1QKxGIB7UHAS8IbHuZOWAFdVtn1N1VwXgVFGmwvCp5iAd5iC+CuShQ8RQwLsVDEJ+EOCpugPyED8SOxuIZe8xUc0y7KrC7/FiwsBB/MBXKgIi3aHirivgsSB7kom13OGF5qna7UJDTchbKRVFryl123V1nRoUIgy67OQOoWycptclKxS8IlhZE8JgRvACyu+Q4l4onlcNGYJzdBbwAeszwVKm7i6gRodYJzhip7XIpephjcOGsU0MqanRmAEG+CIIgHip1FDhrhXE3EPmaQDtg7S4SiDzFxZlRxkuYchEqLjtyzLyTcaZXoOhqCix/mCDYdnkVb9TwRlWaQHy2sIBgzEIQxIPKJQQqCreC5SFgN3Aux3Ge5xYP7q7iNDP3+x0XFwiQp+IXCAOCYHwtKuISXc7zvntWQIHjzP2887SyEnSeHz586Ok4DuC43YLzPIGZgQJiz52ZdmemUnvgI3WshTB+gconlconu3vMVPfznHdHlnxmCKKAQmgwfFI8iYBaCwtBgApdXl5ezhaIBxW6QLAQFj8kYMWPCAjEQrxRwxu1RbgMDMjDwCBLix5iyJMD+ERQqDAgDE/qcQyXLspQEaBUNNAxw5/HbmFRiEEXcIZXcRyHgs4cOhQktNvuu9s7oNpduqzj7XY7jsOZ3RNBdlcdR42673EM2qazpcaD8lEUzlT8AmecobjUzLTLJypP6nmewcwR8TXZAsTZhIivaTxEYFmEFU++wtZjDnR3C5VPlDZFiAcx2F2UrwQrScXbNbxRFchH8hWJ0CFAHaCCeBVPUnytB3mKSgUrUOSnCkWIX1YxoxJIKlDxFbFdoJrjAOMHfGBLJ1DP82x3bje1XXmSrT2bY3iqRT5SQD4q5CvK19SZPc8P79+rgEqpfKUSVIr4JF4FCMRn8TXxCSQqlEuBfC0ucUkF4iEeCiQI5NKMIz8VKMTbduONMtAkka8FgjQ6OvHQAjnTBchR3C1RhotQKBcXwqFGQWTP+8wB8hCgUgtut00HrA0dufTAq5iZWgqQi8C5exwDIhBw7sqDESCDPAxSAZHKpdoAsSKKS3Ce5+EAgkAQaSWXocJxsN2dw0qtAEE9jmNra2Z6mhkKWCkuXlqiPY8ZPSp+SHRMN0aEIGK5d/eB8Xbf+zGEIElUKKBotVImBGXhCM3YRrXtFhA6BILE0zYzxiBv1/BGJZf4QpRXwhR6CILKRSt+QKIC4yfkoYBqd2+3GwkIYqXuJorGg/xIEemgPMhXqmOmbc/zmIOLfCVAfkzls/ghqWOGloeKj+RScVFgjmOc8zypmdnzVAEVqO6X8zyOQ91dYGYqIIgHBS+zuyAVxUUgfkaA8hTJK89dZ8qieBUPatAFEAKly1aAKCDxmSsI8hNCyBs2vFFFMDEhVFSL8eBlqo3zPHd3ZpSt3Z0ZJWgZDz2wi4AGgTAOsC3iBclaLorODE/H4St+SXwmr+JJRS5qBHbu+IAUtXO73e/38zx7UisViM7zVKALl4q21Rm9n/dtg31Vo0C7QLvQKE+jFFAJgqBcKi9AyUeCEg+BeGC7W+MASZIEyUUutalcYnSehHbpoh46wJYgtEvFR0qbr8ZWYguQjwT5OWOlI4K8UcObFZAsLB8lCSRBtZoPQPKkPCjgYjPsnjPED1S7exw3MELixGBVntRj5n6+4MLyT6NAKPFFiNCeWzvH0dM4c8w4e78f7955DKEgr1QuAhbyJESgwyV0CEUYqxV0eNpaWaklCOISrDQW1czwycpK8kqoiNvtgEBBhfgkHlQuMeOeiwJFsLvVcTsUXVhYUEDRGR1gIR7kQcIEAjaRi8iDPATxswRF3qLhjaqQHZAHxQuXBBdP3O1EQCA+Kd3lRGrrnBHQ5gAW1hmfds/dFIfdVdR26bLbPRaorfhlSlshWgheOM+Ti4BzjE4FOHKJSyCNeli0q/Y0zjFHT86obc6MR2czt+N4N85xjHPhQdEusJJ4mdlCkChNPhqJhzphCYiPhMEJ2r2f6u4pVHxNaoWIS80xPFUqBcH2AFJBjtB5vpx7Kpfa4jy3bNFDBziOA3lVXM7zLFQIiC8CJB7ibRreqArjK9HCYhTBasql+Ey+qNUgWDi5lCM+VLt7zKFd9jyP21wUZ2OLSy0EqykVPyfF+MjiyQiN0LaLT7vd7/fzPAGDjbgoaoW82vOMjtuxuyCigtnGpYgncdIAZWbUIDHOjeNYeZBL8mqHJR5KV5L4pAQReQj5eSnomHIpZMbzfs4MUCGwvHIjYI7B7vcX3JmpnZFPArTCCz7xStCV5EfijRveqArkhwYGTAIEZURlt2IcdGtrdHRri4962IV2V52ZDbVC99zuywZu8cmMH2EbPzQ64/1+B4EI6bIB46Agpc5xdAFhjnmlxKU2HkRUIECFQt09x2ELivt5313lPM++2MIZHpRYNm632+4pCBQg8iRSjDMjuE2Ku4Fb+BTG4fALRMQZZiouUczIRbdEHUqpeFJmjuO4gRVYqIEzW4A4HLueJ8UlLgoTxmeiuxTI2zW8VUH8nOQyODIgXzMe4ieCePCCEB9tpQ6fRDDju3fvjpnjmGorQJAfCQJfcbH2mBGqmWFXUKv7hw9qFxJnZndBpLhUkM7uOrO7PNguMDO7Z0TNcTuO43a7cQmQj5R2936/754gP0uJVxFQVIRaC8zM7o5WQNCF+HkGbff7ffeM+MpuxTFHxRcSl5YeAEF8qNTzPG/Hod7vd56KS1SnBIh8xRJ56268UdHW8KBc2gKkUsmWV5UKLTE8uVwGuZwbImyhtDwIAfJgiI5Bu8G5L0QFimQ1yk81csTUWpMoFunUqsRljgMQdHqCilcqyKXGocaHCqjVAS+77XlaaqDIF3ECxxw8HKgB1cnTRBBNXLZUigjiod1jJo0H4Xa7uSx5GXU0x8so0phKwJHA8rDFJVrBHhTUoNKhILpYREJQnecJOLMJ3G4jx72zztoCR3TBhSzAlgLkbRreKEEkfo44OiEI8Zn8kiJCKT6Kn+gJFfcJiHbbIvAyMnxSRIwIKOFHPARUgE88VXwkv6A6joMnFQRUkIeC3eWjeFJ8GF5FBEF8rfhkVPDCR+qMlCCo/AGiROUXbAHxAwLFUwEBKgqoPaAjtr283Pc8VcLxwoM8yT8rhn+WCIJchIEBa2HhxCX+CYo/SHFfY3TGB1AgxgsE8pUuUtBCgjJzENSo/GEE4ouiSLnMjA9Ax3FIg0CFooTKR6FoLec+BQPyJEz8yByHepvjQOMjebXtuefMcAmISwwI1Xme2/LUk/xYQfJZxYMMHuF49ECf8NB5nsV4tLy8vNzvZ7HntneBQl7tVh7HO960G2+WAXKpVCAeEmh2p9NzJeQhHKXiE/koQal4kK/IgzxF4AMFgbEILLS1eOCAEDoyBQv32k2o8yRu725tpWOFCgXEJRCRT8S4KE+OKBcVMSIHiLndXs7zVrQy4oKJiihYQYBASPEgpBAPXlBgd485dhflIUCmEopBYQs7SEAgLmoQAoEIhTzFRwJCAqESAq1x4O55O+Z+PxmJrwi7gMzMu29ux2ltXBaGRIJExXglb9KNNytYPgniowXsWz/M7YTugSbjHO+OaJeA5EEgthJGSxARX/GJXLSikYMIke3c+fW3x4ydL80fbRgIejtutz/6Yzo52X03/QoEAiFwBrnEg7AlzghSfFZcpJKPDuSjCAKE5fjm138Rbt8d725g99VElI9SFMQF4n6iRbBMY0bg5LY7ODNuynmeQDUOW+0Btz0/3G6nFKIFtJ3nvrvdfvvb3/z+N7/7zXHb8/QMqGbUUcBkK7lExisLd3Sc+57IfnOEGJ+UYDXzbu/fv/D+m28/3G73+4LgMsZFj6O472IQb9SNNyseJJBXK4gBnX//7+GvbpxCPKiLl5ujQwPxUMlTIAIFdCFeBQhhDwjEpYVx/fA979//g2Pm3Z0Pw6t3h//ow/nf/+3fvfzZ788zHHmBoeHSVnuRywo6PmHnChafbAHJJ0ZC8UowJFA83p/Hd+fd+228HbMUbNtll4tAkjA4PuzCmLN85EjRihMCUd1utz3Pzvuh48MR9w/vv9+7bn1DJ7MUM/v+H/t//a3jT/7B7Ve/vr//sC93ZJxqiUCT2tQiCkijy66068zWzBAQnxVMuy+77od37nff/d/nh394+JIDgjwFIQ9BIG+RFW/RP/wHf/9f/Gt/7fbtrwUErVbQAXr3sr/ufO/twJVLhHKR4KB3XFzoAkE8DJfiJwIqOhwdiqCRYWG8+90c39349lT3BSLYuy8v0IFbe5584kgBK5cF5DIauAnDRZ4qYKX4WsUrWRCQhW/m9qvmZTvGm3PSGfIVgwALH3hwI0SISyQgEBdFB2eGandAMC5D5/DdN79ZPXqBqeisW8e3q47tsgFtkFpEKPKqoITRWNooUJ6k+FqAlQrRTfjWP52jO9+CzsRDSXz4/e/+q//yv/ib//Hf5EHenBtvmRDKV4TdPc77r/lw/+b7fGkRBMUGHCRguCQUy0fyTyYVOTqU2IgOzc6Uc5znzoCQwvGu41c6OO5pJ5+oPI0Ew0eOE/JgfFHASHxNWi6xg5AY6Hq7n2zLTLDtuauDjkKxFSQEjEAImjwFVIQtnAefqIC0XoIQPO/v2ihucPLRvGvn5TsO701wA7ZzV1CBpCBWAuQiaIYspobRAvK1CgY4jhGms/N4OX5192WWrxlgXAQh3qIbb5XySzx2kHM9JCg+OolLfCVgPHiIP4SCayig8dDOSscOJKAgFMEZ93MJHEDl0i4QEBf5yATiST7rAsQPKcNFBoRgeBhedrANz91AwQshDykgIFAQIF+IjjwF75aIhy4goHwUAzk8nASiBufBMg15bHvfHfEYELnET0gQITgQH4movIqKCQTOuEjMGTO941XIw5Dgxpt2440SVAJB+QHRWnMw4gcC+Xnxh4p4FZeAiKAWanmIjwLywkPEQ/zTxRfxs6L4kRQikUBSPikgvogfiq/FD8kriY/ilUCQjXAPRJ5WNB5OSDYBIf7c4sciID6JS8aPGCpB8abdeKOCtssxt90TBSZeyRcqnwzERbnIJzpcjB9q488jCOQXdOGjuDgC8WO78UPyNMpP6Q6v5EGeAiKVP4zKz6n48xEGzoDiyaCS4qLy/4+oRBuvxJEfCuQp2JCPZHeFOYZ4w268UWrDL5l2GEkxIJ4iLga0JwiIsBgtAvGgkHGJS7xSfkiIi7Bj5AoLVF7AFhDkEk+BCVogBPFU/FgBYnwRBOIwBM4Zseh6k4aHxLq1YkIbcYkH+UyGL+KTii/ko/gJoYibECEkT4IsEYnghaeILxTikhE/Ecol4lXIJT6RwFPAAvksSAbjjbvxRnUBZ/Y81UKIBznPXt5/fzTfNs0q5MplUehybiKh1vIQA6OzBGVCQHw2oAjKoM4k3ctz3q2HazvRGM6c2/v3w+044jg3T8eZA2EnxhAi+WQkJD4SC9mSz6ot9DaTwZzdd++/8dsPhncanu758uE4kpv3G/JKviK5Ik8t8onKJ5aQFPEz6n7j5d3hew5T5JIct++/v7Mn3PWG3yjsCXThQSB0AhEBkQJpi0REpHjqAQlw9DjYc4554f23x/kN7z4QF4mHIggwiDfqxptVFsgXgTjtd7ff/PG/+x/cfvtX94X7wStBkidxQOKhAkR2aQk5iYfCAgQmCGG4aN72dps5cv7oeP+n/9N/97u/978d33wjGM6c739/+5f+9b/6H/2n75d5OW9bwjFzvAt1ghpFhlgCVJ7klZFYAQm+QsTOPWfmw8v9r3xz/t3/9j//s7/7v3zzDfFy8u3ufvj97/7Kv/nv/fP//n/y/h+/P8b3hgOVIhchXikoFZ+ECgGBFx6KiPjaqX/p/N3//t/8Z3/6J//rN786iMsx892f/dlv/pW/8Uf/xn/44f33Rx/a2gOS7IHiEgkMYwgElU/gQNAThaCOzoGSWxvr9Ovf/qXv/o8/+R/+63M/0CBfSIDkQiBv0Y03Kr6IeBpo9yjn3bf/6t+Y3/71+/fe321SgeNwEQ2WNgIhLkVMgiEIxEVCgjIoEiJmYHKW492798f//D/u//l35lewYyHny8tv/sK/8M2/9u98//9+P7tLx+0GvNxPEgQNbUZoz1W2uMSriAcRYYtxHFEEa/Pw5Dd/wfnVX76ff+udxzKBM3Tut/8cf/3fOv+fP/0Gbu4HQ6RgQRTwQlGhfBQQX5yb8rOKE3/9zf349V92/o4QHGFwf+Hbv3j/l//t77/73bfeO+97ro7jyGdbuzvO4UE87HaezHAc2UbtbtCkM87U2YbMDHvfl5cXdn/9F7797o+dP/qw/+ggfiQuZ/F23XjDEgL5irKc2e8/7N5+d39vHw6gAJ2jXQQWg+VJHrbUcgGHiyyJwPDgnopRCTsT4KzHP363H/abwck7CBQQvP++l9+t7t093t8TMQFBkHa30dHlI6X4TLHSYu/ncjdZZmxPIea737O72sk3H6bbnoD60v7ufP/7D7/vZG/H95wwSrshIg8qkXwSoRaftJsiRmoFykN0zw+9xPfv9v2xvzq7wVmN7unvvtvvfvf+xWXv3ndEQ+MSeJmZe9v5AkTjOO793n4QefIBnLOXanercZzZ3fLsxT7s93ges4MnP5SgIm/XjbcqfsmE93V5mW/u83IEhCDMZjOeZ6NwAFGL5BwVMioPKxMz7q5aMLMhYOESyBDdjuOcd8GsAzO8Et5NzSncwhliiRIiCKQnnsYuPEUEHMfRLkgdM0JD7AJDcHLJc2tZjkQhHZ3OF6SDnQ6gUzw5D8eR2m2caJwtQN3d0bgEBN+8u+2uG1IJEeNlobOZ1ZPTyeVVCM47znO/n9st45CHQQIhiIBgJ6OChHPPgbgEVsTpAgXqCLLKoXu7/fbD4c57jq3FBUFe5TDUxBt2462Sr6kVFwVpyBBFwApBzr23M7ejXT4SC4VixgoFqnHaJZBLCkg41czsLgjIgzCNhD0Aym6FArvbtiIggfJgIqFsCWgFHTPpnuehu4tuK2zNTMWDIPLKEJBXAhsVKrSR8c27o3MvwLvj2JyZPU9fxWUiLvIkWZJOJaRb53kmMzcVBsbUuIQoCNNKKIIWtSsiInPfHQ2V0fM8hzmOY3cBnS15CAREjC4zGDEqDi4UyU8IovJ2DW9ViCK/wJiQ+KzLHnPo3O93ngJCHnb3OEbd3Z6O44h8oJoZYSQQg2pmim3Vdkf5MSPb8+XlPM+2eAgCobgcqCAP8UodZ/dsd47ZmhkV2BL2fh4zPMSrMC7JT6izu8D4sOcGPi202y7KpQc1vtZ5PwGdNmTbbUdnxpkeKMYDBuSTaoEZnkSKdo45ZmoFZZxz9xijy3EcQAVUXGpmAIG4RIAOEL0CYWBkSJKfJ2/UjbdLgkA+CZCHuKggP+ETn8RH6u4C8+7WLkgJfeIMEIjbji5tqZT8mE8RIoMlyWcrBxCXKLrMxdldnpQ6ZwQWFDZHILjdjvvL3WP4oeSXVCgEVKAQyeoA8iqMB0meSix2Rwps2mVAEJSKEEGYdbUkEJyJEoW47JYcx1ERF6EajHjqAh5z7h7HnOc5M3GJixCxiwhDygLykfxAkAiCEG/R8GYF8clSGkKAQInxA8XWy/3l3e3Gq/ArjAiog7QFOjPHcdwIEKiACrwgD+NlW74itOdJS2kjXxEWkvXcKYl2N4gnN3bm6GlmthJKGGCbGZ7kSZJg4mtil93juBEgoCLg4QwCghDnss4Un0nOYg2Uml2O2zQ11YJK/Bz/P/bwLvb3RU/sut7vz/e39t5nnzPPZ0wzNbSRi+kYC1aIc6XIGBvaC4NNWsSIQjCxSmyid0CHKu1NvdCUa1OpT7SkgSJjWhMUmmjjwEBMhDCUNm0t0XYezhnmzHla///38/b7+6219l774dCZxJi4Nq9XSVwqK0GnFqiAuORMEIgVkCQVeJ4LjFLpCpourazt5XxGmRs58SAMd0lsLiTvruEdFXEnb0kWVoiLIUR8LPGYOc+zACFABeIujdaQS6VA0YUHxwt3AcVFByEC5KKOBoEgJEmSJJ8UdHtx85jd59ttlEttLRHkMvGGM5F8HvmMABWCIC7KRe5CPqYgr7kYyF2w664bu5acu8DtdqvES9wlSbASBHEJBYLoOI4K5C5ApbgI8ZElLzMe83SevObz7pLH4MJ6cLLOnFwEMT4hXFzeacO7KomPiNTU4MRlgHbC+IgOoAMotYFCeQEdYFukQEZ3F2hXg0BABHbzUiAt34Ng8YpWKsidQLXbMUe7kON5nmC1ESkSQrzmHRpMDHfJxbgI8glqcu4icdcul9rdgBinVgWen59mpuLzVOrM7HnOODO7J5cR2F3kMwQMCnmloIAKhS4g2oV4UMELUKlxqdYRbVdFtl4cNxYK5NJgsIDcKe+84R0liFCkI5/lYLs6RaXyUAHqPJznBpW6e/rAcpHXquM4QKDOuz3BmakYLxXIJ8VDiFyi3ZnZXe6EAC9ItBij3DUzL2634zi4k9fk4fn5GZgZ7uQNgSDeJgoEyhteEO946MLFQq1FLj3wSYXhuLsvn59QQFAhPkMwIgSsgN2dOc7z1GkXRpyZdqvjOOJuy/E8TwXxjmpGLuW4uyogw2uayKfIu+/GF0EBQryWctmOObaAmdldlVKJTCQGl4ABdWb26XnGczdHeeU8t/Y4buAoFAu2rQa+MQq0IW1EQnio9MBd4N1Wo+wmQ8QqELG7ETpjJ7UOICDIXWNRGzKm7AbbKo7KAHVaOQwgAhUQQkyRUswMpbaLdxl3TvKGM1Q67RS7XKq9S2CDimKXGOiyjVMrGC+Oo21mdheIRHR3VXTo+dzjmAU2FFBBW5HtQV6Jj0yEEiQYAgHx7hreffK24i2GpFRqJd4hUSkzvBKoe27t5TiO6MKDd1MBKioC6ozI5xNIhAQD5WMRKCAQlwgoLlGgM875fAY6vXHMwaU7x+JOIz4mMCgC1ThEy7l3fEQhIC5bgZXKg8olQKC47Hnu5Tyd2TqOIeLzGQJxFw9yqbYZK0KcObwgodRejuMAqnEqEKxEHuTXRb4QhneWICAgyEUYJCDE8ewMKmBmVOSictFqN2fQandr54ES+dgqhhGJPIQVAQJxJ2+T72G3malUQhQGgRkhQYFax+PQUR6E6NyNhwIUaXeh4TJwtJCBOnNUXEQuoiha8dC2u/IJte3KXQXMTAUSH/Ey8hmBIVbyIGcbcZFtn8/zmPEy9gA4jgM4SsLhK3S3oyCgwhAiF3kIukB8RMPdeKcN76jCNC4VDwsLCRKseAzKQ8Ub0WUrWaiA89zb7caDWkF8TLnEKxKovCIPBQGBOI6iFBpE8pp6HPP8/CRUEJYbq1Z8QrwhqMh24p77fBxH8RAkYctHBAfESLkI3gHBCauA1XEc77//fhHFa77BG7vnzEQoeIdgBSFvE5JESSJAPubdbKm7C6iIcO7qqIRQbFspagWBu6gkyN1CWHxCsIIgD/GOGt5dhshFgwUEUsDdffn8nAIqD+ruVkvMOAZIu6PH7TjPnTnU3QW2Zg5jcLK4C7USdgN8g3Njd09YFQiELYRIXjHcjMORYJMM3dYL0tDAwBEEPTgTZ52QeBzHeZ6KQncjWUBDwgC3ZZ53HCCJS7iw3AVBCvT8fCLymg/gbtFlN6ByVJQ9T1B5Pp+BYw4+Y+mUpXiQpHEhTU5aY0ySZGUrMoTdhcALD0FJgkpaR/EQBCF3mpN2IUdYiHfU8M6KT4q7dIFAE1SsiGp3j+NAC+QSMB7H8fT0PFoLcZd6zDw/P/EQyZ1jD96hVFC7QJQRPqAew518VvGgKNuePR8vbi9fPp27IHcCM6NyJ8RFMbV2BtjiIusIZTyoXEIuFSCfsLAQDz0QF/mYCr5S+UoBKhe5iCDytrjICKwkHwsFuQjxGdoub0S1FQ+iEq9IQSosLqRBvJGsnIJMvMOGd1SRQAOzCQMswgSk3m63s41U5DIzxChEUQNuW7cXt93A3a10gN3GgdRCmHCbi0bOyN1uvMUAd2vXC1DIJT5LcM8dj5nb89N53I6ZgYIItgeg9vk8gdsxt+OmdAHktV1Y5CKvBQnjuWtZKg4IAQFagICjEq/t7rl77qncjtvtdtyOgwc9fAN6fn4ehzqfT94iKOI+nwPGWxaoZmYLKC5qpTOCd8DhDOrooIUCKWCLjlLxCdLQ8JDGxPBOG95RtRDIQ9wpBGpIrwBqBezucRwqyKeEIigqUMwMctldHsSt3Z3jEOmOV4pA5WNxEYXkIp8VEPJgpAIRDz1wkYtQPT+fT09Pux3HAfERuYvhE3rgonxSNDMUd3EpQO668Frt09PT8/OzM0GBgDxUKILyeUT5mEiAwGjEW3Y7juM8z+KYY7tw0VGUthl3FwSU4hWFEtGKu/i05F124x3VBZAF5NN6AELdXcCH5/MZsMZJgs6dEbtwicscY1jOUQG7RRxjbD3tKRCFYLTRjqNHVstDIBCXgeUuWRkehOaQaM/z8GBVIIcupF1EBgIl9EC6ExgHNwhGSWaCNgq8IKPPu6MQBIjtclHeUlxUQC7B1IK7C0QEEYnUyCjq3OnISGqX52eVcxkuYnsex43ukNGAw3N39DzXUagVnKmtBVQE1FECgQkon89zXxznLhSBEC4PFZ6wKsg76sY7aov/SOIFicRIbeNBjXaBjtuxRalABZzPz8Wh1cwAisy5p4oI6u5yWbxwkc8RggaEvCafsJtHIgQW4O5WM1LRlooQiAgUrwkUlnxCvKFWM1NJyFuUj6lQAcolEFBGg1FwzzOYGbUCeU0+Q7C8xOXc8ziOOnV4KBzO3ZlhA+ROBbaTuKjVMbOlXCSU5C5YyMsMGwLyFrlzeIcN7yiBmSUeBEEQCGYYqVHilR5mBhCHOVDojFB5mBnHuRzjA1ABEcobu6sWAYGitXxWXM6KALVQKSpAgVYZmTSoIAVCZ0YFBG2cijT5SMKA5iAsLC5Quy3lTLu84mVqjuMFDLgFFLsVYCzEnbtbOEKvOCrIto7AudvujMTbhlE3LnI3DncSMyN3GyIbn7Rbm44OCBaCyisFQbCOl2PmmJnjUIG2Nk5mPTqGaYJA3kXDOyo+R1ziDSdx28gLOra9ApzEmPEpBcjdzFQisJAsH6sUBeIiFZ9LPlIdx2ypPLQ7I5SLC6esD2iFULxRfG+RIJ/kA9DuzBCX3bZm5unpCdpdYebgtQAx7qpjjjnm+fnkFbmoFNEFVJTPEjQKlle6iIy7G6iEIFTIK5XKQw/IK7tb8aDyEeUil5XkNdOVpeAAeUcN76gI+UgQIAuCZ56x7LnzAJx7VojaMUu1gBoFYndsnee5u1C76spZcwzxYAXuBjjDzO7yeQxhYWJiuNsWCFDJKXZGohIQXEDQ6Y6gpJFjz8YjCFCgmOM4OFpgQL6HwDGUsalVgTkGrFVnvMwIcicQCTPy0AUKneOYC4UKu4u8LTlloSG5JCiH0VmRMiIEQgWoBaTWcpHL7hY6Oj3o8BB38bEw5BLjAceGHry7hneV1BmfsBCk0dSLcyAeVD6i7bnt3G4Ly0Mgl2qcFy9eHMeNiwLKjC+fn5LkweN2HLcb2u6oQHyWIATxlpCPyEOdurG0EB9TdEaELj5UgEqBEMjdgiDI56koQAUCFRTUc1ep1N1ViUrtAVABQe66AHERdPgekqV4LTrPrW4vbup5Lg/CHMfoPszIRVGkBwWKIj6XYEiCvCVYoXiHDe+o0T1PkLdMDCzseR7f/s5xfBBdeEtFKWrFw3hhN7yrzt1asELA4JgDRQK13fYkxD3XGeR7ks+w4o0KDUaXlDdE8CCqGdEtoKLRgzfaFuI/igoEAoXQwNCdMt4BcxxzjKAo0IzgbrsFFaBAdFlAKGFgCIi3CIJ8TAEpwJFLGZ0bzIy6bSHuriDIK70CqLvLg3I+vRxni41TVmccHdvac2bef/893l3DO+r999778pc/bJc7eUNoXJ74lV86by92DkheU3lNoAtBvCKXCAkqLkrcBXIxJKDSqY34HtQ2HlS0eKUa5S4uuufZrjOjYSBySYq7dtPhYY7D8TzPClK5KJ9H5aEaBSq5yCVAoAL2rpcvX+65z+czD8pe2uN2AILK25S3xUVFgUI40HibCuwuMN7xGTIQIAI+cKfIJUCIh+CY28tvffv5u9/mk+QScdzmq1/9Ku+u4R31lS9/32/9Lb/l6eV3lYsgD7rMjaeXf/PfVp+QmeJO8ZjjRQ4PugdJxuSB7QKJY7KEJJDS8w4NHszAoHJZ2SH5FC8QFZUj3QHqcYwzFQ+Vc9cG0wZEQO25T7srN5jd08tMd6fmAxdxfBhwO2vByAvGXSCgC9RoEK8VATJO5Mx2AQXaiEsBojwUFFDQtl24E9yitUYHBy/DDBoDg0bnHjPjEIIbwUZR1gBb57IZxsCBysDBsA1u7e29b3/tb/rNv3m8GFjN1iDQ2+04n55+04/+JyDeUcM76vbixd/+n/rbn77zHbnE25YPjuNbv/CXZr/+gYcRcann83x+fuYhID6y7XnucdwEdXeBoDr33FKh8/k8z+cIUPlbUqACRTQ+x9YoEHcVIMadcrvdjmMQudvd8zz3PHtQe4Ag7oJ4S8pHClAptBDjrgKEUUQlhOr56fk8V63lIeKhuBTxhgS7+/z8fJ6nQhjjCPKxirio1fPT8+5GvFJAu4dHBYgXgiAIYpjdjW7HDdj4gffO5//3v3d0ns/P6AwfUZ+en3/zj/3YD//wD1G8o4Z310/8xE9Qc9zkNcEY8Li9/JVffP8/+LkPv/T+8xl08QEtLtLowfT8DHjHtlzOPZhhLrsLAueuepvjmGNbINhd9cADBwmDeKUHndFa5G3V7s5McBzH7soxjg44c2wrQly623MDQVDxwmV3e21ra+u5lo8EzkqSXHqYGUpDKC4OUlwEYWZ0APV2u824pSgC5R3QzNHJHMNrQfJpciciF2Fmqt0dB1C5xCvizGxbiUjl6OjYhS48bLvbvHj/Ky9/8eVf/TlfvCc7SjxoHs6v/eo3fsff9Tt+04/95pB31PDu+u/8o//oe++/YJ8tIAgCpufB8+U3fu7/NJ7djg0TULwDBS/AeFTEzPA5HBUKnQoYZx+O4/CBV+SV5JVKKdQ2YJSHSu7Udp2Jit2dcfccp5aHHhwrH9rVNAew4g3l00QqPuLDVsQAC1vJK/HgBZDqOG571zEHnzQz4La32+3p5ROCwfoKEJcgCOIhLs6ce6ogMDPVzES8UQEzwxsiUPGKCCZ17n75S+994+f/wn79r8ztAORtQxQ//uM/PsdNh3fU8O76sd98953vfKfiLYt5fvi+3/prf+X4+X/9+3/gK6fHkdMJQQbnCp27ezIec2xbTRAqAu25xzGGcdPhrgKOOUYNtnO3iBBDPkFH0NmW4qJbu6EVQWPKK57ndiGiO5Z2I+4ElwkpLspxHONwCWd0VN4Qz/N0CC9AJdDGGpAzYER36u4W21bquSeC7J5bW1shHOdZC8vz+exIq3IXb9lhh1OSCEmWGJe8zWnPbbqQJslasoACuzsz554VF7lUpk14+9L7H/7iv/er/5c//eK993LyxmvSFHW8ePHid/+uvw+Wd9fw7npxe/Hf+of+oW9/81szEyUrK8Hgybw3v/Yf/it//Ad+4a9+cJvvzrkHF1GcmTbIC6/trigPGzBjGyCviTxUYgWIEFHoAPGaCiEqBYwK1My0y8cEAgVyhkIuUdscs61IPAQ9LCwWEZAOnyKICQRpECHHzPM+xcIWu9syM8/Pz3Pcnp+fz3Mr5FPkIYLdnAlEKBYXFpePCLqUvFJxJ6/ERYwuEG+TvbTHcVRqD7yRnsqLD3/0S8cv/V//RZ+/M7cXYR68Rf3mN7/xkz/5d//2v+PvLN5hwzvtv/4P/IO3Fwe0Z8DE1Pg0vbw99/7tdrz8G3/jZ/7nP3T+8pe+8t6eB1ltC3g3kwPV6HEcEZeNbZwA79DdraxBINqWuAwMAp174PAxYXf5PNEcR8VHmrLGmd1Ft0AKUI4ZZbswDgSowXkuEHRhaytei0sQQiGMyt3uzgzFxXSQwJna43YEgjp6zAjq+ABI56q7691NRmhPBOQNkcu5vKECtQW4e46OQ3xErYBRRNhdHtRxeCOX9/nRr9x+9V/5X59/9d948aUvkSFvq2Pm6bvf/n2/9/d95cs/wDtteKf9+G/7bT/1Uz/1jW98Y2aIV+xY3nt5Y5vjgy/v3/j5X/7n/6ff/8t/8cMffO/lHBsjlmydy24sNcNdgDrH8fz8RKcGASoQRYAKRCoCBWnDQnLxMgIRLIVFgkq1++J288JddfMYYDuczh2UiwQJ8pbiGA1jwKKoaCWRjwTsFNEDRDPjzJ6nymsBbUZnLu/dbqJx2d2ZibeUovIghbw2EOArh+PgjIcIJHGXIeB56TxuB4Zcotq4211nKl7b5RnZeGo++MpXfnS+8/X/wz/zzf/7v/jhe7DLnXzSt7/1zd/yW3/r7/29v7eedHh33XinqX/sj/2xn/ht/+nlWQ7uDsJKzonmSx9+uL/87/zyP/c/+/Dv+Qd/5O/8r3T63W999/k8O56gRXCttGaoUxKZBfY8mQGTSEeKJEYiAs54YnfmpNPSQhC3c3vu6aW0JwejHKgcwDYlE6i1FAyZjgIrDTJpOFMs7G0OzpUOaOv5eZ7ROefYYcpWkHheffFdPWgIu7gLOUQBXVY0QXKgbUtMYsk9B8q4s7t1FIStp6czEExcHryrmef54AU7nKdtgc6oGw4eB3QCMxVScbtVZ3nMM6Fc5HnPdUa//ysffN/7t/kr/+bX/s//u6df+Gvvf/ji5THT8pBrCFby7W994/f/d//x3/SbfmzPlx68w268637bj//EP/yP/MP/7P/yn/3+H/3qnisQghE0fXvmxZd/0P321/6P/4uv/Lt/4fv/s7/z/f/kb3/+vu976Zfd5+lMTo7UgIaFE7wELSokQcR4AQSEuHvafvBLPs93v42xMDxsy9xefPD9731we7H7bDe5tAs08oojl2iBCitWQVQgLzApsqRwBB5K+ZwfhC98ur14QbxcDrV677j9yIdf7uXzMcCyG0H47DxXYi1QTAPZgBdAhdaBoeEN5bKbOgo+7fzQfPev73fichp3IhwvXrz/5Q/P5+9+eFvP5z1PGAi88GldiIqLyF2FnRPr8GVzv/3121/5t7758//aN/7y/8Pn8/0P3ls0PiJ3gvrNb3zj7/jtv+P3//7/3vPzt263D3mn3fgC+KN/9I/+mX/pf//08vl23FguK2/ssZz69EEfHrt//ed+4a/97PEjv+VLf9t/5r2v/m18+P173Oh26yDFOGHptKUAgU5KdohXiqDktUO/fTx99+v/r/du7+VOyl3p+R2+8f/0m9+d9jaaFUuAis7IGS+hVqQNKJE2vCTKqFuDo8UwhEAYfOdpv/vNfP/sOHhWLsd773/zP/j5//DP/TOcnAWUYIinPWEoEYGboA3FK4plIHdBPAhy91zgevwS33z61tduL96Pc5rVNm4vnn7xrx//tz/9wT696Inz5T6dJA8qn6KJiDIDEa90e3GI3/r28fT8q7/wl/frf/nb3/iV5/NbL95/MS9evKTpxXHCccIChiHu+fz89Pw//p/8oR/8wR/cfeZdZ8UXwJ/9c3/2d/+u3/2V7/+B2+22bYhcguZ52ufjxey86Dy5PT/huefzS3EUhzlgOk+JQ12jCxaXuJiCQBtm8ZYdb19677Znt9M9MB9ervP+h7c9ePm8JnQngrbVcgkdORgoIO7kshggSLYre9xIirgr43jv2P215+E8+WCf4qhut9t37r57jMPBw2ogUEoFVigJksadoMhryUfEoHhFg3Oe3v/wg/eRnuQ4FVCfntonNPclrBDDg8qnCIjW7gbFnTCO9fT0xO3Fi/duLw7meLHlPp/j09yO870XtMeTRFCD1K98/Wv/5D/503/kj/zT5/nyON7jXWfFF8NP/6Gf/iP/9B/5gR/+wefn0+NQYAJcUycO2TjaHRsuZy0wSggJtEKDgMBEARLIXaEJLncBNjXrc95ccoE5pj1nnwdsUhIKhNoCA9JARFCKV+QiFLTAcJcC8oqAiK6cZGOl1OCapMAgasRr8kqvIG+oPCjEKw1vUUDe6GLnCue47qzyIIxYEhflNS98ji5ElBSIMCEslI2bJw3I3eo00zIIhop+/Zd+8Xf+zr/vX/gX/vSXPnjhvFB511nxxbB7/jf/2/+Nf+5/88//wA9/f7olw92AcvBGbaKz7O4J3BSYWFlIYgC5MwRS4i0JLBcXmB1z5znet80FHAFbIEak4Y1aLm7crbyi8nm6wMRl+J4EI0gEY+USD6LyWVHxWaLy6xebuQcnTcgb8rFAXlP5PBUPQYAYgTBAJAvJRTAucqcOEDN+7Zd+6Sd/8id/5md+5qtf/eHywhfAjS+MmeNP/PH/1XvHiz/xJ/63H37lS8ftNmMCcomP6CCXwTsQBQdhBKThI3KRi7zNUO4EHE0dSIaJT5K/hYlXlM9V/PoJxiX+f00wQ/me5DdGIC6CvBYIxqeIU8dY+7Vf+vpP/uf/7p/5l//lr371q3Xq8MUwfJG8ePH+H//jf+J/+D/6A9/6tW+fz+eMxNsUiO8h/mP/f09eSefly+evfe3rf//f/1/9mZ/5ma/+6A/VqQdfGFZ88fzJP/kn/8Af+B/84i/+0g/9yI9um1xU8DzPGXlIjIDiLfEJ8mkqn6cFlw4uLn8rKm9JXmnje5NPU/mNqPiNUPkNygyQ/+9JjM9KXjGIwW1/9etfn/EP/VP/1E//9B90oEH5IrHiC+kv/aV//x//J/6JP/Nn/qXoS1/5yu24nbvF7cVtzxOo0FEi4i0BxRtyt8WDb3CJuEQFNLg2AS5/C84IFBCQvFYgl4h4UF6LT1H5mMolECo+o+I3QuU3KDNAfh1EIOLzCYkJxWckFDjaud/6tW/uPv89/8X/wk//wT/49/7Uf/l8/u4c76l8wVjxxdW/+q/+a3/4D//hn/3Xf/Zb3/rWh1/5vtuL995778Xz0xPRHY5yEah4YzdlRt6oeFDXOwrlLjYBrXY3nRGE+AR5LVB5kDfO89kHkFK5SIU8OAhsC/KgfEJUKKAMBlvKKxW/DoJxUYEg+Sy1qBSRTxHCgC58mhnIRfmeuoip3FW7pwrOuM+75/M3v/Gr773/wd/1n/sd/9g/9t//B37f77m9+LDzyeMFX0hWfLGd5/nn//yf/1N/6k/92T/35772ta9989d+Def9Dz548eJFcZ6nAgpduFNnRtiWO+/AEdhYulCIOTpjd1QzLpx7qiBvxCXulEu8piICjl02IALlLpAHIS4RyIN8QtTmKyAsD3IpKj4WyKfIxF1cVO7MIlDeECIi1EA+Qe6MS8VFPlIgCSigEMintbs+gNUocJ7nd7/1Ldr3P/jSD//Ij/zU3/tf+j2/57/2u3/X7/rggy/VswwOX1RW/McefuVrv/Rv/ty/9Rd+9mf/4l/893/u5/6Nr33tl+eYlssWcVEiQacH7oRA5BKhgAj9f9iDEwC9C/rO/+/P9/c8c+Yg3CB4bhXx5EZBPGuxRexu261aL9RWXBVardID2v9/6wmIUil1baHeFXdtlUvEcoMcAoGg3OQiAQI5ZzIzmXme3/ezv2dyMJPMJJMEuplkXi+MMIh1JJRkmSVCCiQqxk5ajCRkA8aA0bBACtxCRcIC0yIQ6xmcyTqSkMQITockSwJh0jKixdimRTZ2gqRCYh0bHBiwcQWEKsbpREiFxDABxs4SKSQkhsmyTSYIBNgGDaNik04JFJKQTToTSYSEJBBgp52SUGDSWRRFZ3vHbjNnvvKVr3jhC57/yle+4rXHvHa/fQ8AsmxEUWeXJ9tM2Zj7+lY3mw2TTtayDUgyCYgQMhW3gAQYhAWIDYxsA2KYKhZhwC3CSChExTa2EUKixYCzNMa0CFEJJFERCAmbiiSEJEDgCrapSAIESIK0DWEZy+AKuEJLSCGE7GQtU0mMlFQUKIQAO4UkwLYYQRICbCdmmEAVJEAKwDZgJwaEWE+4kqoEdtqAJJxmmLGUELZAtougVm+bNm0aBJA5BBFRY8ow2WbK2EyLqZgWiYptEBUh1jMGgRmDaDHrSGDMOmIUAwaxlsAMM08zCImKQYAwYBDrGMQGYgymRaxn1jKbEC1mJDGCWMe0iDGYp4kJMmDWEiOIFlMxYNaScAVJYFORFEwZTbaZMmXKrieYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLimYMmXKLqnGpNXf37dqVc/AQL/TtVpNEWXZbDQaQ42hsiydBiKKCNkuy1JSFEUoZs3abf/99wfxTLC9bNnSvr6+oaGh9vb2eq2OxDDbYFAFsA2ohWaz7Oho33PPvfjPYnvNmoE1awabjUaz2RxqDFXKMiVFSAoJDwNsZ2ZZlk5TEZIAmxY7Xcm0sVELkJnOtC2BsVGoiKJWr0WEKhFFFPV6vVYrpJBEiwGnyywzU4oIYdJpO9MtmYChVitqtXqEKnvvvXetVufZsXLlyv7+/sxsNhrNsmwOSycmIiSVZdlsNsuybDabfX19q1atWrZsWW9vTzo72ttf9rKXv/GNb5SCHViNyWlocPBDH/rwj/7tYmeCQUCClWDLhSrYEjIJQk7sZjmtq3vO7NkveOGLQGy3W265+d3vfteixYsVqmCBsABLJpM0RIRtgRJEOdR49asPueOO26SCZ43tpUuXzp49+9FHH338icdvuP6GO+64o7e3F6So2cmwxMgGBAghEJIFBgNySJZkkzayA4MQBoEFCCRjywGmRYmRDRZYrBcGzDAZrYVSGJdOiSBswEJSJGWzbEQRZX/jve//o29e+C0peKY9+OCDH/nIR355+y8bjWYUEUVhjGQgLQkQIJwuaTHGpkwVHuobOu/8r77pTW9mxybbTEJ3zZ79mmNfV2vvlERLAAaUtGRmicxaNgjsoFav9T6x/B/PP//kj36UZ4APPfSQ+QvmN7NUURjZIQWmRVE6TROsqGEDsoWaQ0P7zNrz6muufOELX4SCZ8Gll176jX/+50ULFz61fPnKVStQKApswAZCEsOMUWKlgABLFiELlSCBHOk0KYTCSksYCMnGYWGhBARyINMiI1QaGeRgmKgYpWkJyxXSDguwQjY4aREgB0qriWQ8sLTn/PP//uSTP84zqtlsvva4Yx55eG6j0SjtolakE8nCoDSjmWEiUEj9vb2ve90xl19yaUdbu6LODiyYnL797W8VtVrUpAIVECWRilKyZImCekFbEUURRUQ9htVQ0YTQ5ZddBtjJ9nnkkUfuumtO4ijqUatHUVMBSocdgBVEFBG1sEMq5AgkdXV2Pbro0fvuux8Fz7SHHnro+c9//u/94Ttv+MXNcxct6lm9OopCgQUhh1xIhVEaG4Mx4LDDZZC0GEyLjU0pmRAhgwEbDOlKpp1gMGA7XZZlM+Uy007bOMNWWmmlSeMWnCaTtIykIoRKl7bBBoOFWpAIojB1a/qM7lM+ceqtt/6CZ9Tb3va2hx9+uFE2HYpamEphAoccqEAFKqRCFKgIioKicFEQlNleq3/h85/t7OhGBTu2YHK68aYbI5CTFkMJTdmyZcuogmTJES6CCAoRJB0dXXfNueepJ5eI7fWNf/pGrV6zQZHGNjZYIIwycECAKiAjU9hZluny3nvvg+QZUpblzTfffOKJJ77qkENWru7r7OrKSrME24gIs4mEFBYIBAIZGWyRMjIya4WRLWVAQEDgsMPIFikjW1QMREpYpIyMkoAwAQGkScuQCQkGhEWGFRAmTKACCUTKyJIVqSgKRfzJn5y8ZmCAZ8iPfvSje+/7VbNZAmIdQZgwYcKECSMjCCMQhAmrd8WqU0895egjjs1ySAp2bMHktGjR4qKosY4gINiUCxyMos7OrsWLF19z7bUo2A6Z5Y///cdd3d2gdOlMOyEg2ISMzAZCtVrHNddeB+KZ0NPT88lPfvJ3f/e//eKWW2ttbenEaaexDQjERAkQEyIzHknGEusYi4qxpCzLstkcGmpIUShksJ1Ol4gIOY0dUkgRIYl1BDIVTZs+bc6ce844/a95JqxYseILX/xi/8AgCqlABQ4sRhCIjUnC9Pb0HH74YZ/59Gm4GdHGDi+YhBqNxpNPPqUiaHGFTalEpaN0JKPZmVne+ItfQLIdHn/88SVLnpQChAEzUUbU2mrz5s3vWbUKm+1z//33H3rood/+zvcaZbNZlkiAQcMASWwft5DYYqKEZQsLCweWU6UjS5rUKNqK9vY2twhCREhhyQQKiWFOl41mliVgm6epTM3cbbezz/nKlT+7gu2TmSeddNLceXMtJLFV0llmrah9+ctf3m23WRBI7PCCSWjhwoUpmk7jsiydaRtkCgsLK3maHaWFBYRJyKJev+7665rlkJ1sqwcffGj16tVgERAQEIwgIyMjy2nMWilbbmtre3TRwl/fey8S28r2rbfeevRrjl62fHnpsulMzAgaRotw0GKUPE04aDEkLQYMJiyVTmMpJCRhKUNGtpysZ2TCwrJJniYQCAQyYcKECRMGg8FgsGzZsmXLkmyDCZASiLAwSkUqrJqKtu7uaR/80IdXrVrFdvj+979/w403QSFqUqEKIAECgUCMIhAIhFf3rjzj9L8+7rjXZ9lEwWQQTEKXXHppdLQZGzAtZiNWWgkJyXoWFom7ujrnz503+467JbGtLr30shkzZ2SaLbFTETxNiKIefatXz503n22Vmef/4/nHvuF11KNJWoaEZDsJCUmAnRFhbGG2gsFMgEAgEIixCUmMYGFhBJF2rd62+LEn3n/SSWyrm2666TOf/nNabAxmwgL6Vq9+7WuPPvVPT3FZRlFjkggmoYcefqhe1GSDJYGkGg4mJCBqtbaeVT0333wriG317e9+JyIkRhAucDCapLCDp2UmImrFVVdfzbY65ZRP/MVf/dX0GTPLdAqLjVhYWMIFDsQ4jBmTJLCEnYBtNiEQiGeebVWQTICEnYxiIVTsscdeP/nxJd/+zrfZekuXLj311FOHGs3SWTrTWXGmAZuxCETFIrPZ7OroOOfL50ybNl1FMHkEk01ZlvPmzavVa7bZNpLtola/5LJLwWC23vwF81csX1Zmsq2yTEXMmTMns2TrfelLX/j61/9Xe3t7o9lMm+2gYWyWJIQkto9GYytJYhOSyszOzs6PfezjTz31JFvp7LPPnjdvXrMswWZcQgyzzbC0JfX29PzlX5521NGvybIJYvKQbSaV3t7eAw88UB31sixpCcYnMw43hhq77zbztlt+sf/+B4DYSh/+4w9/7wcXtbW3s83sMpszuqddecVPX/7yV4CYsAceeODwww9v7+xolM0mpuIQhMQwM4pCjEVmUwbbjCRAYFm0mA0s5BSyEMNMxSCEsBlBiPEZM4IoUDIG4QCjZIT+nt6jjzrs2mtvKIqCibnyyit/7w9+v1arg1JUDIgWg80w26EwCMpMhewMWNPXd8yxx1z6k4u7OttUtDOpBJPNsmXL1gwONoYabAej9o6OJY8/ceONN4HYSs1m86qrrlZRmO0g1Wq1xxc/9sjDD4OYsKHG0Lve9a62tlqzLEubbSQmzlSEsMGMIAESQqwnEJKQDAgEAoEMBoPBgEAgEAgQCAQCsTWMZ8ycceONN5991peYmEWLFp38sf/R3t4ONuuIMUjKTEm02BARzpTirDPP7J42XUUbk00w2Vx11X90dHbIIl1hHDIy45ELZyRx1VXXgNlK8+bNXbJkSa1eQ2wzAWUi5vzqHrbGeed97YEH709jO1QERVCEWpgw2yQeRuIRwAoppJBCCikUIFBoIwgJCQkEAoEQCBASEhISEhISEhISmzAYDAazNQJl5rTp0874mzN++ctbmID//of/feXKVaVJhYWFhcXYhJ3GoRDIrF7V86Uvfu7ww45wliAmm2Cy+d73vxtFoQi2noWFBSqh2dZWu+GGG4YGB9hKd9911+DQoDMZzcLCwsJi84ylqNXrV199LWAnE9Db23v2WV/u6Ow0WGwXsY5Yy2AwE2VhYbGWQCAQiG2h0RiHZUfpSEYwTrloq6uovfe97+vrW834bH/mM5++/8GHmumyTCZAEuuF1LN8+YnvePspp56S2VAUTELBpJKZt912u4qawQQORpCRkZHZiIXFsIQEDO3t7fPnz7/hxpvAbI1zvnpO97RphSSzloXFRiwsLCzGokpbW+eTS55atmwpmAk499yv9q7uyTRIKlQJKaSQQqwnEDKbkDJtoxCgYQgkQghFADYYDDY2xoxiMGAwBgxGRkZGZi2xMW8EGxsbGydOnDhxYkhc4AIXuICwsAxmNAtLVkDRPW36Aw88dNpppzG++fPn/+jHP25m2kYYLLZIEEawZmBg3+fsc845Z4WIqDE5BZPKkieXDAyuaTabbJNkHStNKjwwMHDbHbeDmLChoaHbb7+jXqsFCjNSQoLBYLYs0x3t7fPnL5wz5x6pYEt6V/f+3ec+W2urAxITYZDAYDBZZkQIOZNhAqUFQorITClCCARCQgIxmrBISIGNHRAmTNjKlJM0Sdhhhx122HLKKaeccuLEiRMnTpEiRYoUKYxKlIxgsAwJtrAYyXKjzOm77f71b/zTT396OeM4+eSTl61ckaSKUBGIiTLGQwNrvviFL7zohS+xA8TkFEwqP/nxT9o7uzKTLQkTZrNcUb126WWXp5tM2EU/vKgx1CzLMrPEhNkgIACTkGxZRCD19/cuWDCfCbjooouazTJUMCEOCCBxmc50pmylnUlaJoyMDUYGExG0SFgQVlhhhSVLSBhZMoIQ4QgiEJYsWSJCBSpUAQQCgUCxeYpQhCIUoSgkmY0IyQEBYhOGiCBUa2876YMfXLx4EZv45je/edsdt5dlUxK4wgg2NqOYdYwielesePd73v3+955kl1LBpFVjUvnl7b+UxLYST5NEuquz88EHHnzwwYcOeslBICbgggsu6JrWbVuSsRAbM0hsgcB2WTaiVr/+uus/8IGT2CzbF198cVdXd1mWkpgYQTLMVIoiMt1oDDlTSKCKschMS7bVYmxRES4QkBbGyGlCAkzFgkgqMiAwskAECkZLl4xgmRHMKDUV9fZ2s9UkdbR3LFmy5H3vf9+VP/t5URSs99RTT33tH85rNBtRK4wYJrBBbJ4i1vQPvOCFLzz7rLPAUsFkVmPyaDYbd86+MwqBQYwgs5EUFYuRBHLQkrSoraNj6ZInr7/xxoNe8lImoLe39757721ra2s6JSoSFZmKRUVSQUVg1rOoyGxgsLBa7vnVPZAQjG9waPC6664r2urOtGgxCJkNbBCSWMsOW6G0Q9FsNFb19s2aOes5Bz53//32azabjcaQJAgkYWMEzmZZSlQEdmGSikBUDAGRBMIkWKxnWizbwhYbMyOYUcQot976y5lt7QhUgnDIBbKVMmAwCCQzkmXsmbvvfvVV15x//nmf+MSprHf66afPnb9AUcMSIQcYUoKkRQgwLZJtJFoyy8aaNf1nnf2l/fbZ105JTGY1Jo/+/oF7f3Vv16zpzWaJ2X6SyrIk4pprrv2TD/0xE/DIIw8vW7a8e8Z0RhGYjZkJsHP69OmPPfb4vb++5+CXvRLEOJ54/InVfX2d07pt12o1htlIjEsCY0dEz8pVe+4+61Of/OQ7//AP999vv7a2up3OBGxZVIwD2WmnkHAKHAZRsYSRIYxIIbkwWAwzGBmMscAJYhQxYZ857a++/vX/NXOPPcy2cff07tP+4i9e9/o3vPqVrwLOP//8f/v3f88yJbGOwFTMWmIUSbYloehZvuLjp3zi9/7r72eWEQWTXI3J4+45dzWzmU1EYcx4TIvYjDDrRa2j+/bb7+xbvap72ky25Oabb6611dNWCJAEsi1RkVnLYoIUoVrtsccee+DBhw5+2asY3/U3Xp9yRNASVIQYTTzNgAHBwOr+5z7ngEsuueQVr3gFlJmOKED8P2NaxGadf/75v7z99jtn3zVj1iybdSw5UIJsSYzJAlO0tQ2s7PnEKaf88F9/8Ot77z3znLMbmRYbExiEwGxMUIvo7ek5+GUH//9/+7emjCiY/ILJ42//9m/a2jqcZktSWFiMJ0WKinG9rVi0YMF1N9zIBJx51tmd3d2IYWI0CwuLCbIgVJbNiOKOO2aDGd+111zb3tFOixjNwsJiJINFiS2GGkNfPufLr3jFK8ochCKiBuL/JYHYEikuu/TSGTOmDw4OQKISJeOzsLAMKQzY7pox7fbbbz/86KP+2x/8/spVq9LJ0xI1UVIRFYMrwsJiLYmy2bTzK1/58u6774HFTiGYJMqyecstt9fb2hQSKKSQQoxm4UDCxgZRkZGRkcFg1kohslbEmjUDN998M1uyfPnyRx9bZCrB0yxhsNgyg6lYWFRk4YKIG264gc26+545ocK2xAYWFpuyIEDC0dc38OpXH/q2t/12szlQRBuTyj777PuDH3xvTW+fnZBgVCLjAheiwAFhYRksIyMjIyMJqLXXly1fRqgsSzshISHBjCRZssQIITlz1YoVp//VX7z1N4/PsiEFO4Vgkli4cOHg0GDUaoDF5iWksBiPhcV6pl789Kc/s0sw4/vXi35gU2YpiREkISElSki2gkXa9fa2JU89+fiSx+1kHE88/oSNqIgRDMk6ZmMWzUZjn3337ersLIp2EJPN8W/97Y99/KO9y1eGBGZjYpip2ErLjCAJqd7eZqxhPM2QYEawMOuFjHtXrTrm2KM/9alPuRyKos7OIpgk5txzTzabQQ0XuMAFmyWGmY0JhIzMep7W3b3w0YVz5tzNZn3v+9/vnj5DKrQOFbeQmU7LDgiwwYxBIDYi3NHR+fCDD99112wpGIvtRrNsa2tHBYiJE7iSgBRMTmd+6eyXHPTi/tV9YcQGRiVKhomKIECMoM1iJBssG1fAOGkMDk2fNu28r31t2rRuosZOJJgk5sy5p9bWUWYyYWKi6vW2p5Y8edNNN4EYR39//6JHF0UEYhxiBLMxIcamitHcuQsYXxS1slkaMw4xtqjVly9dNtRoMGl1dXVddullgYaGhsAgnjVay2Cc2d/b+/nPf/bVrz48y5SCnUgwGdj5059e3tHdhUpUilKUMjIyMhYWFmsFBAhIZMYSEBAQoijLRlHoyit/Bsk4HnzwgSeXPIFLOSFZTxJQSAESawkkNuU0piIjIyM7CoMdvuJnVzAOSR1tdYQQYGFhUREE2KQJtQAyMrLlnDa965575lxz7bVMZi960X/5h384r3/1auzAKFHSYkgZWSAZWRAmrICAkEMOOWzZsmXLli1bNhvIVGQKKEKrVyw/8Xff8dGT/0dzqD+KNnYuwWRQluUjc+faiVqYMIHNFgm1tbfNmXPPsqVLwIzl17/6Va1esxmLaTEbiK2SmYpY+OiiwcEBxvG8579gzZo1bB1VgEaj8bGPfnTx4kVMZh/84Ife8Y4TV61YAUmL2QyzjYxoGVwzeOBzn/cP550XRdTautjpBJNBz6pVy5cviygwmWazbEhkZBASWyRUb+tYtOixm2+5DcRYzv37r9Xr9cCMT0ZGZlMyGIUQ6xiMTVZcdnV1zX3kkV/efjvjOOyQQ8rBIYUYS0Awrukzdps7b96xxx5z3bXXDgwMZCaT04UX/svznvu8vr7+GnKZkGDWk4ULHLYR20aQNmZocOjLZ599wHMOsMXOqMZk8NBDDzWbzbZ6rdlMY9azGJsYk8VaMiNZUlE0M6+97voTTjgRxGiDg4OzZ8+evtuM0mZ8FptlRkvRYipFUaxasfyRuY8ce8yxIDZx/PFvPffcrwSUJAQTYCFTSXnmrN2XPLX0jW9+ywue9/yDX37wc/Z7TlEr7DQtEkIVQAoJg50gAQKTNrYiZsyYvs8+++y/334HHPCcQw89rL29g/8su++++7/9249ee8wxQ41BQkIg1rOMSgwpKgKBsWgxEyBwvSiWP/XURz5y8h/8we9nlhEFO6Mak8EFF17Y2d7ZbAwRhWix2JRMRYzBYkwWFaMgolb/2ZU/P/NLzYg6o/3wf19Ub6+XNgTrJOvZIBAbkRmPBUIME6TSVq246cYb3//e94HYxBGHH5FlRkSmTYvMeCzWsoJhpd3R0d3Z2b1k6ZLHr35cESBF2JTOkBQCiZYyUy0BFhXZqQjbZbMZ0uDQoIcatVpt/wMOeMmLX/zZz/3dEYcdwX+KQw897FOf+uTnP/eFWXvu2cyUBLISTIsQCjAGG4mJEMhUbK/uXXXIIa/63Gf/p11GFOykZJsdm+099th9cKjR1t6WCirGQSVZJ2iRGY9FJSF4mozFOgYjl1de+dOjDj+aEWwf+ZojHnzoYStQyAxLWgKwjQSkWCtokRmPhcEQVGwnpq+n5+ijj/zFDTdBsIlms3nggQf0DvQX9boxIAfjsDCYdQKwZKESEiSFnWkDigLINMOMASHWMch2RBg73dbWlpllWdZqtcbg0OCagXJwcMas3c479+9PPPHtM2fuxrPMzhNOOOHyK66YMWuWjSQLsLGoCCQgSYGoCDC2AbExVUDGlbJsNAavuOLS4457s51SsJMKdngrV67s7eur1euSwoSp2FQCZGQQGwkTZiPBZrgoomfFyptu+gWjrVyx4rHFTyhqQmzKSEJUAgKCMYQJM5IgWEsVoLO7a8GCBfffd7+dbKJWq73zD/+gr6fXmYiNhAkzkiAgIBAuIFhHIIaFJHDaadYTKqKiSoSiRVEEIBOhzBIcITtrtaKru3vmnnum+cBJH9xn3/2+8KUv9fT08GyS4oILLthrjz2HBvoLFIQs0hgIEGBAKCQQExVyT8+qvznj9OOOe3OWQ1Kw8wp2eLNn39kcatTqhW2ePVKz2VRRu+zSy00ywty5c5ctWwZmTGIdsT0EbW1tjz36+CNzH5GCsbzrXe/G1IsaNtvFdjKaQCCQWEtiA4GEQhUPA2wDkmxHFDN3262tvfOv//IvjzzyyFtvvY1n07777nfhBf+8ZmCNJHCF0cSwNBMWYsXyFW960xv/9M8+6WxG0cZOLdjhPfzww0WtKDNTpEhRCZCpSEgokRkpRYoNZGQqMjIyMhUZGRk5I+js6rj/vvsXLJjLCAsWLoxarUzSOD0CG8jIbCAjM1KKFBvIcmkbGRkZASVCv77nXsZx+BFHvezgg1f39MqSgYSEhExlKllPRmY94yZuogSBaAlbVlihCCSFFFKowjhkZGRkZGTWskDYLoqYtcee8xYsOProo077zGds86w54e0nfubTn16xfJnJLBtGsmRkkyWukGWSdkIpEoEYW4TWrBnYa6+9vv71f+xorysKdnbBjs32DTdc3z19uhlBbJGkgYGBzIwIJqyjvf2xxYtvveU2Rrj77jn1ep0JEwgyU4hRxHp2RgQjSWDElT+/knFExFfP/WpjaCiQbLaDbURFisxEbCezTmZ2d3XPnDnzzLPO+uAHTmo0GjxrPv/5L5x4wgmrli2vt9UZLTOdWRRhJqRslv19/WeeeeZv/MZL0gKxswt2bLZvue1WCw9jNBkZmY1ERLPRePGLXlSv1YFMVwCZMdmsZQK46qprGOGHP/xhEAKxBTIyQi4zm81AgTyMtaTMdFoIHGCD2aDe3v7Y40+sWLYMzFje9KY3v/GNb+xZtUpFwZbIyMhomNfBVguixRESo9jYjCQjszkiRYoUlqModt9j929++1u//3u/NzQ4yLOjKIrvfPc7RxxxRDnUDLOeIKSQZFsgNkcSpmflyve85z0f+MAHsmxGFOwCgh3bwMDA4sceUwghidEsLCxGskDuW7Xqve99z8tffnBvzyow47NBZljprHV03HzzLUNDaxjW39+/+PHH02bCRMt7/+g9WTbtZAQh24oADJYMlgGBcff0afPmL5g9+y4QY4mIc88916XLoUaAJMZnYWFRsQ1IAgwWFtvJwsKiIp5mMC4zZ+4+6+JLLvnQh0+yk2fHjBkzTzvttL7VqyWxEbGeUSIzmiFtRWTmgc973jlf/artKGrsGoId2y9vu21g9UC9Vg8F69kYLDZlpcmyLGfM2u2tb/2tQ175ymw2i0KQkJCMZkGABGGrLMuOzq5H5s6dM+dXDPvil75Y1MKiYrZMWa4Z6D/ggP3f//731WuFnYElM8zOoijADgzpVIBwBSyltWagb+6C+Yzv5S9/+Rc+99neVT2ylJbZmEmw2MC2kBQJhCpOVxiHhISMjIzMRiwsKjIyMjJh1jKkcMhi5h6zvvvdf/2rv/5LnjUPPfRQZ1cnIAUucODAAWKdZDSDAYmIzERasXzFFT+9QhK7jGDH9q1vfyvqtcZQwyAJsI0wLckwY2FRMVisGezfZ+89D3nVq15/3OvA6ZTEJsw6BguDUKCB/oGbbr4ZWLly5UU/uKh0QkKyRXaZ5dDg4It/48VHH3XUS1/60oG+frGB2YhEiwhZVCxFW/vVV18NZnyfPu209/zRu1csXw5IYiyGZB2DeVqKFGa7GAwWFhuxsLCoSLHbHjO/eOaZ1153Dc+C/v7+n/3sZ+3tHWxBghnBkBi3EGqW5Z/92Z/OnzefXUawAyub5WWXX97d1ZUtpW1JNhWJSoBQ2pi1BM5UcuBzDgBe85qj995777JM25lps47BbCBaFJKKNEW94+KLL2mWzQv/5cKFixchJsjQ3t6RzfLEt79d0vOee0CjMYTEWCRCbCRdpjVv/kKQnYwjIr7xjX96zdGvWbl8RaGgzDBhICEREiMphGynwMMUgcREGMymBGLzBJHpUK1ea/v4Jz7e07uKZ9qpp55y7333lmWJ2JgZZsYhECAUautoX758xZ985ORms8muIdiB9fb29PcPFLWaQkK2s8yiKMQ6tjOziEBsIBjqHzzu9ccB++27/2++5S1r+vsBSWDWM4gxSKrXagsXLrz+hhs++/nPR60mxMQIBgcH99p7r9e85mjgrW99a1u97hbGZjZmOjo7Fy5YeN9994vN6ezquuqqq44//vhlS5cWRSHJjCIQI0iAWwBhiy0SYEyL2SYSmdnd3f3re+495ytn84w642/OuOh/XzQ4NCS2hVjPBmbMmPnzn//s9NNPZ9cQ7MDuv//+/v6+UEiBUCVkJyAjoxYwMjLDooi2qBUvefGLqSje/c53F1GoCIunCYmKjExFRkZhhesd9aeWLfv//uffpV2r1W1BQAjEBgFiNIn+/r6DX/7Sgw46CDj++N/u7OxUhI2HsZ6MTEVGRg45IApFe73+2OKF9z1wLwo2q7Or8+KLf/Lxj39sxbLlQ0NDtikzTDjllBHCBS5wgQtUKBRBoQxSJCSYpwkXuMAFLoyMCawEQ0KCARkZLGWhDMCQYi1ZcsgCjFKy1Dlj2je+8U+LFs/jGXLHnXdc+C8XKApQKaVNWpmyFVZYgVpCKqRCCkKECCkUoUpIAXKKVHjmbjPPOvvMq67+ObuAYAe28NFHnTaWEGIsQmDWsz3Q37/3Pvsee8wx2RwC3vDGNz73wOd6GBOgSrTccOONma4wcSIb5Qm/cwII2HOvvY5/29vWrFmDmbiiCIrinrvngNmSer3ta18774IL/7kotLq3RwwzFVUQ20miIraPkNrb2h9fvOTCC77JM6G/v/+PP/zHff19UhjxTJHq9bYPf/iPl69Yxs4u2IHNnj27o6uzLJuZyVhkNiIje+899th3n72lADo7O0/4nd8Z7F8TiHHIbGAbnM6ZM2cqQsOYEGeZ02fOeP1xr8cGJJ349rev6e+XZJtNyGzCZTZRXHf9TSAm5oMnfeiG6677rd/8zTUD/QN9qzPLQkHaZcrIbD8Li42I8RkMLnCBw8Zkva32k0t/3NO7Asz2OeOMM+YtXJCEJYvtIQgjU8l0e0f3/HkL3vfe92Q22akFOyrbP/nJT4qiwIzHwsJiA0mNRuO4N7yuqNVU1Bj2htcfN7RmICIYiwFhYbGBhzEOg8GMJq3u7XvJi19y2KGHGTPsBS94fhGhQBKbsLCw2CAzBW31tieffGr58mVM2Ctfechll1928cU/efOb3txsNFYsXTY02AjHWqRJ2wwTBAQEBIhNCcRoAbLNKEYlSkazSGEEYh1XuqZ13nXnnHvm3M32ufPOO//5m99sZgnYZj3LGZlKRrOwsBiTIUWKFFGrpTx91szLLrvi29/7Dju1YEfVaDQee+yxoihQC6NZJNiMJFMUhRuNg176EkUb673lLW+p1YrMJpuwMKSZIIMZQ2KMm40Tfvv4iAAx7KCDXtrW0R4RGsZ6FhZjynR3V/uDD9x75523szVE8da3vu2SSy6+9ppr//zP//zA5+xXhFcufWLl0icH16yxs9kcagwNNYYajaFGY6jRGGo0G81mo9lsNJuNZrPRbDaamY0sG9lsZLNRlo0sM8syy8wyy2aZ6cy0S0hIMKNZWFQkEGDWE0RRpPn5f/wHiG01b97cd/3Ru4taXSrCEQ5ZtNgyo1lYbERGRkZmBEEY1FJ0T5/5iY+d+vDDD7PzqrGjmj9//qpVq6bNmF4UhRmTLckgLGQqZVnO3GPWwS99GSQEw6ZNm374YYffedfs9s4uxmIQLRYVmc1LEaZiUZFBwurq6nzD648FJDFs5szdZkyf3j84JAnECAZD0GJRkZEEBhqNxuLFi9l6UdSPOPLII4488owzTr//vvuuufb6uXPn3nHHHU8tXTqwpl+IYaYlJEawM9NimAABdgK2iVpff/+a/v7uGdNDLQgwCERFAhsMAQjTIlMxCBURd86+i23VaDY+85nTlix9KpNKCpkRbFkIxHoG0yIQY7NYx7SoqLfV+3pWvvOd77z++uu7urrYGdXYUV188Y+BiHALkhjJqMIoWWazbB74nP2OOuIIMCN8/rOff/Nb3tI1rWYLsJP1JCxhs80E9kD/wEEv/o3XHfc6sknUGRYRx//W8d/91+93T5tmWQ62RMhOpJ//x9Xvf/8H2VYzZsw88qijjjzqaKB31Ypmo9nMsmKQWwBJVMR6CZgWoZDSNsakVZl9993/cuGFP/o//zZt5jRFDTHMICDLJCQhxmJl0tHV+eiji5566vG99tqPrfe9733v8isvL2ptEEyMQGyBTMUCCYJh02bMuOOOOz75qT//+j+ez86oxg7K3//X73V1dUWEsdmEWEeM1BgaetELX9TZ2WkjscGhhx02Y9YMxmIbG4ktkrDZVBJFNAb6/+s73hFFJ6N94P0f+NZ3vq2QbSbAWFCr1x566OFmY6io1aRgG4lh02fOomKDkdgCUzFgEAJExd5//wN+522/c+65X/3kpz7ZNW26FJJAgG0qBrEZbe3t999//4IF8/baaz+20v9lD07gLC3IM2//7+d9z6l97YUGAdlENlHQGUFQlmaRTQSXqDHiAsYQMS6gUZM4ThJ1ENSgJp8mMcnM98UoUfyJiWgihpFEMSAigqIIsiP0WtW1nXPe5/5OVXdj9V6NSLqhruu7//nd83/3d+qdHWkeUwKznljHdm//4Kc//amlxx/7spe9nCecYIc0NTX1k9tuL+s1IqxpbEhGpk1GRqYtIlqNqWOPOUYqRTBLX1/fEc89IjNtAxYWFiCQCBBtadKbAWkbGwxh1pKRsQF19/Yev/Q4NnHEEUeUZaEICwsLizZBsF6aNOsope7evp/fccfNP7hZPHYkFCAQCAQCgUAgEAgCAgUqUECAQCiY8Xu/99Zzznnt5Pi4jC0ntiWF2iDtNGkyRSUqlCAULWdWbk01G5MNttPk5MR5557X1dNrJIWkUEhKkkDTIiiCQgTrycisZ0gw6wmFCzkgQDKyyYRMWhVEUdZq9Te96Xfuu/cennCCHdLPf37nVKMRRZGYOauVtVpZ22PPPWmTmCUiTj3l1JFVqyOCTYhtk+Q0IDZkIjQ2Orr3Pns/78jngdlQZ2dnd0dXo9UyYq5UFuVDDz989933oGDH8553v7tqVSBm2LgNY7NlQk6DRteMsZ1OP/2MBx58MKsEMSOdNkVRslVimm0eDff09q5avfr1b3h9q9XkiSXYIf3gBze3mi0gK9tpm82Rma1VNffYY89jjj7a2WITZ734rEKy005+yWCTsmW2QRLrCMQ6EVE1myecsLRW62BzTjr5pObkhNvYmsy0jR2m1WxFFNd99zp2SPvuu9++++6jkG2EhG3WE+t4BmvZShVRRFFOTE6BmbPLLvuz//jOd1pZJWY9TcNOtkygREnVrAoiCBnPYD1JmeYRwVoSqEhrcHDw61//1w994E95Ygl2SD+4+aYo1Wq1MDZzYXtycnJwaGC33XeTgk3svvvu/QN9zWaDDWkGm2NAMtgGxObIrarZUaudcfrpTBObOOWFpzQnp8qyNFtmMG2GFEgUxf+99ltgdjySTjr5JKdZTxLrGQxmY5JAoCiCObvnnnsu+/jHO7o6KyfbIgWzGdukuzu7Go2GQsxinKoqt4oImy1Je2Bw8E8+8IF/v/YankCCHY/tK6/8Snd3j60ZBYSFhYWFhYWFxSMkNRuNY489FhUo2ISkt7z5zeOjoyBEm4yMjEybbUnMMBjchs06AoFAgAUyYCbHx/fZb58jj/jvWTXYnP33f1pR1rHYHKcxthUiRIQlFyo76g8te/jBB+9nh7T77nsaR4Qk1jOYzTBrpalMq7urg7lptVpnnXXW8hXLnQkBAQGysKiMhYWFRXpGug07TBGxetWKV7/6Nz//93/fmpqqppoFyAmJ0jIgyVhis4xMgWTFueedt2r1cp4ogh1PZt59111SFFEg5qgoiqrVPPDAp7Nlr3nNa4oIW5gtk23WCqVtkMTmCKRoTk6ddOLS7q5em83ad999gdZUg2kCgZhNKMQ6TrDo6Oq642d3/OjWW9khPfzQQ1GUbMKQYi2zAUngtu7uXhBz8M53vfO2n95uM0dCzBDTxsfH9tpnr99/10XHLz3uoosuXDMyIom1DNhKy2yVIUXvQN+Pf/LTN73pt8E8IQQ7nl88+OD4xGRRlpJwMAcWVVUNDg8dcMDTwWzBrkt27e8baFUNYzYUpkC2wZKYISMkNiNw2GHI7OzoeNHpp4GLssbmDA8vWLxwEUYgUVWVbdZTqI0ZTrfJKYNdNVu33HorO56qqr585ZfBbEoI0SYUIgQIJDxNRa2tZA6+de23/uozf1MUJQSITUQwm0LGESqQTNVsTI6Pf+TSD++x+x7p/OP/+cev+a1Xr1i2PCLYToqoWjk0PPS5z33hb//ub3hCCHY8X73qqqnJKdrEnGlsbGx4wfB/e85zcLIFnV3dp512yuSaNZKYG4HYmvHx8X2fts/RRz2vqlogNqejo/OwZx06ObZGYJDEJiSxlsEIZ1aE/u2a/8uO5+JLLn54xQqJzTNb0mhM7bv3Prsu2YVtufPOO1/+spcXhSTmSLQZBBRFMTo6esFbzj/rxS/NbIZC0sc/8Yklu+4yNr6miILtYoOzcv9g/4UXXvSTn/yYnV+w4/nCFV+sd3Y0m5WFwlrLIYeMjIyMjExb4marCXnIwQfVO2pmiySdcOIJrjIQm6P1QgpJIYUUCim0DiAESIqIZnPqxWe+qN7RF1GyZfvtt19WFcaZEmIdp51mhqSQQlIII1Pr7Lr9jjvuve+eRmOKHcZlH//4xy67TEVUtpUmDQYzTQjRJiMjs5ZRKiYnpvbcY4/dnrIHW2X7/e9//3hjIqEiHbLELDIyMjIyMjKywxlkuhodGXn2sw9////4H5lTETVm9PX1f+1rV7Umm85KIEsOWWyB3UKJEmSUIora6lWj57z2tePj4+zkZJsdSbPVWrh4YbPZqtc6HGIOLJBGH1724UsuvvAdF9mWxBaMjo4ODi/s6e+TmC1MW4rZLNaSeYSNIEBSs9nMVvPrX/un5x11tFSyZT/84c2HPuuw3oEB2iTaRJvTQEjMYiGzlrNVL8venp7DDzt8wYKFtVqxePEuuz9l98Ghoa6urghNTEysWrVqdHQ0M8uiBJrN5lRjynZZlLV6zfbk5OTE5MTU5BSQmUBZ1jo7Orq6uttq9RLITCAigKrValVVEVGr14Hx8fFly5avWLHiR7f96LpvX9fR3aUiMtNimrHFegYxTSCJWSSNrlr1xnNf9xd/8Wm26pprrnnRmWeoLNKApGAOhOVpaTcnp66++l+PPPIoO6Vglos//KF3vfPdgwuGKiMFW2A7FOmUxDRLOCkVK5Yve9c7L/zQ//owO7OSHcwD998/Ndns7OyMiAozB7YlRVE8ZbddAUlsWV9f33Of+5wbb7q51lEXW2VkEBuRmGacnhibeNazDnnuf3uOs6WiZMsOOujgzq5OScaKcFumICQ2IbNWGFNMTE6NT4xf9Y2vyyHJgE2b2pI2C2SbtSSRxhAYhBAYGTAIYQG2mJYoaXPwS0Zmhi0hQNDZ021nVVWAkRRMM+uJaWITdoBdvejMM9mqm2/+wdITju8b6KsSxPYqoli9fPkHP/CBI488qqqaRVFjQ+94+0VfufKfv/Od6/qHBrOycWI2IclYEusIE5B270D/JZd+5AUvOObU005npxXsYG688capyUmVRYXZFgsLQ6PR3G33pzz/qKPIJtvy9re9bXLNaCBmSZFiIyksLDZlKSKqqnHa6aeVHb2KOlsVEWeecUZjckqWbLbKYq0UDpX1jlpHZ9TqqpfUS9ULajVqddVqqtVVq1OrUS/VUVO9rnpdtZrqddU7VK9RL1WvqV6qo656h2r1qNdVr1Ovq15XvaZ6qXpd9Q7V6+qoqaOmjpo6auqoq96heofqHVGvq1aPWi1qZeVM1pGEmbupqcl99t77sMMOs1tsQVVVb3zjb/f09WeCWEsKfklsWUSsWLH8+KXHvv0db7OroqixiaIoLr/88oGBvqmpCWEwG7KwsNgs26FSUb7t7W9bseIhdlrBDuaGG7+HnU62ysJiLUl2Dg0NLVmyBLNNzz/6+UWtTDvttC02ZeFAYiMWFtNEs9Xs6u4+/vilYCnYltNPP31yYty4TXZommdgMAgLizYLCwuLNhOkEqfToAiFDIkSERgbiEBhSAICSRFIFsa2TGEKE6AEY4PBli1vAFu2bBlZWLKwBGHChE2VacwMgUAgNmZjPL5m7LTTX7hkl93SZgte97rX/egnt5mwChDg9ZhhG+Q0G3Pb2NiaRYsX/fVf/VW9XpcKtmCXXXb5s49/bM3q0SpbrVbTrsCAhcWWGFI4wlH0D/T/5Ce3n3veeemKnVOwI7HzK1d+ubO/zzZzkJBg0xgbP/64Y8t6F1GyLcPDw0/b/2nQkqwQYGFhsZFkHQuLRxiqKscnJp+2/9OPet7z0hVzsPfee5dlURQByVYlJCTrWLRJKlCBwgoIKKQCFUgmrAIpLbtQFChQmDBhwgorUECYMAEFBAQEBAQEBAQEBAQEBAQECDPDrJPpiMLGbIMESXdv9zmvOQcaRdTYnCuvvPLyK/6xwhazCTGLMyPCbEDIWU1NTF188Yf22mtfLLbqVa949e+8+U2rV66CjAjbrGfWsTCbIdGqqoHhwSuu+PLH/uyj7JyCHcnY2NhPfvqzsqwjMTeGsiyoqgMPOIA2iW2p1Wpnv/jFa1aNhARIgeS2NBsKNmYjIyjLsmpMnXbqKWVZEwVzcMABTy/KQplBgDxDMxAIzBYJhaRCKqRgQyKkAElIgMFgEAgEAoHBYDAYg8FgMFg4cODAgYXBYDAYzEYkgUBsSBAmWM8updFVK1/+0pccfth/t4PNmZqaeu8f/kFnVxcbkmQsiRkSChmLXwpJztFVI+ec86rXvub1mS0ktuXSiy895JADWs1GkKVCRkZGTLNJg9iEIZFE9PX3vfv333PD965nJxTsSL53ww1TE1OhYO7SVasaGB4++OCDwczNcccehy2FFMyRMdM8o2q16h31E05YalsSczA4MLRweEGr1cLmv4IQjykhbIHYGonG1FT/QP+73vX7YKlkc4444oi777mn1aqE2JhZy2yW7dHR0YMOPvDiiy+1q4iSOejq6v7sP3yu2Wi1mq3MlsRGZDCbJQkoijLt8847b2RkNTubYEdyzb9d02o1FMLB5lhYWKwVEHZjcnJgaOAZhz4DJ3Nz7DHH9vX3Va0WJG1pZcjBejIybTIy04RAxm1ZTY2tefr+TzvyiCOrbDE3EXHcscevGV0jFWFms7CwWCsgINgiGRmZtRISkq2xDdg4wUwTIYUUUkghhRRSSAoppJBCCimkkCKCIoiQQgopRMghQgr9EpJDFpA4Za8ZHX3ve95zwAEHZVWxOe9573vuvOvnMoVKKUJrhVRIYVtIKJ2ewXqCMNlqZVV95KOXLF68RCqYs0MOPvRP//hP1oyMhZSuwAgsZRGOEBswNgaLxCkndPf33fi977/zogvZ2QQ7kptuuinKutMg5qzVbO6377493d1mrspa7cwXvWh8dI3ATmzmythlRKPROPXUU7q6ukLBnJ177htsS+JxFxFVVgIF5nEiKSJWrVh5/PHHv/Wtb8tWM4qSTdxwww2f/vSnbUtiKySbTUkaXb363e9+98knnmpXbKeL3vmuE088Yc3omiJCEmY2MYsAyxgQ04Qz+wf7/vqvP3PFFy5npxLsMJx53Xe/21HvxGJuBLUostE4/gXHlkUdxJy99ffempkC0myBzEYkBdju7Oo68cQTgYiCOTvqqKPKKMgKDBgsLDZLkg2IWWRkhDCPCAgI1pHZlO2IQLRJyMjMkRCVZbaPKRST4+NPfepTP/2pv6jX61HW2MTKlStf+apXqSghjNiCdNoZRTCLoFCMrFp95BFHvvvd78GVVLCdIuKzn/37/r6+qlm5SoHYIkkGjBDIdihC0dXZee55b/z5nXew8wh2GJOTkyOjo/XOOmFTMYuFhcVGhMqyVpbl3nvvDUjBnB140EH9A/1VVUGCUaJkQxYWFrOFYnx8fL/99nnBC17gbLI9yrLs6qxnJmKbMlOSbR4vBguLjdipCMxGLCwsNqsoipGRkXq9/n/+z9/tu9/+WTXZnA9+8IMPPfxwo9FEkcLiERYW5pdEmwwWiLaJifF6R/nJP/9Eb083KnhUhocX/sPnPjuyenVIMlsnIWGmSTIoiq6+npHR0def+/rJyQl2EsEO4+d3/XxicirKcLaEmWFhsREZGRmZqcnJXXbZ9cgjj8yqyfbo7Ow647TT1oyOSoAhIVnPwmJTIhGtZuv4Y4+r1TqgYDudceYZU1OTILZFEiAhIyMjs5Yxok1Gpk1GRkamTUZmIzIyMjIbsWQpbWaRkZERAiMeYWGxJQI5x8fW1Gvl3/7NZ57//GOq1mQUNTZxzTXXfOqv/rLCVaZlY2ZYWKwjNMN22oiIIB1JKCbGxz74wf952GGH28mv4IQTTnrT7/z2yOpVKgIzF5assFQpJ5uN/uGBb37zmv/1vz7ITiLYYdx1993NxpSzkizELAkJycacOTU1NTw8vMceu4PYHpKWLl1KpgQk6yQk6yUkJL9kSGe9Vp56yslgJLbT0qVLJyYmMHMgMOZx4MysUkWRYObEkKxjMVtIq1es7O3u/vznPnfWi89uNieLspNN/PSnPznzrBerKC05ZMA8wmDWsTAzBMI2UsLKZQ+fetoLL7jg9+yWVPAr0aWXfORp+z9tYnw8ItgeBotmVfUN9n/gQx/6xtVfZ2cQ7DDuvPPOWlc9ncyZyFZz6vnPP7osa1EUbKfTTjutVi+dFXMm1Jic3HfffY46+ihXDUlsp0MPfWaE0mYWG5vNUWYyS5gwG5FZK0yYMFsnCCPzCIUIyRkgNiYIIzObIFhHRhAmjKtcuWzZ4Ycf9vWvf+20U09vtRq1soPNufTSj0RRVpmgaSCJ9QRis6xA8uTE2G5P2e3PP/7JUCGV/Mq6u7u/dtVVrlrOVlCJZPOEC1zgYB1BSEGA9Ja3vHX16hXs8IIdxlev+mpXdxebIzbLURRVVR36jEOYJrbTokWLn334s8fHxoXYHLERC6Ympk4+6eTeviEr2H4HHXRwWdaMzdxIzJlnpKexnQQ220tGxjZG0ujo6JqR1ef/7vnf+MY3Dj/s2VXVKss6Epu4+uqrL//C5VXVEgjEXAmqrJrNZmNi8kMf+tBT99oHxGPkqXvu9eGLLx5ZuVIS4BnMlTFdPd233vKjiy66iB1esGOwfd13vi0TJoyyUlZKk5YRBASzpXHLreEFg4ccchCP1hte97rWVFWoLFCBwoQJp5xyigwySEhIyw4VZXH80uOBiBrbr6ur+ym7795oTZkUKaecQQYpp5xyyimnnHIVJCQkJGQqUwkJCQlpV3ZlV3aVylRaCWlXZEVWZCWnnJCQkCZTaSUkJKScIqWEhJRTTkhISJOptBISElJOOXGGM3DA1MTkyuXLDj/smV+64ouf/MQnBwb67CyKks357nevO/slZ6NAAgRiAzIybTIyMgKJwNi10MTq0de89rd+69W/ZSeIx86b33zBK175itWrV0YhZjiNmcW4hVu4Ik1CQtoJKrLKvsG+z/zN3/31X3+aHZtsswMYHR0dGBgYXjjUaqWQMdPCAsnCNiAJkIE0nhwf23P3PW7+/o1dnT1EwfZ7+OFf7L77Hj19/c5EPKKSaZNYzzZSY2JyjyW7Xnfdd4aHh6SSR+U3XvEbn//c53sXDMpI4ldjm/Vss54k1pPEHFisJbMVkuyMKGy3JqfGxsbKojz00ENf//rXvu51r+3u7quqVkQhic2pqurwww6//4H7G9kyArGeJGaxkJnFYEmTY2N77f3Ub37jm7ss3iWi4LG2YuWKZzzjGatHRyNKBKgNMGaGbWaRAAO2hWU3m83uzq7rvvvtffd5OjuqYMfwH//x70UhkYUUUqAgAgmRdjqNTaazsiuTVpKt6mn77N3V3WvMozI8NPyMQ54xNrrGWblKV+kqs6qcdrrKrKqqVVWtVqvZalVVNsYnjjzieQsWLILg0XrBC15AGYpAbQHilxSzaD0gM20jIRmvBUQxTZuwsbFxG3MiIyOzOUIy0zI9OTm16uHla0ZGurq7XvrSl/z1X336W9+6+nd/94KujjKzKopSEpuTmbvtttuDDzzoVKlaUdSKoiyKsijKoigjiogioogoIopCRUQRUUQUEUVEUZZlZjU1NXXpJZfsumS3UPBrMDw0/Oef/POxkVGqVrZahlZVtaoq05nOdFt6LWwyyZQti6AIRW93z+qRkbe85YKpyTF2VCU7hk996lOtVq5YsQoLbDPNskRbAKJNgAqEsoiomnnC0uMheLSKsnb++W+68KJ3lWUBNghsEG0WCEloWtqdg0Mvf9lLwCAerZe99KW/9/a3tRpTMq10Om0LkNxWmfXSZpoBSYBtibayLAxOZ1pCEsI2M2ycAQbTJmdWtNmmTdisJTDTBGaaiAgbMAgLbBSiq6uzq6uriOLQQw7+b8959qGHPuPkk07adckSqVa1xqpqsii6xNb88R//8YrlD2eKNsmizYDNNIPYLLURQdWo3nHR20875YzMVkTJr8eZZ575R3/0B5/85J8XRVnZaTFNYppm2M42J8YggaKQRAEeGur/+te+8bGPfuRd734vBDse2ea/nq+++l9v+/GPknRiLMQ0I2plSZtBRBQSRVnalEXZqqqjjz5yv333j6jzaGVW4+NrpqamMhMMCAkM2ICY4bRSMDAwGLWuiJJHz9+65uqVq1dklVNTk7arTIlQgZ2ZiLVs0+aCDUlR66iTOTU5oShoE9NswMJJpsCAcGar2aoyE5yZgNOItWwLJBk5HYparW6STEs2iLaOem3X3Z6y1157Dg/1dff09vQuoM1TVWUURVEDsVWZ1Re/cPnqVSubrSagNtNmXKUBO6WQAhBmFoWKoghicGDghaee0t3Thwp+nexcsfzhNWtWTYyNTU5OJa5aVbPVkl0UUdbqrVY1OTWRaQkQxk4iREhCTE5OdXZ0PP8Fx0glOx7ZZueTIDDITilA/KrMNLOWBWZLFPyqDAYzTWyD2IDAYBC/JDC/JB57LWymBWDaJITE48rYKHicJNPEOgaBMYgtELPYSGLHI9vMmzfvySeYN2/ek1Iwb968J6Vg3rx5T0rBvHnznpSCefPmPSkF8+bNe1IK5s2b96QUzJs370kpmDdv3pNSMG/evCelYN68eU9Kwbx5856Ugnnz5j0pBTubZrP5jW/868EHHzgwODAwOLh48a7n/875IyMjbNltt9124Tsveu97/+D6629YvXr1yMjIXXfdddVVX/3//t//3Wo2mDfvSUm22XnceecdL3zhKfc/cG+UpYmqgkrj42sGBnq+8pUrjj7qWDZRVdXSk0645tpry6iXUlIJbBqTk0996u433XRjf/+wFMyb9yRTsi22b775B3feeUej2ezu6lm4cGFHR72qqlar1Ww2mq1Wo9FsNhpTjUbVagG2G81mq9XKrJxME+vYrCNm2Gk7MwFFm5jmrLKrq/vVv/mqKGqs12w2X/Wq31y+4uGiqBkpijJw6cF6/8jI6nPf8MYbbri+p6efDVVVNT4x3tXTU6oIY1e0iQi6e3psEDuvH/3o1h//+MdAT09Pd3dPd3d3Z2dnvaNer9WBZrM5OTXpzKIoJXla2lRV1Ww2Go1mVbVs2sqy7Ozs7OiogyYmxpctWzYysnq/pz3tsGcdzrwnqJJt+dznPvumN53fqBqVUUStVosIKdPOKrPyWmmczPC0tJ1ME2LzzDShCMBVC4wBU3mXJYt/4+VndxQ11vvFL37x/Rtv6O7pAQnMOmn39vX/5Ce3f/nKK175inPYUET0dPdEhJBoE48wSBjEzuj+++49+ujnr5maRIoo2uIRCrAhq8oGWwJkLCltVwnYBpypIsqykDCuprWaY1PHLj3m61/9F+Y9QZVsy7333rN69eq+BUPhRNOMTSCiqEUBQsgp26hymjZJzBBOs55CzJACMBZtYppl2gytRqO3t9dmtssv/3xHV2emFWEBCUhBFEHaXrFiFZsoiqK/v99mLUnMELLZqd17z90rVqzoXbBAEtMMpLPVrACJDZh1jEASoBDgkEXlaXLaFGUx3mxi5j2BlWyTDUgKhQymTYhpos20CZk2WcwmZDHNIISYIQTYZpqZTaBgmpjlP6+/PqssCgFmA5IAm01JKosamzDTQsFOKytmmA2JaZLYkMxaAjHDtBkZMAghCSFAZt4TWLAtZVFjFimkYJrYkCRAGwIkYaSQxNy0qlZVVYjZ9txjz9HRsYgSMYshsYqyXLJkCZhNSGITtoUKBTstFQWbo5BCzJCR2X5impj3xBVsS1EUzJCCCAsLKyyZsEicOHFipplNCcRaFhYWFgkJliwSp2wxw8bYzPLa154DZOIUlq1EtqRYueLhQ5956Bmnn2G32IQkwCJFihQGzUASYucUIbaHhYVFQooUKVJYWKQwpLBkBWAF8564gm2pqgookTJxYrAEAknMMKBEqQiDZzCLJHAoQKEIBTZ2QEgRCoWkALIKsl5IYJtZDjjgwAvfceGqVSsak1PNqUZWWTWqxlRj9fLlS3bb9ROfuKyjo0Mq2YRt2sSMsCIVEEZC7LRsAzIbkZGRIV3ZldswmBkSgQMHDixZrKO2UIRNWzLviaxkW6qsgInxMTsBO2wDbkPgKIP1JNU7OqVgQ5JsN1vNrDJbTQmnJWzaMhMoorBsVxJVs2o0GgrAINb78CUfPvDgp3/q//n0HXfc2Wi16vUy0Etf/OI/+MP3HvD0p1etyaLsZAsMiDYDAiHaDAaxE0qzBbKrqYmJdLKOwEyTAAnMNDHNrCOwpMwEqlaTeU9cJdtyxhmnDQz1dXd1AzIGHAhBYsAYTJvKianJP3jvH46sGa3XO6VgvYgYWbniNa95zWmnnjo+NhohIdpsg5hmEEYY29nV3SWxCb/+dee+8hUvv//++x+474G+vv7FuyzZddddkewsyk62zCCmGYI2ITkBsXMSM8wGTFHE2MjohRe9/eADD66ywgmyLaZFhMCmTcKAaZNos2kzVK3Wbk9Z4qwUBfOeiEq2Zf+nH7T/0w+GFgSIdQwCMc2so8nG5Ic+cPHKVaupM5vtqtl81jMPfcnZZ4OZJrYowUDVaoHYgICurv599+3dd9/9aTMoAElskZlFzBAgCHZ+NhKzqNGYOvnkpS84aikkCMQvmW0w0wJadjDvCSrYNjGthACBQBAg1hEIBHTWO8968Zm1ImyznkU6ganJCcCZILYmoICiKDvYooCAQMG2SQpmyATTDMYOdl62aQvZyXrGiUkmxifAECA2IBAIBAKBQCAQCAKCaaUk5j1BBY+14487rigKzCNsMyOYpij4r2XabGOEwOykzDSxWaIAMW/eFgSPtWuvvTbTzCIpImiT+K+QTjuZRabNIMzOy6bNYDAbq5g3bytKHmvXXPNvCMQGxDTxX0fMYjFNRubRst1oNEZGVk2Mj1dVVbSVZW9PT1dXd1mrRRT8mqVNm6Yxi0SbMf8VbLdazYmJicnJSUFZq3V1dtbq9aIoeRzZHhsbGx0dycze3t6BgUHmrNVqrRkdHV0z2mg0bNfKol6vDw4NdXZ2S+Jx0Wo1R0dH1qxZMzk5OTo6UrWaQ0PDCxct7unpqdVqEPzKSh5rI6MjGJOJZaQAKvOYuP++e35w8w8l1ev1np6ewaGhnu6eycnJ5cuX77XXnosXL2FzQoFYy0oLGZEyj86DDz7wxS9+8ac/vf222277/k3ff3jZ8larKUVZlj29vYMDA8cf+4IzznjRs5512F577cWvjZW02ZIQj0gzTeJxZPv6G67/9re/feuPbr377rvvuvOuh5cvq1qter2jb6B/v333Of644w446IDnPue5ixYtZvuNjY3deustk5NTi3dZvMfue9Tr9QhFFGxifHz8L//yU3fdddfNP7z55ptvGVk9ctLJJ33hH/+xKEq25cc//vHl/3j5TT+46aabb7r/vvsnxyYzk4Ke3t49nrLHGaeffvRRRx1zzDEDA4NsaHTN6E3f//6KFcunphoTk5OZ2VGvnX3WWR2d3WyPVqv1rWu/9c1/++YPf3jLDd+74YEHH2i1miKKsqzXaj09PV1dXSefeOKLTn/RUUc9b3BomF+FH2sHH3JQT39f7/Bg38Kh/gVDAwsX9C9a0LtoGPjwJRf7V/P2t781ZtRqte7u7uHh4cWLFy9YsKC7u/ujH73EW/CSl72sZ8GCnoUL+hYu6Fs41LNoqHfhUGdP10EHHTg6utpOz9kDDzxwwolLlyxZ0tnd3dPX1z84PLRwUf+CBQOLFg0sXDSwcFH3wFBnX3+9sy5paHjoFa985Y03fs+/Htdeey3QNzzct3Bh38IFfQsX9C1c0LtguH/xYuBrV/2zHy+fv/zzBz/jkJ6enqKzo7u/r294sHdosHdosH/BcN/QcM/gUM/gQNFRk7Trbkt+4xUvv/XWH3p73Hnnz/bcc8/u7u56vT40NLTnnnvuPeOww585OTHhWS677LK99t5rweJFQwsGBxYM9g0PFx2dJ55y0tTEmLfq3nvvPebYY4aGhrr6e3qH+noGe/sWDPQvHhpcvGB4l0UDCxf0DA509fVI2mPPPS54y5sfeugXXu/KK6/c/8CnDy9c0NPX29ndVXbWVRZLdtv1/nvv8pxl5rve8/t77btPZ1dnZ19P10Bf79BA/4KhgUULBhYO9w0P9Q0P9Q4Ndg/0lfUasOuSXS688B3333evH61gp5JVKzOHFwz29vd1dHVnUbTSKsrx8fFarc72EW2umJv7H7j/RWe+6Cl77P7d/7yh0Wp1dnbXah2KsLHJqrLTznoRnbVaT0/f4ILhKvn85f/47Of891e88lWTk5M81jITcJoNCQNZVfyaNZvNa//92oULF/7mq1997333RWetq6uzKAsgQhHKTMIRKouyp7d/aOHCsfGJL1zxpYMOfsYRRz737rvvYm4efODBu+++u95R6+zudmhkfM3q0VUPr3hozejYshXLmLF8+bJzzjnnfe9//8jIaKvZqtJV2kSVDgKxJRMTE3/0vj/cY4/dv/e971FEFCVRqChtqOwqs1XZLoqo1euDi4ZWr1n98cs+ccgzDvmXq/8FWLlq5YUXXnjv/b9oZkZZ1jrqnZ2dXT3d3T09IDDb0mg0PvM3nymK4mMfv2z5yhVlZ2etViuLQhI2VVJl2LIlIoruvr6hRQtWjY5ecsmlBx584Ec/8mE72X7BY802GzIIAUL8imwgN8E0sf0ktikzP/vZvz/s8MOu/ta3BhYMF2VhWxKSIixQEJIJoxmA05L6+vp7evs+9w+f3Xe//W677TYeU4qgTdhmFvN4+NnPfnb++eef+MJTM6K3txcQighmkRCSAgXQyqQoe/sHhhYtvvGmH+61197vf///aDYbbMvo6AgQUUi02c5MJ7Y76vXJqcmbb/7B2We/5Ctf/SfAWEISagPkFBabc+utt7zsZS+77LI/Gx4eLosyMyUxQxIISK+Hq6wUMbxoeGx87OSTTv7yV678j+985/bbb7cNQiAhMc3MwR13/Oy88847/3d/p3eor1aWUrQBngGENhARoGZVqVb0DvW1snr7O9750peeNTExznYKfg0khSTTZidOMI+FKAvAAskhIEWKNknMSeCAANMmsS3ve9/7LnjrBY1WIwpVdjItRQaVMDLCAbbT6arKVmZlZlhiwaLFy1asPPKII2/54S08hkybImwzQ045wwkE4tfms5/9+zPOeNHnv3hFrbMjnUREUUoCNIMZkgDJYCmkkMJWVbmnp79vcMH73/8/zzr7rBUrlrNVrWYF2GaaDRVKu6zXOjo7/+zPPvryl//GLbfekukUKTmCiJAsQYIRm7r77rtPP/2M6677dqjMtIWFZgQSAjLtqiIzTdpOOZ1Vq17v6Ozqef25b7j++uuHFy0C7ESoLcLgTASILfvZz3526qmnXfnlL9frnRBSpNNOZjiTxEZRQGQ6HLIAKRQRRFl09A32ffGLXz77JWePj69hewSPi5B4LBRlQZtk8Vgw23L22Wd/8i8+WVUVtozSgG3JWbUm1qwZWfbQmuUPjS5/ePWKFatXrZpqNJBos5khqVVVfb19a8YnTn7hyQ/cfx+PKSHbbEr8mvzTV77yhnPfcP8vHjBpZ4JtMEjIJmZ4hqSIwGlXYGywZJNlFANDw//0lX8+4YTjRkZWs2URwUakRqt10IEH3fSDm/7kT/70F8sfqjLZDGPaxGY885nPXDM2UlXJDDNNIMR6VatVVVWz0cyq5TSoDaiyKmvl+MTExy67rMqs12qZKcSc3Xjjjfvvv//y5csSF2VJmwkJkOQqJ8cnRlatWrVixcply1atWD4xPtFqtULBjABESKCBof6rvvq1Cy64wDZzVvK4kII2m19NEQVtZpoDRJuDaWb7ia257OOXffP//psQDkAR2M6UNLpqFfZBhxxy0kkn9nb3CIO+972brv33f1+x/OHegYF6rSOTZJ1Mevv677vvvrf83gWXX/5FHgtimtg8Kfg1uOH661/6spd1dHUmlsIILJNVIkcUUxMTo+MTURadXR1OGo1m1Wx29XTXOzvCziotORTIFJL6BwduvPHm157zW//4hS9FBJtT76jTJmNBACGqycbChYuuuOLLa9aMD9brrCeQSZyQNk5AbCCr6pWvehVkY8oIhABJgB0RVZUjK1d193T39w/09/bVO+rLVixvtqrlDz9U7+zo7Kw7KcqIorOq7EhDWZYgsEiZrRsfH3vd6143NDzcylTISAqJgKlmc3x0zcLFi44/5tjDDjssQoZmo/nd7/7n9ddfv3L5ssHhBXZaSLJdRGFn30DP3/3t/z7ttNPPPvslzE3J48NME48lJWvJgHl0zBbccssP/+RP/wRkO0VbSLazVY2Mjh533LFvf9vbjjn2mL6+AdarqtZDDy/7zGf+5mOXfXT5shWDQ8OkUQI2bf2DQ1/44pe+dtVXTn7haSAeEyIkDGI9AbV6jcfavffee/oZZ3R0dKSNZFttiXGtVo6OjjYbU8961rOWLl361Kc+dY8998isHnpo2R13/Oyfv/rVW2+5tazVuzo7bWOQjIGIGBjqu+JLV376L//8Tb/9Zjano7ODNjOL6l1d/37dt0dWre7p68W02RaKCDuzqhpVZYuqBTZmlp/efvu3v/MfFY4Ig4VARgJp5bLl/QP9573xvFNPOeXII4/o7Ogg1Kqq1atXX3XV1770pSuuvvqbnZ1dZURmRgjMOsk0sVW2X//6N9x9zz1IgkTGNkUwPjZeFHHRRRed98Zzn7rnnvV6J+u1ms2f3n77pZde8rd/97/rHfV6ZwlCwjYqolbWqz963/tOPHFpX98AiG0p+fUwIGTaZJwJVJhfTWbSJjCPsJhhtoMlhYItyMw3v/mCVtUysvA0gspZrRkdveAtb/7IpZeUZYerhjMlIQFFUe66ZJf3vufdp59+yiv+//bgA97Ssjz38P9+3m/tXqYPZUCaFBEERFCKiqiAgDUIaiyxoKJiS4xoTjTWqDEe1MTEigKCORpCUZSIQdQgYolRkWABQWGYtntZa33fe5+198zAbKbPbIz+2Nd15lm//NXt7Z3tKSVkEKgoaobzP/yRk04+lZ1nWqqcEYi1JEUIuGvFyonJic6OTmbP+eefPzk5aZEiZWMRGdskVq9adeABB7z97W8/6eQn9fctAJumSJCAt77lvC9fdeVb/+qvf33bb+YvWOCMsytXKEtZEV29Xee99a+f/ORT9tl7XzZSq9UAi2zEFNud3V2/+tWvJNVqtQxIbpbjo8NVVXX39nR3dXUh7FG7Pjk+MTFZa+9ivde97nVj4xOOlJkiiSm28/DQyJOe9MS/fe97jzjiSFpcoWDawvkLz3nFOWe/7KWXfOELrzv3tSPDQ52dnaRk7iOQEVty1Ve+/MV/u6yvp9cCKRygnKuR4eHFixd+4pMfP/UpTy2bkxGFnaVgWlGrHXTQQZ/85KeecMIJr3jlOWWjmWptxgZEtrq6un/2059d+PlLXvnyV4itK/j9sGkRO8k298lswGLLxDpiA2aTrv/W9Tf98Pu1jjZbtjHCtkaGRl7+irM/fP5HcNO5Umrj/gQ84tDDLv3CJccd/zi14IxB4Jyb/f1911//rRu/959HH3Uss0JIYgPNsuzu7zvnVa/6y7e++cUv/LODH3ZwvV5fvXr1xMRErVZra2sbH58YGBgYHhpqNBr1+uTI8Mj4xESjXl+5cuXQ4ODExOT111/38EMOZaahoaEPf/Sj3d1dkbNtkEAQKQ2sWXXcscddeunnd999j3p9tMrNFDXRxnq9PfPOOuv5xx73uOc977nf+c4N8+YvqHK2zbTsrCINrh547/vf/4mP/TMbSUXBRmzX2tuEsIuiGBkZzY3GiSeeePxjj3/Yww7cd5/9dlm6RKHBgTVDw8MdnR2sNzAw8J0bvuuAAAXYgAnF4OrBs89+2cc+9g8RtVxORtGBEjMVqe35z33+wQ972KlPOW14ZKitCNtMEYgNSWzKv1z6hd6+vuwMCAGSyrKs1YpPfvITT3nK6c3mWK3WBWJTnvu8Px2dGH3FK87p7k1KIbBBZFzUin+59F9e8qIXtrd3sTUFs01mc4JgZwkQ28fY5CBkpggj29mZKWIjl15yaarVqspIEFAh1euTjzjs0A9+8IM5N6VCITbvEYce/vrXvvZd73pP34J+TBYtYSLS2NjEDf9549FHHcvOEWuJmYRqbbVGs7l61ZoPfuhDtrNNNqCWEBLgFpCnhCKkQEkaGBxccc8KDuF+XvKSl/T09NlGEggwIY2OjDz84IO/+MUvLl26tGxOtLd3g9iUPZbteeUVXz7mmEf/8rbbuzq7Q1i0CJDa+3ouuujzbzj3dQcddBAz1YqCTRCWoFakVStWHnzwwe9993tOOeWkotYOOJd2lrRkyRIQiPXOO+8tqWgrcwMpuwKFVaQ0NjR84hNP+PD554fsqhlFB5t3xGGPvOrKK4497vhcVRHBWmYtGZlNajab/3blFSqSc9YUwmEYGx1+5zvf8ZSnnF6Vk7VaN1v0khe/5MKLLrrxxps6e9qwEWQMtc6uH/34v+684zf7PXR/SGxRMMssIXN/EiDMzpGCzZDFZlkWmyLERqqquvjzn6fFZppxRNTHJ1/96ld3d/VASGJr3vCGN7a1F9lmA7ajVnzlK1dDBWanSbLZkCSbIhW1Wi0iUkq1omibVhSFWlBLpFS0tLcV7W2prYiWFEWtBkjBTI1G479/8lNJdmY9Ozu7vb3t4x//56VLl1Zls6h1gti8/v7+K6+8qhZFzmaKmaKWolabHB29+KKL2EhfXz8twjIbEFPWrFpz1FGPuuaaa05/6lMVcq4ARRGpTVGDBAFi2uDg4He+c0POOVIS2GBamo16USs+8P73tXe0ZyelGlvzyEc+6m1v++uR4REp2ATZZiOf+ewFFtiSaMlImpyYfMhe+7z85S/HOVI7W5Oi9tpzX1c2yhQhCbNWRBofG//mN6+HYGuCWWWDzQxhJSmYYnZO1AqgsrwBsthOoYDAIDb2ox/9iKScM0pARCSl8bHxh+y916mnnmY7IrEN5s2b98xnPrNslpYgILJCkWpF2/J7lk+Mj9oVOyFjQICNmRYQELZAEFKSkpQUSQpFSqmWUpFSkaJIqRApVIgkJSzbgJWZ6b/+67/WrBmwMxuQGBxac+aZZzzmMcdWZSMVNbbBPvvs+1d/9dbRkaGiiLBlQeCQI2q1a/79a41GnZkWLV4MWAnTIhzOcgZPjo8/ZM89/vVfv7TbrrsBKbUpEpt3++23/+rXv2aKsRMRhBSjQyOnnfqUww8/Mucckdg257zynAXzFzWaZSYyqnCFK2wsZ9ls5K3nvSWlJCkUiSSHYHJ89PTTTl20aDEKSWyDU59y6i6771pVFdMsLIoilY3Grb/4hY2d2aLg90BIYjYkJTZLbJbAmI0JsZF/+Ng/oJZAtOQpVdls7L3P3rss2UUS2+zZzz6z3miwgcru6Oxavnz5LT+/WQpmg2024mlqQYBttB5yNjbZMmTLUiSHcs60SMx0++23l3kK64gWKaV4wQtfAKSixjZ70YteJOyc2YBxZ1f3j3/837+89efM1NXZpRZA3EuAqE9MvOMdf7P7bnvYmW3w5auuam9vzzlj7uXsVNSe//wXABGJbdbfP+85Z501OTnJpomZbI9MjqdIxqzn7I6OjhNOOEES26yjvePYY49tNBo2M0TcccdvyuaYMFsUzLbKNjPZOWdAiJ0j0SIyUwICgq0RAmTChJGZZqaI+/PNP7vZBBGsp5Rc5eOOPa6sSraHJJclyNOYlopi5YpVd9xxBwQ7T2IjmhItSRFIRkaQUEIBCcmQLVtgXOXKSCmxKTfddBMhi7Uksj02PnbkUUcdcfgjXTVBbLNddtnlmMccMzkxYVtrhVps5ezbbv8NM0kC7AozTRCg+vjEgQceeMrJJ9lZCrbG9vkf/nCK1GJA0whZixctfPjBB+EKxPY477zzqMy2Wb787oiirCwSCIiInHNnV+chhxxSVRXbTFJ/Xz9mWoAMld3R1fU/t/5yYnwcsWUFDwALiRlC3McgdpDZfsYGi8w0IdNisLif8fGJkeGRCLEBQUd3179ddtndd9/1lje/Zd78ebffdvvA4MCee+y5ZMmSWq2WcwVqqdfr4+NjRVFruf322z78kfM7e/uEwNzHQL1RgkE8MIaHBigrFNzLmbWkiGSwjZgmQKIIAWWjzkyXXHIpNtOykAA1J+vLli3r7u7BZjudd96bn/6sZ7QVnbZZT0GV8zev++appz2NmSJCRoj1DPWJiUceecTCRUvZNitXrli9ZnV//3xaxFrGk5Njxx1zwm677YoS22m33XarFUWgClvIbMEPfvCDsqxqtTawwSJQFEVZNl529suecsop55xzzuDA4Fe/evWvfv3r9va2RYsXL1gwf+GChbvuuuvChYuKosjO7W3ttn/4ox9+69vfLmqFbRDrRZFWrFzZaFQgtqhg1gUWBrEBBWB2lrMBMYOZpsxmZBtDgIGMQQixKStXrFi+fDkJEOvZbu/o+PUdv7n1V7+86KKLFaxlW2ItAxYCgwOQVGuv1WptzhUSaxnnDDSrCgxi51RlFSmBmSak7LGxkWc98/Q9lu1ZNpoItRhnW1i0hFpQC1K2TWWDc67KZrnXXnvalZRYb8XA6q6ubhuLljLnkBSx/377QAO1sZ2e9OSTquyqqiKCFjtJOXDOv7zjDjYSEaxnsECByblim/3whz9IKYwtwIBlB83JyaVLl7a1d7ND5s+fP9aYxBYIZLLJYImZ7r77rqJIzhmBEMpkQEXthu9978Yf3PQ37303yBmEDNgCBAaSg3XcrBpt7R0pFTZrCWVFlZv1RqMsG9iILSiYZZZkYSFzLzM7JDbHYrOMhQEhIwQYC4yYaXh4eGR0pLO/l5lsR0rtkYwlA5JsYzYQZootCQwIWwo7M02ScwaGh0d4ANhOEc16/VWvOueExz4JzBQzRSCmmClmHTFFTMlMKW2xXlmWVVWxnoXBECn2228fENuvKIrurq6mHQIzzRKIypmNSGImMyVXmW122223IZDNOhaWmWJ21Lz584fv/p2kAJl7SdxPvd5MUdiWBFjcq62rE2eECBAgpph1BDLTZFdF1MBgSTbryQhkia0pmFU2ttmInQExzSB2jCTAFhgH6wQtFpshphjEFElAztmYjTQaDSBXOVIwUygQOIOksDPIOMx6FlOyBARgK2dATMkiOxeRoiiqqgKx01KRqrKMCMQ0g4CJ0XHAOSNhs5YMYoq5j5linG0kpJok1rvrrrtsLGEDMoHA2Xnp0t2gYIcsWrBo1ciQjZhimxZJZmO2QbQ4sZZAZJtt1mw2bbIM4l4WYMyOKookpBCVZQwWCEnMZBsCjEWLzDoKCQVTsnM2mBkM4j6KBLKZyUCmJdiaglnmFjYiZkfOmXXEemaKLDZDLdwnu7KVUqJF3E+Vc6Rk7kd2jlBEVKZFCowMRuZ+pABkwJK4l7CtFEghgdgJktgkMU2AItEiNiI2phCb8LObb0ZsSMLZGClA7JDu7u7VYyMuMxsKVWXFZon7kdhm7R0dBBsRLQp2mEGAwGyFJUCsJ8k2oAimCVlGYmNmmkEIzHqmxQpFSmGwMYgtKfi9CAmwzc4pqwxkRIuyjYiEmGI2Q2IGM8VWSIiN2AacDSiEaUkpDa5ZTWVmycjwEGQIZpXBTAkFs+See5a7mhJMkYQhUxS11WtWs6MyLptVkIwlg0CYYBMkZUSLKhAOpkhsh8WLF5XNUigDQgYLhGJocChX9UjtbL+JiYmIqHJOYLGOEWImGxBYCnALRpBzNbRqFbNkAhrNuhBbVPB7IlpMi7EQO6SsSnaUWE8CbNMi7qdWFFVZtocw9xH18YnTT3/qYYc+Aiob22AhZDNFbEispxbEOmKKgccef0xV1lPRyY6SxJaIWVKkhB0SNusJclX95rbb2FETk5O5ykohCwGWgiqbTZDExiwQ22zBvPlUIGzEWsrZbd29P/vZzatWrVyydBnbb2ho0NOQMPcS9xcRVVUVRWKawDkDXZ2dZ7/4xT3d3cYgjDHbQRICyZXL9ra2BfP72ZqCB4IBgSXZzKJcVUDgCnAIAXZmi8wUgcxaYdYx91MUhbMjkjOItUKaGBt/4Qtf+KynP4NZ03RldoYNqqoqUgKznpmWzSxZtmwZoJBNGJmWjKqyuuWWW9lRA0ODtba2XBqEZedaIVBPVxcbkRS4AlwwTWaKxDbbffdltEi5ykFIIClSe3vxm9/csXLlmiVLl7H9xuuTKgqJaTLKkoW4v6JIzWazqCXnjJDALstm/6KF7//b96SijVlSVWNIbFHwe2Gb+4gdlXPFFIORUUYZme1kNitSqIVpZpqZNjQ4xKwxLpTa2AlmcwxYzJaDDjqIKWK9iEgpJO5efndVNdl+Oeex8bGqqpCRUYZsO4ri4Q9/OJtmWlShCmUkMDbbbO999l26y5JmowGYdVKKnMtGffLaa7/B9lu9enVVVcaSDFlYYDYppVDgXKEMGWOBYnx8bNXKe3DFDnOumqNlfbCsDzXrg86A2KJgttkgwIBNi6FypkUCxI6zzUbMWmZzjACzloVFi0Dc3+LFi/vnz6sqZzvn7Gwb28DPf34zs0ZI7KQQOKWUqwqzliDMlMjMkkWLFivbuXJ2trMonStyd1/v97//g5/fcjPb78ILP9fe0W4qhUM57CQazYadH3Xko8BsRCYgWMuiAoPZZkVRPP6ExzcbpSyBQZiqGYnUVvv8pZc2m3W20/nnn9/W0SESDhMg0yIhNrJ48eKqbIJZLySyR8bGhkfHULDDFKnoiiikFCpS1NiaYHaZmcw0Y2aDbe6TIUNGGbDYHGNmMtPMxhYuXLjbbrs3yya2JKYZVEvXXXcdf0jMFLFpWWaWpJT2P+ChZbPJTKlWDA0NXXLpF9hOOee/eNObEFEEGDJkCeElixfvtfdeIGayzRRDhgwZMiDM9nj9a1/fHJ8MSdwrQ+7q673xe9+77LIvsT0mJyc///8usQLENLOexUYOO/xwyiYyZDAg6OjoGBsbv+baa0HsBJNBoWgxYmuCWWU2TUwx5n+HbARhwsiIaWJjKRUHHrh/1WyEJAgpJFvd3X3/c8utN9/8M/5g2CYi5ywQyGwoHMyec1/96omR0VBg1hNWV0/vpz75qTVrVrM9Lr/88slmwzkrG8y0kMZGRh915JH77fdQNmIbsSGxIw5+2MH9/f1VVQrEWpJDVkdn1+v//C9WD6xim1122WWDw8MRArOOIECAub8993hId0+3XCU5JFrUguCiiy6uqpId0mjUV6++5+67f3f38pV3/PbuX/36tuwmWxPMMrewEVmAEC1iJ4jNEpsjxHZ4zllnlRP1FCGJaYKIGBkZectb3sr2GBgYuOCCCw477PC99953//0PPOigg/ff/4C9p+z14//+AbNB4vfgaU9/eq0oBELcS+ro6Lhn+Yo3/vkb2B6XXXZZipDEBrKdc37WM58piY1UVcVs6OntfdGfvWhieERIiPWy3d7evnLFylNPe8rY+Chbk3O+6aabXvfG1zXq9aqqmElsWkQcddRRzWbTNs5Myzl39/R+94bvXvnlq9ged955x5ve9BfLlu22xx57POyghx/+iEcefsQjDz3siL/6P2+DxNYEs8tgM5NoMVPMTpIAR9IMCZDEZgg0JSQBMjItBouNnX7aU1OtcK7COUyYtXp6+y6//PKLL76YbfbSl770da99/a23/vLue1bd+du7brv99jt/97vf/va3ith7r72cS3aCJHIWYgOGzBRZzJ7ddt39cY8/vt6oI+GEEw6bCi9YvPiCz3zuQx/6INvmPe95z5VX/ZtdCQEya42OjB5wwP5Pf8bT7IqN5JyxmEG0iO3152/881A451AKIkiiCALonz//xu/edMIJj73llp+yRR/84Aef/ZwzJuoTOZu1hEIKSSFFSEhs5B8++tGJ0UnAOStXOGdBRFtH54tf8uI7f3sH22ZkZPiMM579T5/4xPDI2Pj4xNj4xOjYxMjY2PDw8EP22jOlNjBbFMwq4+wsI8QmiP8NEWE2SSA20tbWds45rxoaGIwI7iVSis7u7pe97Oyrr/4y2+Cd73zntdd+IxW1tva2jo72jo729o6O9vb2qqqOOeYxfX0L7czOEC1CbJLF7FHE+/72/ZMjI1JGmXUMqrL7F8x/wxv+/F3veIed2aIPfOADf/eh96NAgSXu02w0XvOa18ybt0AEM9lm9ixbtuwv//IvR4aGkFlPKCI1m2X/vL4f/NePDzviyDe/+U2rV69mIz/84Q8f+9jHfuj8v18zMGgjie2x//4HHHLIw+qTdaaYacadnZ3Dw6NPeMKJd/72TrbG9lOf+rRbf/ULpSLVaqlW1Nra2jva22pt7R21k046SarY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"

# ICON_IMAGE = r"iVBORw0"
# SPLASH_IMAGE = r"iVBORw0"

import json
import warnings
import platformdirs
import tkinter as tk
from tkinter import ttk
from tkinter import colorchooser
from tkinter import filedialog
from tkinter import messagebox
from tkinter import simpledialog
from contextlib import suppress
import tkinter.font as font
import struct
import os
import sys
import math
import copy
import base64
import io
from PIL import Image, ImageTk
import webbrowser
import logging
import traceback
import subprocess
import threading
import queue
from scipy.optimize import linear_sum_assignment
import shutil

# --- Constants ---
TILE_WIDTH = 8
TILE_HEIGHT = 8
EDITOR_PIXEL_SIZE = 30
VIEWER_TILE_SIZE = TILE_WIDTH * 2  # 16
PALETTE_SQUARE_SIZE = 20
NUM_TILES_ACROSS = 16
MAX_TILES = 256
DEFAULT_SUPERTILE_GRID_WIDTH = 4
DEFAULT_SUPERTILE_GRID_HEIGHT = 4
SUPERTILE_DEF_TILE_SIZE = TILE_WIDTH * 4  # 32
SUPERTILE_SELECTOR_PREVIEW_SIZE = TILE_WIDTH * 4 # Used for an old ST selector calculation, review if still needed for that
MAX_SUPERTILES = 65535 # MODIFIED - Increased from 256
DEFAULT_MAP_WIDTH = 32  # In supertiles
DEFAULT_MAP_HEIGHT = 24  # In supertiles
DEFAULT_WIN_VIEW_WIDTH_TILES = 32  # Default screen size
DEFAULT_WIN_VIEW_HEIGHT_TILES = 24  # Default screen size
MAX_WIN_VIEW_HEIGHT_TILES = 27  # Allow up to 27 for half-tile logic

MINIMAP_INITIAL_WIDTH = 256  # Default desired width of minimap window in pixels
MINIMAP_INITIAL_HEIGHT = 212  # Default desired height of minimap window in pixels

DRAG_THRESHOLD_PIXELS = 3 # Minimum pixels mouse must move to initiate a drag

RESERVED_BYTES_COUNT = 4 # NEW constant for clarity

MAX_RECENT_FILES = 10

MIN_DIM = 1
MAX_DIM = 1024

# Unicode constant strings
UP = " \N{BLACK UP-POINTING TRIANGLE}"
DOWN = " \N{BLACK DOWN-POINTING TRIANGLE}"

# --- Constants for TileUsageWindow (can be placed near other constants or here) ---
TILE_USAGE_PREVIEW_SIZE = 24 # Pixel size for tile previews in the usage window

# --- Constants for SupertileUsageWindow (can be placed near other constants or here) ---
SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL = 1 # Example: Scale factor for display (1 means 1 screen pixel per MSX pixel)
SUPERTILE_USAGE_ROW_PADDING = 4
SUPERTILE_USAGE_COL0_OFFSET_GUESS = 20 # For tree indicator/padding in column #0
SUPERTILE_USAGE_MIN_IMAGE_MSX_W = 8    # Min MSX pixel width for ST content area to be visible

# --- Palette Editor Constants ---
MSX2_PICKER_COLS = 32
MSX2_PICKER_ROWS = 16
MSX2_PICKER_SQUARE_SIZE = 15
CURRENT_PALETTE_SLOT_SIZE = 30

# --- Project Open Modes ---
OPEN_MODE_INTERACTIVE = "interactive"   # User clicks "File -> Open..."
OPEN_MODE_RECENT = "recent"             # User clicks a recent file
OPEN_MODE_STARTUP = "startup"           # App automatically loads last project

# --- MSX2 Default Palette (Indices & Colors) ---
MSX2_RGB7_VALUES = [
    (0, 0, 0),
    (0, 0, 0),
    (1, 6, 1),
    (3, 7, 3),
    (1, 1, 7),
    (2, 3, 7),
    (5, 1, 1),
    (2, 6, 7),
    (7, 1, 1),
    (7, 3, 3),
    (6, 6, 1),
    (6, 6, 4),
    (1, 4, 1),
    (6, 2, 5),
    (5, 5, 5),
    (7, 7, 7),
]
BLACK_IDX = 0
WHITE_IDX = 15

# --- Placeholder Colors ---
INVALID_TILE_COLOR = "#FF00FF"
INVALID_SUPERTILE_COLOR = "#00FFFF"

# --- Grid & Overlay Constants ---
GRID_COLOR_CYCLE = [
    "#FFFFFF",
    "#000000",
    "#FF00FF",
    "#00FFFF",
    "#FFFF00",
]  # White, Black, Magenta, Cyan, Yellow
GRID_DASH_PATTERN = (5, 3)  # 5 pixels on, 3 pixels off
WIN_VIEW_HANDLE_SIZE = 8  # Pixel size of resize handles
WIN_VIEW_HALF_ROW_COLOR = "#80808080"  # Semi-transparent grey for overscan area (adjust alpha if needed, format depends on tk version)


logging.basicConfig(
    level=logging.INFO,  # Set the minimum level of messages to handle
    format='%(asctime)s [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# --- MSX2 Color Generation ---
msx2_512_colors_hex = []
msx2_512_colors_rgb7 = []
for r in range(8):
    for g in range(8):
        for b in range(8):
            r_255 = min(255, r * 36)
            g_255 = min(255, g * 36)
            b_255 = min(255, b * 36)
            hex_color = f"#{r_255:02x}{g_255:02x}{b_255:02x}"
            msx2_512_colors_hex.append(hex_color)
            msx2_512_colors_rgb7.append((r, g, b))

# --- Data Structures ---

# Initialize tileset with one "empty" tile. The list will grow dynamically.
tileset_colors = [
    [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]
]
tileset_patterns = [
    [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
]

# Initialize supertileset with one "empty" supertile. The list will grow dynamically.
supertiles_data = [
    [[0 for _ in range(DEFAULT_SUPERTILE_GRID_WIDTH)] for _ in range(DEFAULT_SUPERTILE_GRID_HEIGHT)]
]

current_tile_index = 0
selected_color_index = WHITE_IDX
last_drawn_pixel = None
current_supertile_index = 0
selected_tile_for_supertile = 0
map_width = DEFAULT_MAP_WIDTH  # In supertiles
map_height = DEFAULT_MAP_HEIGHT  # In supertiles
map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
selected_supertile_for_map = 0
last_painted_map_cell = None

# --- Utility Functions ---
def get_contrast_color(hex_color):
    try:
        hex_color = hex_color.lstrip("#")
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)
        luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
        return "#000000" if luminance > 0.5 else "#FFFFFF"
    except:
        return "#000000"

def _debug(message):
    logger.debug(f"{str(message)}")

def _info(message):
    logger.info(f"{str(message)}")

def _warning(message):
    logger.warning(f"{str(message)}")

def _error(message):
    logger.error(f"{str(message)}")
    stack_list = traceback.format_stack()
    stack_str = "".join(stack_list)
    logger.debug(stack_str)

def _critical(message):
    logger.critical(f"{str(message)}")

# --- Undo/Redo Framework Classes ------------------------------------------------------------------------------
class ICommand:
    """An interface for an undoable action."""
    def __init__(self, description=""):
        self.description = description # For potential UI hints, e.g., "Undo Paint Pixel"

    def execute(self):
        # Applies the command's action.
        raise NotImplementedError

    def undo(self):
        # Reverts the command's action.
        raise NotImplementedError

class UndoManager:
    """Manages the undo and redo stacks for the application."""
    def __init__(self, app_ref):
        self.app_ref = app_ref
        self.undo_stack = []
        self.redo_stack = []

    def register(self, command):
        """Registers a command that has already been executed."""
        _debug("[UndoManager.register] Registering command.")
        self.undo_stack.append(command)
        self.redo_stack.clear()
        self.app_ref._update_edit_menu_state()

    def execute(self, command):
        """Executes a new command and registers it for undo."""
        _debug(f"[UndoManager.execute] Executing command: {command.description}")
        command.execute()
        self.register(command)
        self.app_ref.update_all_displays(changed_level="all")

    def undo(self):
        if not self.undo_stack:
            _debug("[UndoManager.undo] Stack empty.")
            return
        command = self.undo_stack.pop()
        _debug(f"[UndoManager.undo] Undoing command: {command.description}")
        command.undo()
        self.redo_stack.append(command)
        _debug("[UndoManager.undo] Redrawing screen.")
        self.app_ref.update_all_displays(changed_level="all")
        self.app_ref._update_edit_menu_state()

    def redo(self):
        if not self.redo_stack:
            _debug("[UndoManager.redo] Stack empty.")
            return
        command = self.redo_stack.pop()
        _debug(f"[UndoManager.redo] Redoing command: {command.description}")
        command.execute()
        self.undo_stack.append(command)
        _debug("[UndoManager.redo] Redrawing screen.")
        self.app_ref.update_all_displays(changed_level="all")
        self.app_ref._update_edit_menu_state()
        
    def clear(self):
        self.undo_stack.clear()
        self.redo_stack.clear()
        self.app_ref._update_edit_menu_state()

    def can_undo(self):
        return bool(self.undo_stack)

    def can_redo(self):
        return bool(self.redo_stack)

class PaintPixelCommand(ICommand):
    """Command for a single pixel paint action in the Tile Editor."""
    def __init__(self, app_ref, tile_index, r, c, new_value):
        super().__init__("Paint Pixel")
        self.app_ref = app_ref
        self.tile_index = tile_index
        self.r, self.c = r, c
        self.new_value = new_value
        self.old_value = tileset_patterns[tile_index][r][c]
        _debug(f"[PaintPixelCommand CREATED] Tile {self.tile_index} ({self.r},{self.c}). Old->New: {self.old_value}->{self.new_value}")

    def _apply_and_update(self, value):
        _debug(f"  [_apply_and_update] Setting pixel ({self.r},{self.c}) to {value}")
        tileset_patterns[self.tile_index][self.r][self.c] = value
        self.app_ref._mark_project_modified()
        self.app_ref.invalidate_tile_cache(self.tile_index)
        self.app_ref._request_color_usage_refresh()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        _debug(f"  -> EXECUTE PaintPixelCommand for Tile {self.tile_index} ({self.r},{self.c})")
        self._apply_and_update(self.new_value)

    def undo(self):
        _debug(f"  <- UNDO PaintPixelCommand for Tile {self.tile_index} ({self.r},{self.c})")
        self._apply_and_update(self.old_value)

class SetRowColorCommand(ICommand):
    """Command to set the foreground or background color of a tile row."""
    def __init__(self, app_ref, tile_index, row, fg_or_bg, new_color_index):
        super().__init__("Set Row Color")
        self.app_ref = app_ref
        self.tile_index = tile_index
        self.row = row
        self.fg_or_bg = fg_or_bg
        self.new_color_index = new_color_index
        self.old_colors = tileset_colors[tile_index][row]

    def _apply_and_update(self, colors_tuple):
        tileset_colors[self.tile_index][self.row] = colors_tuple
        self.app_ref._mark_project_modified()
        self.app_ref.invalidate_tile_cache(self.tile_index)
        self.app_ref._request_color_usage_refresh()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        current_fg, current_bg = self.old_colors
        new_colors_tuple = (self.new_color_index, current_bg) if self.fg_or_bg == "fg" else (current_fg, self.new_color_index)
        self._apply_and_update(new_colors_tuple)

    def undo(self):
        self._apply_and_update(self.old_colors)

class PlaceTileInSupertileCommand(ICommand):
    """Command to place a single tile in a supertile definition."""
    def __init__(self, app_ref, st_index, r, c, new_tile_index):
        super().__init__("Place Tile")
        self.app_ref = app_ref
        self.st_index = st_index
        self.r, self.c = r, c
        self.new_tile_index = new_tile_index
        self.old_tile_index = supertiles_data[st_index][r][c]
        _debug(f"[PlaceTileInSupertileCommand CREATED] ST {self.st_index} ({self.r},{self.c}). Old->New: {self.old_tile_index}->{self.new_tile_index}")


    def _apply_and_update(self, value):
        _debug(f"  [_apply_and_update] Setting ST {self.st_index} pixel ({self.r},{self.c}) to {value}")
        supertiles_data[self.st_index][self.r][self.c] = value
        self.app_ref._mark_project_modified()
        self.app_ref.invalidate_supertile_cache(self.st_index)
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        _debug(f"  -> EXECUTE PlaceTileInSupertileCommand for ST {self.st_index} ({self.r},{self.c})")
        self._apply_and_update(self.new_tile_index)

    def undo(self):
        _debug(f"  <- UNDO PlaceTileInSupertileCommand for ST {self.st_index} ({self.r},{self.c})")
        self._apply_and_update(self.old_tile_index)

class PaintMapCellCommand(ICommand):
    """Command to paint a single supertile onto the map."""
    def __init__(self, app_ref, r, c, new_st_index):
        super().__init__("Paint Map")
        self.app_ref = app_ref
        self.r, self.c = r, c
        self.new_st_index = new_st_index
        self.old_st_index = map_data[r][c]

    def _apply_and_update(self, value):
        map_data[self.r][self.c] = value
        self.app_ref._mark_project_modified()
        self.app_ref.invalidate_minimap_background_cache()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        self._apply_and_update(self.new_st_index)

    def undo(self):
        self._apply_and_update(self.old_st_index)

class CompositeCommand(ICommand):
    """A command that groups multiple commands into a single undoable action."""
    def __init__(self, description, commands_list, app_ref=None, post_hooks=None):
        super().__init__(description)
        self.commands = commands_list
        self.app_ref = app_ref
        # Always take a copy, and expect the argument to be a list.
        self.post_hooks = list(post_hooks) if post_hooks else []

    def execute(self):
        for cmd in self.commands:
            cmd.execute()
        if self.app_ref:
            for func in self.post_hooks:
                func()

    def undo(self):
        for cmd in reversed(self.commands):
            cmd.undo()
        if self.app_ref:
            # For undo, we execute the same hooks.
            for func in self.post_hooks:
                func()

class ClearTileCommand(ICommand):
    """Command to clear a single tile's pattern and color data."""
    def __init__(self, app_ref, tile_index):
        super().__init__("Clear Tile")
        self.app_ref = app_ref
        self.tile_index = tile_index
        self.old_pattern = copy.deepcopy(tileset_patterns[self.tile_index])
        self.old_colors = copy.deepcopy(tileset_colors[self.tile_index])

    def execute(self):
        tileset_patterns[self.tile_index] = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        tileset_colors[self.tile_index] = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]
        self._apply_side_effects()

    def undo(self):
        tileset_patterns[self.tile_index] = copy.deepcopy(self.old_pattern)
        tileset_colors[self.tile_index] = copy.deepcopy(self.old_colors)
        self._apply_side_effects()
    
    def _apply_side_effects(self):
        self.app_ref._mark_project_modified()
        self.app_ref.invalidate_tile_cache(self.tile_index)
        self.app_ref._request_color_usage_refresh()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

class ClearSupertileCommand(ICommand):
    """Command to clear a single supertile's definition."""
    def __init__(self, app_ref, supertile_index):
        super().__init__("Clear Supertile")
        self.app_ref = app_ref
        self.supertile_index = supertile_index
        self.old_definition = copy.deepcopy(supertiles_data[self.supertile_index])

    def execute(self):
        supertiles_data[self.supertile_index] = [
            [0 for _c in range(self.app_ref.supertile_grid_width)] for _r in range(self.app_ref.supertile_grid_height)
        ]
        self._apply_side_effects()

    def undo(self):
        supertiles_data[self.supertile_index] = copy.deepcopy(self.old_definition)
        self._apply_side_effects()
        
    def _apply_side_effects(self):
        self.app_ref._mark_project_modified()
        self.app_ref.invalidate_supertile_cache(self.supertile_index)
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

class ClearMapCommand(ICommand):
    """Command to clear the entire map."""
    def __init__(self, app_ref):
        super().__init__("Clear Map")
        self.app_ref = app_ref
        self.old_map_data = copy.deepcopy(map_data)

    def execute(self):
        global map_data, map_width, map_height
        map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
        self._apply_side_effects()

    def undo(self):
        global map_data
        map_data = copy.deepcopy(self.old_map_data)
        self._apply_side_effects()

    def _apply_side_effects(self):
        self.app_ref._mark_project_modified()
        self.app_ref.invalidate_minimap_background_cache()
        self.app_ref._request_supertile_usage_refresh()

class TransformCommand(ICommand):
    """A general command for any transformation on a single data item."""
    def __init__(self, description, app_ref, data_list, index, invalidate_func):
        super().__init__(description)
        self.app_ref = app_ref
        self.data_list = data_list
        self.index = index
        self.invalidate_func = invalidate_func
        self.old_data = copy.deepcopy(self.data_list[self.index])
        self.new_data = None

    def execute(self):
        if self.new_data is not None:
            self.data_list[self.index] = copy.deepcopy(self.new_data)
        self._apply_side_effects()

    def undo(self):
        self.data_list[self.index] = copy.deepcopy(self.old_data)
        self._apply_side_effects()
    
    def capture_new_state(self):
        self.new_data = copy.deepcopy(self.data_list[self.index])

    def _apply_side_effects(self):
        self.app_ref._mark_project_modified()
        self.invalidate_func(self.index)
        self.app_ref._request_color_usage_refresh()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

class SetPaletteColorCommand(ICommand):
    """Command to change a single color in the active palette."""
    def __init__(self, app_ref, slot_index, new_hex_color):
        super().__init__("Set Palette Color")
        self.app_ref = app_ref
        self.slot_index = slot_index
        self.new_hex = new_hex_color
        self.old_hex = self.app_ref.active_msx_palette[slot_index]
    
    def _apply_and_update(self, hex_color):
        self.app_ref.active_msx_palette[self.slot_index] = hex_color
        self.app_ref._mark_project_modified()
        self.app_ref.clear_all_caches()
        self.app_ref.invalidate_minimap_background_cache()
        self.app_ref._request_color_usage_refresh()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        self._apply_and_update(self.new_hex)
    
    def undo(self):
        self._apply_and_update(self.old_hex)

class SetDataCommand(ICommand):
    """Generic command to replace a complete data structure."""
    def __init__(self, description, app_ref, data_setter, new_data, old_data):
        super().__init__(description)
        self.app_ref = app_ref
        self.setter = data_setter
        self.new_data = new_data
        self.old_data = old_data

    def execute(self):
        self.setter(copy.deepcopy(self.new_data))
        self.app_ref._mark_project_modified()
        
    def undo(self):
        self.setter(copy.deepcopy(self.old_data))
        self.app_ref._mark_project_modified()

class ModifyListCommand(ICommand):
    """Command to handle insertion or deletion from lists, adhering to strict state isolation."""
    def __init__(self, description, list_obj, index, value=None, is_insert=True):
        super().__init__(description)
        self.list_obj = list_obj
        self.index = index
        self.is_insert = is_insert

        # Adhere to the "Immutable Command State" standard.
        # All necessary state is captured via deepcopy at creation time.
        if self.is_insert:
            # For an insert, the value to be inserted is the state.
            self.value = copy.deepcopy(value)
        else:
            # For a delete, the value being deleted is the state.
            # Capture it BEFORE the delete happens.
            self.value = copy.deepcopy(list_obj[index])

    def execute(self):
        if self.is_insert:
            # Adhere to the "State Isolation" standard.
            # Insert a DEEP COPY of the internal value, not a reference to it.
            self.list_obj.insert(self.index, copy.deepcopy(self.value))
        else:
            # The action is simple; the state was already captured.
            self.list_obj.pop(self.index)

    def undo(self):
        if self.is_insert:
            self.list_obj.pop(self.index)
        else:
            # Adhere to the "State Isolation" standard.
            # Insert a DEEP COPY of the internal value, not a reference to it.
            self.list_obj.insert(self.index, copy.deepcopy(self.value))

class ReplaceRefsCommand(ICommand):
    """Command to replace all references of one item with another."""
    def __init__(self, description, app_ref, item_type, source_index, target_index):
        super().__init__(description)
        self.app_ref = app_ref
        self.item_type = item_type
        self.source_index = source_index
        self.target_index = target_index
        
        if self.item_type == "palette_color":
            self.old_data = copy.deepcopy(tileset_colors)
        elif self.item_type == "tile":
            self.old_data = copy.deepcopy(supertiles_data)
        elif self.item_type == "supertile":
            self.old_data = copy.deepcopy(map_data)

    def execute(self):
        self.app_ref._mark_project_modified()
        if self.item_type == "palette_color":
            for tile_color_def in tileset_colors:
                for i, (fg, bg) in enumerate(tile_color_def):
                    new_fg, new_bg = fg, bg
                    if fg == self.target_index: new_fg = self.source_index
                    if bg == self.target_index: new_bg = self.source_index
                    if (new_fg, new_bg) != (fg, bg):
                        tile_color_def[i] = (new_fg, new_bg)
            self.app_ref._apply_palette_change_updates()
        elif self.item_type == "tile":
            for st_def in supertiles_data:
                for r in range(len(st_def)):
                    for c in range(len(st_def[r])):
                        if st_def[r][c] == self.target_index:
                            st_def[r][c] = self.source_index
            self.app_ref.clear_all_caches()
            self.app_ref.invalidate_minimap_background_cache()
            self.app_ref._request_tile_usage_refresh()
            self.app_ref._request_supertile_usage_refresh()
        elif self.item_type == "supertile":
            for r in range(len(map_data)):
                for c in range(len(map_data[r])):
                    if map_data[r][c] == self.target_index:
                        map_data[r][c] = self.source_index
            self.app_ref.clear_all_caches()
            self.app_ref.invalidate_minimap_background_cache()
            self.app_ref._request_supertile_usage_refresh()

    def undo(self):
        self.app_ref._mark_project_modified()
        if self.item_type == "palette_color":
            global tileset_colors
            tileset_colors = copy.deepcopy(self.old_data)
            self.app_ref._apply_palette_change_updates()
        elif self.item_type == "tile":
            global supertiles_data
            supertiles_data = copy.deepcopy(self.old_data)
            self.app_ref.clear_all_caches()
            self.app_ref.invalidate_minimap_background_cache()
            self.app_ref._request_tile_usage_refresh()
            self.app_ref._request_supertile_usage_refresh()
        elif self.item_type == "supertile":
            global map_data
            map_data = copy.deepcopy(self.old_data)
            self.app_ref.clear_all_caches()
            self.app_ref.invalidate_minimap_background_cache()
            self.app_ref._request_supertile_usage_refresh()

class UpdateSupertileRefsForTileCommand(ICommand):
    """ An optimized command to update supertile definitions when a tile is
    inserted or deleted. It only operates on the active slice of supertiles. """
    def __init__(self, description, app_ref, tile_index, is_insert):
        super().__init__(description)
        self.app_ref = app_ref
        self.tile_index = tile_index
        self.is_insert = is_insert
        # No need to store old_data, as the operations are perfectly reversible.

    def _process_refs(self, is_forward):
        # is_forward = True for execute, False for undo
        active_slice = supertiles_data[:len(supertiles_data)]
        
        if (self.is_insert and is_forward) or (not self.is_insert and not is_forward):
            # This is an INSERT action
            for st_def in active_slice:
                for r in range(len(st_def)):
                    for c in range(len(st_def[r])):
                        if st_def[r][c] >= self.tile_index:
                            st_def[r][c] += 1
        else:
            # This is a DELETE action
            for st_def in active_slice:
                for r in range(len(st_def)):
                    for c in range(len(st_def[r])):
                        if st_def[r][c] == self.tile_index:
                            st_def[r][c] = 0
                        elif st_def[r][c] > self.tile_index:
                            st_def[r][c] -= 1

    def execute(self):
        self._process_refs(is_forward=True)

    def undo(self):
        self._process_refs(is_forward=False)

class ReorderListCommand(ICommand):
    """Command to handle reordering or swapping items in a list."""
    def __init__(self, description, list_obj, source_index, target_index, is_swap=False):
        super().__init__(description)
        self.list_obj = list_obj
        self.source_index = source_index
        self.target_index = target_index
        self.is_swap = is_swap
        self.moved_item = None # To store item during move

    def execute(self):
        if self.is_swap:
            # Swap the items at the two indices
            self.list_obj[self.source_index], self.list_obj[self.target_index] = \
                self.list_obj[self.target_index], self.list_obj[self.source_index]
        else: # It's a move (reposition)
            # Remove item from its original position and store it
            self.moved_item = self.list_obj.pop(self.source_index)
            # Insert the item at the new target position
            self.list_obj.insert(self.target_index, self.moved_item)

    def undo(self):
        if self.is_swap:
            # A swap is its own inverse
            self.list_obj[self.source_index], self.list_obj[self.target_index] = \
                self.list_obj[self.target_index], self.list_obj[self.source_index]
        else: # Undo a move
            # Remove the item from its new position
            item_to_move_back = self.list_obj.pop(self.target_index)
            # Re-insert it at its original source position
            self.list_obj.insert(self.source_index, item_to_move_back)

class UpdateSupertileRefsForTileReorderCommand(ICommand):
    """An optimized command to update supertile definitions when a tile is moved."""
    def __init__(self, description, app_ref, source_index, actual_insert_idx):
        super().__init__(description)
        self.app_ref = app_ref
        self.source_index = source_index
        self.actual_insert_idx = actual_insert_idx

    def _process_refs(self, is_undo):
        active_slice = supertiles_data[:len(supertiles_data)]
        source, target = (self.actual_insert_idx, self.source_index) if is_undo else (self.source_index, self.actual_insert_idx)

        for st_def in active_slice:
            for r in range(len(st_def)):
                for c in range(len(st_def[r])):
                    val = st_def[r][c]
                    if val == source: st_def[r][c] = target
                    elif source < target: # Moved down
                        if source < val <= target: st_def[r][c] -= 1
                    else: # Moved up
                        if target <= val < source: st_def[r][c] += 1
        self._apply_side_effects()

    def execute(self):
        self._process_refs(is_undo=False)

    def undo(self):
        self._process_refs(is_undo=True)

    def _apply_side_effects(self):
        self.app_ref.clear_all_caches()
        self.app_ref.invalidate_minimap_background_cache()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

class UpdateSupertileRefsForTileSwapCommand(ICommand):
    """An optimized command to update supertile definitions when two tiles are swapped."""
    def __init__(self, description, app_ref, index_a, index_b):
        super().__init__(description)
        self.app_ref = app_ref
        self.index_a = index_a
        self.index_b = index_b

    def _swap_logic(self):
        active_slice = supertiles_data[:len(supertiles_data)]
        for st_def in active_slice:
            for r in range(len(st_def)):
                for c in range(len(st_def[r])):
                    if st_def[r][c] == self.index_a: st_def[r][c] = self.index_b
                    elif st_def[r][c] == self.index_b: st_def[r][c] = self.index_a
        
        self.app_ref.clear_all_caches()
        self.app_ref.invalidate_minimap_background_cache()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        self._swap_logic()

    def undo(self):
        self._swap_logic() # Swap is its own inverse

class UpdateMapRefsForSupertileSwapCommand(ICommand):
    """An optimized command to update map data when two supertiles are swapped."""
    def __init__(self, description, app_ref, index_a, index_b):
        super().__init__(description)
        self.app_ref = app_ref
        self.index_a = index_a
        self.index_b = index_b

    def _swap_logic(self):
        for r in range(map_height):
            for c in range(map_width):
                if map_data[r][c] == self.index_a:
                    map_data[r][c] = self.index_b
                elif map_data[r][c] == self.index_b:
                    map_data[r][c] = self.index_a
        
        self.app_ref.clear_all_caches()
        self.app_ref.invalidate_minimap_background_cache()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        self._swap_logic()

    def undo(self):
        self._swap_logic() # Swap is its own inverse

class SetTilesetLimitCommand(ICommand):
    """Command to handle changing the tileset limit, adhering to strict state isolation."""
    def __init__(self, app_ref, new_limit):
        super().__init__("Set Tileset Limit")
        self.app_ref = app_ref
        
        # --- Capture "Before" State ---
        self.old_limit = self.app_ref.project_tile_limit
        self.old_patterns = copy.deepcopy(tileset_patterns)
        self.old_colors = copy.deepcopy(tileset_colors)
        self.old_supertiles_data = copy.deepcopy(supertiles_data)
        self.old_current_tile_index = current_tile_index
        self.old_selected_tile_for_supertile = selected_tile_for_supertile

        # --- Calculate and Capture Definitive "After" State ---
        self.new_limit = new_limit
        
        # Start with a copy of the "before" state to calculate the "after" state
        after_patterns = copy.deepcopy(self.old_patterns)
        after_colors = copy.deepcopy(self.old_colors)
        after_supertiles_data = copy.deepcopy(self.old_supertiles_data)
        current_size = len(after_patterns)

        if self.new_limit < current_size:
            # Truncation logic applied to our temporary "after" state copies
            for st_def in after_supertiles_data:
                for r in range(self.app_ref.supertile_grid_height):
                    for c in range(self.app_ref.supertile_grid_width):
                        if st_def[r][c] >= self.new_limit:
                            st_def[r][c] = 0
            
            del after_patterns[self.new_limit:]
            del after_colors[self.new_limit:]

        # Store the calculated "after" state in the command
        self.after_patterns = after_patterns
        self.after_colors = after_colors
        self.after_supertiles_data = after_supertiles_data
        self.after_current_tile_index = min(self.old_current_tile_index, len(self.after_patterns) - 1)
        self.after_selected_tile_for_supertile = min(self.old_selected_tile_for_supertile, len(self.after_patterns) - 1)

    def _apply_and_update(self, limit, patterns, colors, st_data, cti, sts):
        """Helper method to apply a given state by modifying lists in-place."""
        global tileset_patterns, tileset_colors, supertiles_data
        global current_tile_index, selected_tile_for_supertile

        self.app_ref.project_tile_limit = limit
        
        # Adhere to the State Isolation standard: apply a DEEP COPY of the
        # backup state to the live lists. This breaks the reference chain
        # and prevents future commands from contaminating this command's state.
        tileset_patterns.clear()
        tileset_patterns.extend(copy.deepcopy(patterns))
        
        tileset_colors.clear()
        tileset_colors.extend(copy.deepcopy(colors))
        
        supertiles_data.clear()
        supertiles_data.extend(copy.deepcopy(st_data))

        current_tile_index = cti
        selected_tile_for_supertile = sts

        # --- Post-change UI updates ---
        self.app_ref.tile_limit_var.set(limit)
        self.app_ref._mark_project_modified()
        self.app_ref.clear_all_caches()
        self.app_ref.invalidate_minimap_background_cache()
        self.app_ref.update_all_displays(changed_level="all")
        self.app_ref._update_editor_button_states()
        self.app_ref._request_color_usage_refresh()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        _debug("Executing SetTilesetLimitCommand: Applying pre-calculated 'after' state.")
        self._apply_and_update(self.new_limit, self.after_patterns, self.after_colors, self.after_supertiles_data, self.after_current_tile_index, self.after_selected_tile_for_supertile)

    def undo(self):
        _debug("Undoing SetTilesetLimitCommand: Applying pre-calculated 'before' state.")
        self._apply_and_update(self.old_limit, self.old_patterns, self.old_colors, self.old_supertiles_data, self.old_current_tile_index, self.old_selected_tile_for_supertile)

class SetSupertileLimitCommand(ICommand):
    """Command to handle changing the supertile limit."""
    def __init__(self, app_ref, new_limit):
        super().__init__("Set Supertile Limit")
        self.app_ref = app_ref

        # --- Capture "Before" State ---
        self.old_limit = self.app_ref.project_supertile_limit
        self.old_supertiles_data = copy.deepcopy(supertiles_data)
        self.old_map_data = copy.deepcopy(map_data)
        self.old_current_supertile_index = current_supertile_index
        self.old_selected_supertile_for_map = selected_supertile_for_map

        # --- Calculate and Capture Definitive "After" State ---
        self.new_limit = new_limit
        
        after_supertiles_data = copy.deepcopy(self.old_supertiles_data)
        after_map_data = copy.deepcopy(self.old_map_data)
        current_size = len(after_supertiles_data)

        if self.new_limit < current_size:
            # Truncate supertiles
            del after_supertiles_data[self.new_limit:]
            # Reset references in map
            for r in range(len(after_map_data)):
                for c in range(len(after_map_data[r])):
                    if after_map_data[r][c] >= self.new_limit:
                        after_map_data[r][c] = 0

        # Store the calculated "after" state
        self.after_supertiles_data = after_supertiles_data
        self.after_map_data = after_map_data
        self.after_current_supertile_index = min(self.old_current_supertile_index, len(self.after_supertiles_data) - 1)
        self.after_selected_supertile_for_map = min(self.old_selected_supertile_for_map, len(self.after_supertiles_data) - 1)

    def _apply_and_update(self, limit, st_data, m_data, csi, ssm):
        """Helper method to apply a given state."""
        global supertiles_data, map_data
        global current_supertile_index, selected_supertile_for_map

        _debug(f"[_apply_and_update] Setting app_ref.project_supertile_limit to: {limit}")
        self.app_ref.project_supertile_limit = limit
        
        supertiles_data.clear()
        supertiles_data.extend(copy.deepcopy(st_data))
        
        map_data.clear()
        map_data.extend(copy.deepcopy(m_data))

        current_supertile_index = csi
        selected_supertile_for_map = ssm

        # --- Post-change UI updates ---
        self.app_ref.supertile_limit_var.set(limit)
        self.app_ref._mark_project_modified()
        self.app_ref.clear_all_caches()
        self.app_ref.invalidate_minimap_background_cache()
        self.app_ref.update_all_displays(changed_level="all")
        self.app_ref._update_editor_button_states()
        self.app_ref._request_tile_usage_refresh()
        self.app_ref._request_supertile_usage_refresh()

    def execute(self):
        _debug("Executing SetSupertileLimitCommand.")
        self._apply_and_update(self.new_limit, self.after_supertiles_data, self.after_map_data, self.after_current_supertile_index, self.after_selected_supertile_for_map)

    def undo(self):
        _debug("Undoing SetSupertileLimitCommand.")
        self._apply_and_update(self.old_limit, self.old_supertiles_data, self.old_map_data, self.old_current_supertile_index, self.old_selected_supertile_for_map)
        
# --- Usage Window Classes -----------------------------------------------------------------------------------------------
class ColorUsageWindow(tk.Toplevel):
    def __init__(self, master_app):
        super().__init__(master_app.root)
        self.app_ref = master_app
        self.title("Color Usage")
        self.transient(master_app.root)
        self.resizable(True, True) 

        self._image_references = [] 
        self.current_sort_column_id = "slot_index" 
        self.current_sort_direction_is_asc = True   
        self.refresh_timer_id = None 
        self.style = ttk.Style()

        self.window_class_name = self.__class__.__name__
        saved_config = self.app_ref.get_window_config(self.window_class_name)
        initial_geometry = saved_config.get('geometry')
        initial_sort_col = saved_config.get('sort_column_id', self.current_sort_column_id)
        initial_sort_asc = saved_config.get('sort_asc', self.current_sort_direction_is_asc)
        initial_col_widths = saved_config.get('column_widths', {})
        
        self.current_sort_column_id = initial_sort_col
        self.current_sort_direction_is_asc = initial_sort_asc

        self._is_dragging_col_separator = False 
        self._treeview_refresh_timer_id = None 

        main_frame = ttk.Frame(self, padding="5")
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_rowconfigure(0, weight=1) 
        main_frame.grid_columnconfigure(0, weight=1)

        self.data_column_ids_for_values = ("slot_index_val", "pixel_uses_val", "line_refs_val", "tile_refs_val")
        
        self.tree = ttk.Treeview(
            main_frame,
            columns=self.data_column_ids_for_values,
            show="tree headings", 
            height=16, 
            selectmode="browse"
        )

        # --- Column Configuration with loaded widths or defaults ---
        col0_default_w = 60 # Includes swatch + padding
        self.tree.column("#0", 
                         width=initial_col_widths.get("#0", col0_default_w), 
                         minwidth=30, stretch=tk.YES, anchor="w")
        self.tree.heading("#0", text="Color", command=lambda: self._sort_by_column("#0"))

        col_idx_default_w = 60
        self.tree.column("slot_index_val", 
                         width=initial_col_widths.get("slot_index_val", col_idx_default_w), 
                         minwidth=40, stretch=tk.YES, anchor="center")
        self.tree.heading("slot_index_val", text="Index", command=lambda: self._sort_by_column("slot_index"))

        col_counts_default_w = 80
        self.tree.column("pixel_uses_val", 
                         width=initial_col_widths.get("pixel_uses_val", col_counts_default_w), 
                         minwidth=60, stretch=tk.YES, anchor="center")
        self.tree.heading("pixel_uses_val", text="Pixel Uses", command=lambda: self._sort_by_column("pixel_uses_count"))

        self.tree.column("line_refs_val", 
                         width=initial_col_widths.get("line_refs_val", col_counts_default_w), 
                         minwidth=60, stretch=tk.YES, anchor="center")
        self.tree.heading("line_refs_val", text="Line Refs", command=lambda: self._sort_by_column("line_refs_count"))

        self.tree.column("tile_refs_val", 
                         width=initial_col_widths.get("tile_refs_val", col_counts_default_w), 
                         minwidth=60, stretch=tk.YES, anchor="center")
        self.tree.heading("tile_refs_val", text="Tile Refs", command=lambda: self._sort_by_column("tile_refs_count"))
        
        self.header_details = {
            "#0": {"id": "#0", "data_key": "slot_index"},
            "slot_index": {"id": "slot_index_val", "data_key": "slot_index"},
            "pixel_uses_count": {"id": "pixel_uses_val", "data_key": "pixel_uses_count"},
            "line_refs_count": {"id": "line_refs_val", "data_key": "line_refs_count"},
            "tile_refs_count": {"id": "tile_refs_val", "data_key": "tile_refs_count"}
        }
        self._update_header_sort_indicators()

        v_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=v_scrollbar.set)
        h_scrollbar = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=h_scrollbar.set)

        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew") 

        color_swatch_preview_height = 16 
        self.treeview_style_name = f"ColorUsage_{id(self)}.Treeview"
        target_row_height_style = color_swatch_preview_height + 4 
        
        try:
            self.style.configure(self.treeview_style_name, rowheight=target_row_height_style)
            self.style.map(self.treeview_style_name,
                      background=[('selected', self.style.lookup(self.treeview_style_name, 'background'))],
                      foreground=[('selected', self.style.lookup(self.treeview_style_name, 'foreground'))])
            self.tree.configure(style=self.treeview_style_name)
        except tk.TclError as e_style:
            _debug(f" ColorUsageWindow: TclError configuring style '{self.treeview_style_name}': {e_style}.")
        
        # Use the shared font object from the main application
        try:
            if hasattr(self.app_ref, 'link_font') and self.app_ref.link_font:
                self.tree.tag_configure('has_tile_refs', foreground='blue', font=self.app_ref.link_font)
            else: # Fallback if font object doesn't exist for some reason
                self.tree.tag_configure('has_tile_refs', foreground='blue', underline=True)
        except Exception as e_font:
             _debug(f" ColorUsageWindow: Could not apply special font: {e_font}")
             self.tree.tag_configure('has_tile_refs', foreground='blue')

        self.tree.bind("<<TreeviewSelect>>", self._on_item_selected)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self.tree.bind("<ButtonPress-1>", self._on_tree_button_press) 
        self.bind("<ButtonRelease-1>", self._on_window_button_release, add='+') 
        self.tree.bind("<Configure>", self._on_tree_configure_debounced) 
        self.tree.bind("<Motion>", self._on_tree_motion)

        button_frame_container = ttk.Frame(main_frame) 
        button_frame_container.grid(row=2, column=0, columnspan=2, sticky="ew", pady=(5,0))
        self.refresh_button = None 
        if root.app_debug_mode:
            self.refresh_button = ttk.Button(button_frame_container, text="Refresh (Debug)", command=self.refresh_data)
            self.refresh_button.pack(pady=5)
        
        if initial_geometry:
            try:
                self.geometry(initial_geometry)
            except tk.TclError as e_geom:
                _error(f" ColorUsageWindow: Error applying saved geometry '{initial_geometry}': {e_geom}")
        else: 
            self.update_idletasks()
            header_h_approx = 30
            scrollbar_h_approx = 20
            total_h = (16 * target_row_height_style) + header_h_approx + scrollbar_h_approx + 20
            total_w = col0_default_w + col_idx_default_w + (col_counts_default_w * 3) + 20
            self.geometry(f"{max(300,total_w)}x{max(300,total_h)}")


        self.app_ref.update_window_config(self.window_class_name, is_open=True)
        self.after(10, self.refresh_data_if_ready)

    def _get_current_tree_config(self):
        """Returns current sort state and column widths for saving."""
        widths = {}
        if hasattr(self, 'tree') and self.tree.winfo_exists():
            try:
                widths["#0"] = self.tree.column("#0", "width")
                for col_id in self.data_column_ids_for_values:
                    widths[col_id] = self.tree.column(col_id, "width")
            except tk.TclError:
                _debug(" ColorUsageWindow: TclError getting column widths for save.")
        return {
            "sort_column_id": self.current_sort_column_id,
            "sort_asc": self.current_sort_direction_is_asc,
            "column_widths": widths
        }

    def refresh_data_if_ready(self):
        if self.winfo_exists() and self.winfo_ismapped():
            self.refresh_data()
        else:
            self.after(50, self.refresh_data_if_ready)

    def request_refresh(self, delay_ms=300): 
        if not self.winfo_exists(): 
            return
        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
        self.refresh_timer_id = self.after(delay_ms, self._perform_debounced_refresh)

    def _perform_debounced_refresh(self): 
        self.refresh_timer_id = None 
        if self.winfo_exists() and self.winfo_ismapped(): 
            self.refresh_data()

    def _sort_by_column(self, column_clicked_key):
        data_sort_key = self.header_details.get(column_clicked_key, {}).get("data_key")
        if not data_sort_key:
            _debug(f" ColorUsageWindow: Invalid column key '{column_clicked_key}' for sorting.")
            return

        if self.current_sort_column_id == data_sort_key:
            # If clicking the same column, just reverse the direction
            self.current_sort_direction_is_asc = not self.current_sort_direction_is_asc
        else:
            # If clicking a new column, set the initial direction based on column type
            self.current_sort_column_id = data_sort_key
            # Index column defaults to ascending, count columns default to descending
            if "count" in data_sort_key:
                self.current_sort_direction_is_asc = False # Descending for counts
            else:
                self.current_sort_direction_is_asc = True # Ascending for index
        
        self._update_header_sort_indicators()
        self.refresh_data()

    def _update_header_sort_indicators(self):
        if not hasattr(self, 'tree') or not self.tree.winfo_exists(): return
        for key, details in self.header_details.items():
            col_id_for_tree = details["id"] 
            data_key_for_sort = details["data_key"]
            
            current_heading_options = {}
            try:
                current_heading_options = self.tree.heading(col_id_for_tree)
            except tk.TclError: continue

            current_text = current_heading_options.get("text", "")
            text_to_set = current_text.replace(UP, "").replace(DOWN, "")

            if data_key_for_sort == self.current_sort_column_id:
                text_to_set += UP if self.current_sort_direction_is_asc else DOWN
            
            try:
                self.tree.heading(col_id_for_tree, text=text_to_set)
            except tk.TclError: pass

    def refresh_data(self): 
        _debug(f" ColorUsageWindow: refresh_data() called. Sort by: {self.current_sort_column_id}, Asc: {self.current_sort_direction_is_asc}")
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            _debug(" ColorUsageWindow: Treeview not ready for refresh_data.")
            return
        
        current_selection_iid = None
        if self.tree.selection():
            current_selection_iid = self.tree.selection()[0]

        for i in self.tree.get_children():
            self.tree.delete(i)
        self._image_references.clear()
        
        usage_data = [] 
        if hasattr(self.app_ref, '_calculate_color_usage_data'):
            try: usage_data = self.app_ref._calculate_color_usage_data() 
            except Exception as e:
                _error(f" ColorUsageWindow: Error calling _calculate_color_usage_data: {e}")
                for i in range(16): 
                     usage_data.append({'slot_index': i, 'current_color_hex': self.app_ref.active_msx_palette[i] if i < len(self.app_ref.active_msx_palette) else "#FF00FF", 'pixel_uses_count': 0, 'line_refs_count': 0, 'tile_refs_count': 0})
        else: 
            _debug(" ColorUsageWindow: _calculate_color_usage_data not found for refresh.")
            for i in range(16): 
                usage_data.append({'slot_index': i, 'current_color_hex': self.app_ref.active_msx_palette[i] if i < len(self.app_ref.active_msx_palette) else "#FF00FF", 'pixel_uses_count': 0, 'line_refs_count': 0, 'tile_refs_count': 0})

        valid_sort_key = self.current_sort_column_id
        if usage_data and self.current_sort_column_id not in usage_data[0]: 
            _debug(f" ColorUsageWindow: Invalid sort column '{self.current_sort_column_id}' in refresh_data. Defaulting to slot_index.")
            valid_sort_key = 'slot_index' 
            self.current_sort_column_id = 'slot_index'
            self.current_sort_direction_is_asc = True
            self._update_header_sort_indicators()
        elif not usage_data: _debug(" ColorUsageWindow: usage_data is empty, skipping sort.")
        
        if usage_data: 
            try: usage_data.sort(key=lambda item: item[valid_sort_key], reverse=not self.current_sort_direction_is_asc)
            except (TypeError, KeyError) as e_sort: _error(f" ColorUsageWindow: Error during sorting by '{valid_sort_key}': {e_sort}. Using unsorted.")
        
        preview_image_size = 16 
        for item_data in usage_data: 
            slot_idx = item_data['slot_index']
            hex_color = item_data['current_color_hex']
            photo = None
            try:
                img_w, img_h = max(1, preview_image_size), max(1, preview_image_size)
                photo = tk.PhotoImage(width=img_w, height=img_h)
                hex_color_to_put = hex_color
                if not (isinstance(hex_color, str) and hex_color.startswith('#') and (len(hex_color) == 7 or len(hex_color) == 9)):
                    hex_color_to_put = "#FF00FF" 
                photo.put(hex_color_to_put, to=(0, 0, img_w, img_h))
                self._image_references.append(photo) 
            except tk.TclError as e_photo: 
                _debug(f" ColorUsageWindow: TclError creating/putting color swatch for slot {slot_idx} color '{hex_color}': {e_photo}")
            
            tags_for_this_row = ('color_row',)
            if item_data.get('tile_refs_count', 0) > 0:
                tags_for_this_row += ('has_tile_refs',)

            item_iid = f"slot_{slot_idx}"
            self.tree.insert("", "end", 
                             iid=item_iid, 
                             image=photo if photo else '', 
                             text="", 
                             values=(f"{slot_idx}", 
                                     item_data['pixel_uses_count'], 
                                     item_data['line_refs_count'], 
                                     item_data['tile_refs_count']),
                                     tags=tags_for_this_row
                            )
        try: 
            row_bg = self.style.lookup(self.treeview_style_name, 'background')
            self.tree.tag_configure('color_row', background=row_bg)
        except tk.TclError: pass

        if current_selection_iid and self.tree.exists(current_selection_iid):
            self.tree.selection_set(current_selection_iid)
            self.tree.focus(current_selection_iid)


    def _on_item_selected(self, event):
        if not self.tree.winfo_exists(): return
        selected_items = self.tree.selection() 
        if not selected_items: return
        item_id_str = selected_items[0]
        try:
            if item_id_str.startswith("slot_"): slot_index = int(item_id_str.split("_")[1])
            else: _debug(f" ColorUsageWindow: Could not parse slot_index from iid '{item_id_str}'."); return
        except (ValueError, IndexError) as e: _error(f" ColorUsageWindow: Error parsing slot_index from iid '{item_id_str}': {e}"); return
        
        if 0 <= slot_index <= 15: 
            _debug(f" ColorUsageWindow: Item selected, slot_index: {slot_index}")
            if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'): self.app_ref.synchronize_selection_from_usage_window("color", slot_index)
        else: _debug(f" ColorUsageWindow: Parsed invalid slot_index {slot_index}.")

    def _on_close(self): 
        # If the app is handling the closure, do not update config from here
        if getattr(self.app_ref, 'is_changing_projects', False):
            if self.winfo_exists():
                 self.destroy()
            return

        # Update in-memory config before destroying
        if hasattr(self.app_ref, 'update_window_config') and self.winfo_exists():
            current_geo = ""
            try:
                current_geo = self.winfo_geometry()
            except tk.TclError: # Window might be closing
                 pass 
            self.app_ref.update_window_config(
                self.window_class_name,
                geometry=current_geo,
                tree_config=self._get_current_tree_config(),
                is_open=False
            )

        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
            self.refresh_timer_id = None
        
        if hasattr(self, '_treeview_refresh_timer_id') and self._treeview_refresh_timer_id:
            try: self.after_cancel(self._treeview_refresh_timer_id)
            except tk.TclError: pass
            self._treeview_refresh_timer_id = None
            
        _debug(" ColorUsageWindow closed.")
        if self.app_ref: self.app_ref.color_usage_window = None 
        
        try: 
            if self.winfo_exists(): self.destroy()
        except tk.TclError: pass

    def _on_tree_configure_debounced(self, event=None):
        if not self.winfo_exists(): return
        if event and event.widget != self.tree: return # Ensure event is for the tree itself

        if self._treeview_refresh_timer_id:
            self.after_cancel(self._treeview_refresh_timer_id)
        self._treeview_refresh_timer_id = self.after(150, self._do_refresh_if_tree_valid_from_configure) # Increased delay slightly

    def _do_refresh_if_tree_valid_from_configure(self):
        self._treeview_refresh_timer_id = None
        if self.winfo_exists() and self.winfo_ismapped():
            _debug(" ColorUsageWindow: Tree <Configure> event. No data refresh needed.")
        else:
            _debug(" ColorUsageWindow: Tree <Configure> -> Skipped (window not valid/mapped).")

    def _on_tree_button_press(self, event):
        if not self.winfo_exists(): return
        region = self.tree.identify_region(event.x, event.y)
        
        if region == "separator": 
            self._is_dragging_col_separator = True
            _debug(f" ColorUsageWindow: Drag started on separator.")
        elif region == "cell":
            column_id = self.tree.identify_column(event.x)
            item_iid = self.tree.identify_row(event.y)
            if not item_iid: return # Clicked on empty space

            try:
                slot_index = int(item_iid.split("_")[1])
                if not (0 <= slot_index <= 15): return
                
                item_tags = self.tree.item(item_iid, "tags")

                if 'has_tile_refs' in item_tags:
                    if column_id != "#0":
                        if hasattr(self.app_ref, 'show_tiles_using_color'):
                            _debug(f"--- CLICK HANDLER: Calling show_tiles_using_color for slot {slot_index}")
                            self.app_ref.show_tiles_using_color(slot_index)
                        return "break"

                if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'):
                    self.app_ref.synchronize_selection_from_usage_window("color", slot_index)

            except (ValueError, IndexError) as e:
                _error(f" ColorUsageWindow: Error processing cell click: {e}")
                return
        else:
            self._is_dragging_col_separator = False

    def _on_tree_motion(self, event):
        """Changes the mouse cursor when hovering over different regions of the treeview."""
        if not self.winfo_exists(): return
        
        region = self.tree.identify_region(event.x, event.y)
        new_cursor = "" # Default to standard arrow

        if region == "separator":
            new_cursor = "sb_h_double_arrow"
        
        # If hovering over the image/text area of the first column...
        elif region == "tree": 
            item_iid = self.tree.identify_row(event.y)
            if item_iid: # If we are on a valid row item...
                # ...the color swatch is always clickable.
                new_cursor = "hand2"

        # If hovering over a regular data cell (columns #1 through #4)...
        elif region == "cell":
            item_iid = self.tree.identify_row(event.y)
            if item_iid:
                item_tags = self.tree.item(item_iid, "tags")
                # Make the cursor a hand only if it's a "special" row.
                if 'has_tile_refs' in item_tags:
                    new_cursor = "hand2"

        # Only re-configure the widget if the cursor style needs to change
        if self.tree.cget("cursor") != new_cursor:
            self.tree.config(cursor=new_cursor)

    def _on_window_button_release(self, event):
        if not self.winfo_exists(): return
        if self._is_dragging_col_separator:
            self._is_dragging_col_separator = False
            _debug(" ColorUsageWindow: Column drag ended. Updating config for column widths.")
            # Save new column widths to in-memory config
            if hasattr(self.app_ref, 'update_window_config'):
                self.app_ref.update_window_config(
                    self.window_class_name,
                    tree_config=self._get_current_tree_config() # This gets widths and sort state
                )

class TileUsageWindow(tk.Toplevel):
    def __init__(self, master_app):
        super().__init__(master_app.root)
        self.app_ref = master_app
        self.title("Tile Usage")
        self.transient(master_app.root)
        self.resizable(True, True) 

        self._image_references = [] 
        self.current_sort_column_id = "tile_index" 
        self.current_sort_direction_is_asc = True   
        self.refresh_timer_id = None 
        self.style = ttk.Style()

        self.window_class_name = self.__class__.__name__
        saved_config = self.app_ref.get_window_config(self.window_class_name)
        initial_geometry = saved_config.get('geometry')
        initial_sort_col = saved_config.get('sort_column_id', self.current_sort_column_id)
        initial_sort_asc = saved_config.get('sort_asc', self.current_sort_direction_is_asc)
        initial_col_widths = saved_config.get('column_widths', {})

        self.current_sort_column_id = initial_sort_col
        self.current_sort_direction_is_asc = initial_sort_asc

        self._is_dragging_col_separator = False 
        self._treeview_refresh_timer_id = None

        main_frame = ttk.Frame(self, padding="5")
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_rowconfigure(0, weight=1) 
        main_frame.grid_columnconfigure(0, weight=1)

        self.data_column_ids_for_values = ("tile_index_val", "total_uses_val", "used_by_sts_val")
        
        self.tree = ttk.Treeview(
            main_frame,
            columns=self.data_column_ids_for_values,
            show="tree headings", 
            height=16, # Default height, can be overridden by saved geometry
            selectmode="browse"
        )

        # --- Column #0: Tile Preview (Fixed Width, Not User Resizable) ---
        col0_img_fixed_width = TILE_USAGE_PREVIEW_SIZE + 8 
        self.tree.column("#0", width=col0_img_fixed_width, minwidth=col0_img_fixed_width, stretch=tk.NO, anchor="center")
        self.tree.heading("#0", text="Tile", command=lambda: self._sort_by_column("#0"))

        # --- Data Columns (User Resizable) ---
        col_idx_default_w = 70
        self.tree.column("tile_index_val", 
                         width=initial_col_widths.get("tile_index_val", col_idx_default_w), 
                         minwidth=50, stretch=tk.YES, anchor="center")
        self.tree.heading("tile_index_val", text="Index", command=lambda: self._sort_by_column("tile_index"))

        col_refs_default_w = 100
        self.tree.column("total_uses_val", 
                         width=initial_col_widths.get("total_uses_val", col_refs_default_w), 
                         minwidth=70, stretch=tk.YES, anchor="center")
        self.tree.heading("total_uses_val", text="Tile Refs", command=lambda: self._sort_by_column("total_uses_count"))
        
        self.tree.column("used_by_sts_val", 
                         width=initial_col_widths.get("used_by_sts_val", col_refs_default_w), 
                         minwidth=70, stretch=tk.YES, anchor="center")
        self.tree.heading("used_by_sts_val", text="ST Refs", command=lambda: self._sort_by_column("used_by_sts_count"))

        self.header_details = {
            "#0": {"id": "#0", "data_key": "tile_index"}, 
            "tile_index": {"id": "tile_index_val", "data_key": "tile_index"},
            "total_uses_count": {"id": "total_uses_val", "data_key": "total_uses_count"},
            "used_by_sts_count": {"id": "used_by_sts_val", "data_key": "used_by_sts_count"}
        }
        self._update_header_sort_indicators()

        v_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=v_scrollbar.set)
        h_scrollbar = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=h_scrollbar.set)

        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")
        
        self.treeview_style_name = f"TileUsage_{id(self)}.Treeview"
        target_row_height_style = TILE_USAGE_PREVIEW_SIZE + 4 # Image size + slightly more padding
        try:
            self.style.configure(self.treeview_style_name, rowheight=target_row_height_style)
            self.style.map(self.treeview_style_name,
                      background=[('selected', self.style.lookup(self.treeview_style_name, 'background'))],
                      foreground=[('selected', self.style.lookup(self.treeview_style_name, 'foreground'))])
            self.tree.configure(style=self.treeview_style_name)
        except tk.TclError as e_style:
            _debug(f" TileUsageWindow: TclError configuring style '{self.treeview_style_name}': {e_style}.")

        # Use the shared font object from the main application
        try:
            if hasattr(self.app_ref, 'link_font') and self.app_ref.link_font:
                self.tree.tag_configure('has_st_refs', foreground='blue', font=self.app_ref.link_font)
            else: # Fallback
                self.tree.tag_configure('has_st_refs', foreground='blue', underline=True)
        except Exception as e_font:
             _debug(f" TileUsageWindow: Could not apply special font: {e_font}")
             self.tree.tag_configure('has_st_refs', foreground='blue')

        self.tree.bind("<<TreeviewSelect>>", self._on_item_selected)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self.tree.bind("<ButtonPress-1>", self._on_tree_button_press)
        self.bind("<ButtonRelease-1>", self._on_window_button_release, add='+')
        self.tree.bind("<Configure>", self._on_tree_configure_debounced)
        self.tree.bind("<Motion>", self._on_tree_motion)
        
        button_frame_container = ttk.Frame(main_frame)
        button_frame_container.grid(row=2, column=0, columnspan=2, sticky="ew", pady=(5,0))
        self.refresh_button = None
        if root.app_debug_mode:
            self.refresh_button = ttk.Button(button_frame_container, text="Refresh (Debug)", command=self.refresh_data)
            self.refresh_button.pack(pady=5)
        
        if initial_geometry:
            try:
                self.geometry(initial_geometry)
            except tk.TclError as e_geom:
                _error(f" TileUsageWindow: Error applying saved geometry '{initial_geometry}': {e_geom}")
        else: # Default size if no geometry saved
            self.update_idletasks()
            default_h = (16 * target_row_height_style) + 60 # Approx header, scrollbar, padding
            default_w = col0_img_fixed_width + col_idx_default_w + (col_refs_default_w * 2) + 20
            self.geometry(f"{max(350, default_w)}x{max(300, default_h)}")

        self.app_ref.update_window_config(self.window_class_name, is_open=True)
        self.after(10, self.refresh_data_if_ready)

    def _get_current_tree_config(self):
        """Returns current sort state and column widths for saving."""
        widths = {}
        if hasattr(self, 'tree') and self.tree.winfo_exists():
            try:
                # Column #0 width is fixed, but we can save its configured fixed width
                widths["#0"] = self.tree.column("#0", "width") 
                for col_id in self.data_column_ids_for_values:
                    widths[col_id] = self.tree.column(col_id, "width")
            except tk.TclError:
                _debug(" TileUsageWindow: TclError getting column widths for save.")
        return {
            "sort_column_id": self.current_sort_column_id,
            "sort_asc": self.current_sort_direction_is_asc,
            "column_widths": widths
        }

    def refresh_data_if_ready(self):
        if self.winfo_exists() and self.winfo_ismapped():
            self.refresh_data()
        else:
            self.after(50, self.refresh_data_if_ready)

    def request_refresh(self, delay_ms=300): 
        if not self.winfo_exists(): 
            return
        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
        self.refresh_timer_id = self.after(delay_ms, self._perform_debounced_refresh)

    def _perform_debounced_refresh(self): 
        self.refresh_timer_id = None 
        if self.winfo_exists() and self.winfo_ismapped(): 
            self.refresh_data()

    def _sort_by_column(self, column_clicked_key):
        data_sort_key = self.header_details.get(column_clicked_key, {}).get("data_key")
        if not data_sort_key:
            _debug(f" TileUsageWindow: Invalid column key '{column_clicked_key}' for sorting.")
            return

        if self.current_sort_column_id == data_sort_key:
            # If clicking the same column, just reverse the direction
            self.current_sort_direction_is_asc = not self.current_sort_direction_is_asc
        else:
            # If clicking a new column, set the initial direction based on column type
            self.current_sort_column_id = data_sort_key
            # Index column defaults to ascending, count columns default to descending
            if "count" in data_sort_key:
                self.current_sort_direction_is_asc = False # Descending for counts
            else:
                self.current_sort_direction_is_asc = True # Ascending for index
        
        self._update_header_sort_indicators()
        self.refresh_data()

    def _update_header_sort_indicators(self):
        if not hasattr(self, 'tree') or not self.tree.winfo_exists(): return
        for key, details in self.header_details.items():
            col_id_for_tree = details["id"] 
            data_key_for_sort = details["data_key"]
            
            current_heading_options = {}
            try:
                current_heading_options = self.tree.heading(col_id_for_tree)
            except tk.TclError: continue

            current_text = current_heading_options.get("text", "")
            text_to_set = current_text.replace(UP, "").replace(DOWN, "") # Remove old indicators

            if data_key_for_sort == self.current_sort_column_id:
                text_to_set += UP if self.current_sort_direction_is_asc else DOWN
            
            try:
                self.tree.heading(col_id_for_tree, text=text_to_set)
            except tk.TclError: pass
            
    def refresh_data(self): 
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            return
        
        _debug(f" TileUsageWindow: refresh_data() called. Sort by: {self.current_sort_column_id}, Asc: {self.current_sort_direction_is_asc}")
        
        current_selection_iid = None
        if self.tree.selection():
            current_selection_iid = self.tree.selection()[0]

        for i in self.tree.get_children():
            self.tree.delete(i)
        self._image_references.clear()
        
        usage_data = [] 
        if hasattr(self.app_ref, '_calculate_tile_usage_data'):
            try: 
                usage_data = self.app_ref._calculate_tile_usage_data() 
            except Exception as e:
                _error(f" Error calling _calculate_tile_usage_data: {e}")
                for i in range(getattr(self.app_ref, 'len(tileset_patterns)', 1)): 
                     usage_data.append({'tile_index': i, 'total_uses_count': 0, 'used_by_sts_count': 0})
        else: 
            _debug(" TileUsageWindow: _calculate_tile_usage_data not found for refresh.")
            for i in range(getattr(self.app_ref, 'len(tileset_patterns)', 1)): 
                usage_data.append({'tile_index': i, 'total_uses_count': 0, 'used_by_sts_count': 0})

        valid_sort_key = self.current_sort_column_id
        if usage_data and valid_sort_key not in usage_data[0]: 
            _debug(f" TileUsageWindow: Invalid sort key '{valid_sort_key}'. Defaulting to 'tile_index'.")
            valid_sort_key = 'tile_index' 
            self.current_sort_column_id = 'tile_index'
            self.current_sort_direction_is_asc = True
            self._update_header_sort_indicators()
        
        if usage_data: 
            try:
                usage_data.sort(key=lambda item: item[valid_sort_key], reverse=not self.current_sort_direction_is_asc)
            except (TypeError, KeyError) as e_sort: 
                _error(f" TileUsageWindow: Error during sorting by '{valid_sort_key}': {e_sort}. Using unsorted.")
        
        preview_image_size = TILE_USAGE_PREVIEW_SIZE 
        for item_data in usage_data: 
            tile_idx = item_data['tile_index']
            photo = None
            try:
                if hasattr(self.app_ref, 'create_tile_image'):
                    photo = self.app_ref.create_tile_image(tile_idx, preview_image_size)
                    if photo:
                        self._image_references.append(photo) 
                else:
                    _error(f" TileUsageWindow: create_tile_image not found for tile {tile_idx}")
            except Exception as e_photo: 
                _error(f" TileUsageWindow: Error creating preview image for tile {tile_idx}: {e_photo}")

            tags_for_this_row = ('tile_row',)
            if item_data.get('used_by_sts_count', 0) > 0:
                tags_for_this_row += ('has_st_refs',)

            item_iid = f"tile_{tile_idx}"
            self.tree.insert("", "end", 
                             iid=item_iid, 
                             image=photo if photo else '', 
                             text="", 
                             values=(f"{tile_idx}", 
                                     item_data['total_uses_count'], 
                                     item_data['used_by_sts_count']),
                             tags=tags_for_this_row)
        
        try:
            row_bg = self.style.lookup(self.treeview_style_name, 'background')
            self.tree.tag_configure('tile_row', background=row_bg)
        except tk.TclError: pass
        
        if current_selection_iid and self.tree.exists(current_selection_iid):
            self.tree.selection_set(current_selection_iid)
            self.tree.focus(current_selection_iid)
        
    def _on_item_selected(self, event):
        if not self.tree.winfo_exists(): return
        selected_items = self.tree.selection() 
        if not selected_items: return
        item_id_str = selected_items[0] 
        try:
            if item_id_str.startswith("tile_"):
                actual_item_idx = int(item_id_str.split("_")[1])
            else:
                _debug(f" TileUsageWindow: Could not parse tile_index from iid '{item_id_str}'.")
                return
        except (ValueError, IndexError) as e:
            _error(f" TileUsageWindow: Error parsing tile_index from iid '{item_id_str}': {e}")
            return
        
        if 0 <= actual_item_idx < len(tileset_patterns):
            if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'):
                self.app_ref.synchronize_selection_from_usage_window("tile", actual_item_idx)
        else:
            _debug(f" TileUsageWindow: Parsed invalid tile_index {actual_item_idx} for selection sync.")

    def _on_close(self): 
        # If the app is handling the closure, do not update config from here
        if getattr(self.app_ref, 'is_changing_projects', False):
            if self.winfo_exists():
                 self.destroy()
            return

        if hasattr(self.app_ref, 'update_window_config') and self.winfo_exists():
            current_geo = ""
            try:
                current_geo = self.winfo_geometry()
            except tk.TclError: pass
            self.app_ref.update_window_config(
                self.window_class_name,
                geometry=current_geo,
                tree_config=self._get_current_tree_config(),
                is_open=False
            )

        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
            self.refresh_timer_id = None
        
        if hasattr(self, '_treeview_refresh_timer_id') and self._treeview_refresh_timer_id:
            try: self.after_cancel(self._treeview_refresh_timer_id)
            except tk.TclError: pass
            self._treeview_refresh_timer_id = None
        
        _debug(" TileUsageWindow closed.")
        if self.app_ref: 
            self.app_ref.tile_usage_window = None 
        
        try:
            if self.winfo_exists(): self.destroy()
        except tk.TclError: pass

    def _on_tree_configure_debounced(self, event=None):
        if not self.winfo_exists(): return
        if event and event.widget != self.tree: return

        if self._treeview_refresh_timer_id:
            self.after_cancel(self._treeview_refresh_timer_id)
        self._treeview_refresh_timer_id = self.after(150, self._do_refresh_if_tree_valid_from_configure)

    def _do_refresh_if_tree_valid_from_configure(self):
        self._treeview_refresh_timer_id = None
        if self.winfo_exists() and self.winfo_ismapped():
            _debug(" TileUsageWindow: Tree <Configure> event. No data refresh, fixed image size.")
            # For fixed image sizes, only column data stretch might occur, Treeview handles this.
            # If rows become clipped/unclipped due to height change, a refresh might be desired
            # to re-center selection or re-evaluate what's "visible" if lazy loading were used.
            # For now, no explicit refresh_data() call.
        else:
            _debug(" TileUsageWindow: Tree <Configure> -> Skipped (window not valid/mapped).")

    def _on_tree_button_press(self, event):
        if not self.winfo_exists(): return
        region = self.tree.identify_region(event.x, event.y)
        column_id_pressed = self.tree.identify_column(event.x)

        if region == "separator" and column_id_pressed != "#0": # Prevent resizing column #0
            self._is_dragging_col_separator = True
            _debug(f" TileUsageWindow: Drag started on separator for data column.")
        elif region == "cell" or region == "tree": # A click on either the preview or a data cell
            item_iid = self.tree.identify_row(event.y)
            if not item_iid: return # Clicked on empty space

            try:
                tile_index = int(item_iid.split("_")[1])
                if not (0 <= tile_index < len(tileset_patterns)): return

                item_tags = self.tree.item(item_iid, "tags")

                # If it's an interactive row and the click was on a data cell...
                if 'has_st_refs' in item_tags and region == "cell":
                    # ...trigger the "Find All References" action.
                    if hasattr(self.app_ref, 'show_supertiles_using_tile'):
                        self.app_ref.show_supertiles_using_tile(tile_index)
                    return "break" # Stop further processing

                # For any other click on a row (including preview in 'tree' region), select the tile.
                if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'):
                    self.app_ref.synchronize_selection_from_usage_window("tile", tile_index)

            except (ValueError, IndexError) as e:
                _error(f" TileUsageWindow: Error processing click: {e}")
                return
        else:
            self._is_dragging_col_separator = False

    def _on_window_button_release(self, event):
        if not self.winfo_exists(): return
        if self._is_dragging_col_separator:
            self._is_dragging_col_separator = False
            _debug(" TileUsageWindow: Column drag ended. Updating config for column widths.")
            if hasattr(self.app_ref, 'update_window_config'):
                self.app_ref.update_window_config(
                    self.window_class_name,
                    tree_config=self._get_current_tree_config()
                )

    def _on_tree_motion(self, event):
        """Changes the mouse cursor when hovering over different regions of the treeview."""
        if not self.winfo_exists(): return
        
        region = self.tree.identify_region(event.x, event.y)
        new_cursor = "" # Default to standard arrow

        if region == "separator":
            new_cursor = "sb_h_double_arrow"
        
        # If hovering over the image area of the first column...
        elif region == "tree": 
            item_iid = self.tree.identify_row(event.y)
            if item_iid: # If we are on a valid row item...
                # ...the tile preview is always clickable to select it.
                new_cursor = "hand2"

        # If hovering over a regular data cell...
        elif region == "cell":
            item_iid = self.tree.identify_row(event.y)
            if item_iid:
                item_tags = self.tree.item(item_iid, "tags")
                # Make the cursor a hand only if it's an interactive row (has ST refs)
                if 'has_st_refs' in item_tags:
                    new_cursor = "hand2"

        # Only re-configure the widget if the cursor style needs to change
        if self.tree.cget("cursor") != new_cursor:
            self.tree.config(cursor=new_cursor)

class SupertileUsageWindow(tk.Toplevel):
    def __init__(self, master_app):
        super().__init__(master_app.root)
        self.app_ref = master_app
        self.title("Supertile Usage")
        self.transient(master_app.root)
        self.resizable(True, True) 

        self._image_references = []
        self.current_sort_column_id = "st_index" 
        self.current_sort_direction_is_asc = True
        self.refresh_timer_id = None
        # self.underline_font = None # This is now removed
        
        self.window_class_name = self.__class__.__name__
        saved_config = self.app_ref.get_window_config(self.window_class_name)
        initial_geometry = saved_config.get('geometry')
        initial_sort_col_data_key = saved_config.get('sort_column_id', self.current_sort_column_id) # This is the data key
        initial_sort_asc = saved_config.get('sort_asc', self.current_sort_direction_is_asc)
        initial_col_widths = saved_config.get('column_widths', {})
        
        self.current_sort_column_id = initial_sort_col_data_key # Store the data key for sorting logic
        self.current_sort_direction_is_asc = initial_sort_asc
        
        self._is_dragging_col_separator = False
        self._col0_width_at_drag_start = 0 # For image column specifically
        self._treeview_refresh_timer_id = None
        self.styled_row_height = 0 
        self._update_images_timer_id = None 

        app_st_grid_h = self.app_ref.supertile_grid_height
        tile_h_const = TILE_HEIGHT 
        scale_const = SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL 

        self.preview_target_content_h = max(1, int(app_st_grid_h * tile_h_const * scale_const))
        treeview_styled_row_h = self.preview_target_content_h + SUPERTILE_USAGE_ROW_PADDING
        self.styled_row_height = treeview_styled_row_h 
        
        min_col0_image_area_w = SUPERTILE_USAGE_MIN_IMAGE_MSX_W * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL
        self.min_col0_total_width = max(1, int(min_col0_image_area_w + SUPERTILE_USAGE_COL0_OFFSET_GUESS))

        main_frame = ttk.Frame(self, padding="5")
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_rowconfigure(1, weight=1) # Treeview itself is in row 1
        main_frame.grid_columnconfigure(0, weight=1)

        self.style = ttk.Style()
        self.treeview_style_name = f"SupertileUsage_{id(self)}.Treeview" 
        try:
            self.style.configure(self.treeview_style_name, rowheight=treeview_styled_row_h)
            self.style.map(self.treeview_style_name,
                           background=[('selected', self.style.lookup(self.treeview_style_name, 'background'))],
                           foreground=[('selected', self.style.lookup(self.treeview_style_name, 'foreground'))])
        except tk.TclError as e_style:
            _debug(f" SupertileUsageWindow: TclError configuring style '{self.treeview_style_name}': {e_style}")
            try: 
                app_style = getattr(self.app_ref, 'style', ttk.Style()) 
                app_style.configure('Treeview', rowheight=treeview_styled_row_h) # Fallback
                self.treeview_style_name = 'Treeview' 
            except Exception as e_gen:
                 _debug(f" SupertileUsageWindow: Failed to apply generic Treeview rowheight: {e_gen}")

        self.data_column_ids_for_values = ("st_index_val", "uses_on_map_val")
        self.tree = ttk.Treeview(
            main_frame,
            columns=self.data_column_ids_for_values,
            show="tree headings",
            height=16, 
            selectmode="browse",
            style=self.treeview_style_name
        )

        col0_default_width = 150 
        self.tree.column("#0", 
                         width=initial_col_widths.get("#0", col0_default_width), 
                         minwidth=self.min_col0_total_width, stretch=tk.YES, anchor=tk.W)
        self.tree.heading("#0", text="Supertile", command=lambda: self._sort_by_column("#0"))

        index_col_default_width = 70
        self.tree.column("st_index_val", 
                         width=initial_col_widths.get("st_index_val", index_col_default_width), 
                         minwidth=50, stretch=tk.YES, anchor=tk.CENTER)
        self.tree.heading("st_index_val", text="Index", command=lambda: self._sort_by_column("st_index"))
        
        self.header_details = { 
            "#0": {"id": "#0", "data_key": "st_index"}, 
            "st_index": {"id": "st_index_val", "data_key": "st_index"},
            "uses_on_map_count": {"id": "uses_on_map_val", "data_key": "uses_on_map_count"}
        }
        
        self.current_sort_command_key = initial_sort_col_data_key 
        for cmd_key, details_dict in self.header_details.items():
            if details_dict["data_key"] == initial_sort_col_data_key:
                self.current_sort_command_key = cmd_key
                break

        uses_col_default_width = 100
        self.tree.column("uses_on_map_val", 
                         width=initial_col_widths.get("uses_on_map_val", uses_col_default_width), 
                         minwidth=80, stretch=tk.YES, anchor=tk.CENTER)
        self.tree.heading("uses_on_map_val", text="Uses on Map", command=lambda: self._sort_by_column("uses_on_map_count"))
        
        self._update_header_sort_indicators() 

        # Use the shared font object from the main application
        try:
            if hasattr(self.app_ref, 'link_font') and self.app_ref.link_font:
                self.tree.tag_configure('has_map_refs', foreground='blue', font=self.app_ref.link_font)
            else: # Fallback
                self.tree.tag_configure('has_map_refs', foreground='blue', underline=True)
        except Exception as e_font:
             _debug(f" SupertileUsageWindow: Could not apply special font: {e_font}")
             self.tree.tag_configure('has_map_refs', foreground='blue')

        v_scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=v_scrollbar.set)
        h_scrollbar = ttk.Scrollbar(main_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(xscrollcommand=h_scrollbar.set)

        self.tree.grid(row=1, column=0, sticky="nsew") # Treeview in grid row 1
        v_scrollbar.grid(row=1, column=1, sticky="ns")
        h_scrollbar.grid(row=2, column=0, sticky="ew") # H-scrollbar below tree

        button_frame_container = ttk.Frame(main_frame)
        button_frame_container.grid(row=3, column=0, columnspan=2, sticky="ew", pady=(5,0))
        self.refresh_button = None
        if root.app_debug_mode:
            self.refresh_button = ttk.Button(button_frame_container, text="Refresh (Debug)", command=self.refresh_data)
            self.refresh_button.pack(pady=5)

        self.tree.bind("<<TreeviewSelect>>", self._on_item_selected)
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        
        self.tree.bind("<ButtonPress-1>", self._on_tree_button_press)
        self.bind("<ButtonRelease-1>", self._on_window_button_release, add='+')
        self.tree.bind("<Configure>", self._on_tree_configure_debounced)
        self.tree.bind("<Motion>", self._on_tree_motion)
        
        v_scrollbar.bind("<ButtonRelease-1>", lambda e: self._schedule_update_visible_images(delay_ms=100), add='+')
        v_scrollbar.bind("<B1-Motion>", lambda e: self._schedule_update_visible_images(delay_ms=150), add='+')
        self.tree.bind("<MouseWheel>", lambda e: self._schedule_update_visible_images(delay_ms=50), add='+')
        self.tree.bind("<Button-4>", lambda e: self._schedule_update_visible_images(delay_ms=50), add='+')
        self.tree.bind("<Button-5>", lambda e: self._schedule_update_visible_images(delay_ms=50), add='+')
        self.tree.bind("<KeyPress-Up>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+')
        self.tree.bind("<KeyPress-Down>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+')
        self.tree.bind("<KeyPress-Prior>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+') 
        self.tree.bind("<KeyPress-Next>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+') 
        self.tree.bind("<KeyPress-Home>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+')
        self.tree.bind("<KeyPress-End>", lambda e: self.after_idle(self._schedule_update_visible_images, 50), add='+')

        if initial_geometry:
            try:
                self.geometry(initial_geometry)
            except tk.TclError as e_geom:
                _error(f" SupertileUsageWindow: Error applying saved geometry '{initial_geometry}': {e_geom}")
        else: # Default size if no geometry saved
            self.update_idletasks()
            default_h = (16 * treeview_styled_row_h) + 60 # Approx for 16 rows + header/scrollbar
            default_w = col0_default_width + index_col_default_width + uses_col_default_width + 20
            self.geometry(f"{max(400, default_w)}x{max(400, default_h)}")
            
        self.app_ref.update_window_config(self.window_class_name, is_open=True)
        self.after(50, self.refresh_data_if_ready)

    def _get_current_tree_config(self):
        """Returns current sort state and column widths for saving."""
        widths = {}
        if hasattr(self, 'tree') and self.tree.winfo_exists():
            try:
                widths["#0"] = self.tree.column("#0", "width")
                for col_id in self.data_column_ids_for_values: # Correctly iterate defined data columns
                    widths[col_id] = self.tree.column(col_id, "width")
            except tk.TclError:
                _debug(" SupertileUsageWindow: TclError getting column widths for save.")
        return {
            # Save the data_key used for sorting, not the command_key
            "sort_column_id": self.current_sort_column_id, 
            "sort_asc": self.current_sort_direction_is_asc,
            "column_widths": widths
        }

    def refresh_data_if_ready(self):
        if self.winfo_exists() and self.winfo_ismapped():
            self.refresh_data()
        else:
            self.after(50, self.refresh_data_if_ready)

    def refresh_data(self):
        _debug(f" SupertileUsageWindow: refresh_data() called. Sort: {self.current_sort_column_id}, Asc: {self.current_sort_direction_is_asc}")
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            _debug(" SupertileUsageWindow: Treeview not ready for refresh_data.")
            return

        current_selection_iid = None
        if self.tree.selection():
            current_selection_iid = self.tree.selection()[0]

        for i in self.tree.get_children():
            self.tree.delete(i)
        self._image_references.clear() 

        usage_data = []
        if hasattr(self.app_ref, '_calculate_supertile_usage_data'):
            try:
                usage_data = self.app_ref._calculate_supertile_usage_data()
            except Exception as e:
                _error(f" SupertileUsageWindow: Error calling _calculate_supertile_usage_data: {e}")
                for i in range(getattr(self.app_ref, 'len(supertiles_data)', 0)):
                     usage_data.append({'st_index': i, 'uses_on_map_count': 0})
        else:
            _debug(" SupertileUsageWindow: _calculate_supertile_usage_data not found.")
            for i in range(getattr(self.app_ref, 'len(supertiles_data)', 0)):
                 usage_data.append({'st_index': i, 'uses_on_map_count': 0})

        valid_sort_key = self.current_sort_column_id
        
        if usage_data and valid_sort_key not in usage_data[0]:
            _debug(f" SupertileUsageWindow: Invalid sort column DATA KEY '{valid_sort_key}'. Defaulting to 'st_index'.")
            valid_sort_key = 'st_index'
            self.current_sort_column_id = 'st_index' 
            self.current_sort_command_key = "#0" 
            self.current_sort_direction_is_asc = True
            self._update_header_sort_indicators() 

        if usage_data:
            try:
                usage_data.sort(key=lambda item: item[valid_sort_key], reverse=not self.current_sort_direction_is_asc)
            except (TypeError, KeyError) as e_sort:
                _error(f" SupertileUsageWindow: Error sorting by '{valid_sort_key}': {e_sort}. Using unsorted.")
        
        for item_data in usage_data:
            st_idx = item_data['st_index']
            item_iid = f"st_{st_idx}"
            
            # Determine which tags to apply to the row
            tags_for_this_row = ('st_row',)
            if item_data.get('uses_on_map_count', 0) > 0:
                tags_for_this_row += ('has_map_refs',)
            
            self.tree.insert(
                "", "end",
                iid=item_iid,
                text="", 
                image='', 
                values=(f"{st_idx}", item_data['uses_on_map_count']),
                tags=tags_for_this_row # Apply the determined tags
            )
        
        try:
            row_bg = self.style.lookup(self.treeview_style_name, 'background')
            self.tree.tag_configure('st_row', background=row_bg)
        except tk.TclError: pass
        
        if current_selection_iid and self.tree.exists(current_selection_iid):
            self.tree.selection_set(current_selection_iid)
            self.tree.focus(current_selection_iid)

        self.after_idle(self._schedule_update_visible_images)

    def _sort_by_column(self, column_command_key):
        # column_command_key is like "#0", "st_index", "uses_on_map_count" (keys from self.header_details)
        _debug(f" SupertileUsageWindow: Sorting by command_key '{column_command_key}'")
        
        new_data_sort_key = self.header_details.get(column_command_key, {}).get("data_key")
        if not new_data_sort_key:
            _debug(f"   Could not find data_key for command_key '{column_command_key}'. Aborting sort.")
            return

        if self.current_sort_column_id == new_data_sort_key: 
            # If clicking the same column, just reverse the direction
            self.current_sort_direction_is_asc = not self.current_sort_direction_is_asc
        else: 
            # If clicking a new column, set the initial direction based on column type
            self.current_sort_column_id = new_data_sort_key
            self.current_sort_command_key = column_command_key # Update the command key being sorted by
            # Index column defaults to ascending, count columns default to descending
            if "count" in new_data_sort_key:
                self.current_sort_direction_is_asc = False # Descending for counts
            else:
                self.current_sort_direction_is_asc = True # Ascending for index
        
        self._update_header_sort_indicators()
        self.refresh_data()

    def _update_header_sort_indicators(self):
        if not hasattr(self, 'tree') or not self.tree.winfo_exists(): return
        for cmd_key, details in self.header_details.items():
            tree_col_id = details["id"]      # e.g., "#0", "st_index_val"
            data_key = details["data_key"] # e.g., "st_index"
            
            current_heading_options = {}
            try:
                current_heading_options = self.tree.heading(tree_col_id)
            except tk.TclError: continue

            current_text = current_heading_options.get("text", "")
            text_to_set = current_text.replace(UP, "").replace(DOWN, "")

            if data_key == self.current_sort_column_id: # Compare with the data key
                text_to_set += UP if self.current_sort_direction_is_asc else DOWN
            
            try:
                self.tree.heading(tree_col_id, text=text_to_set)
            except tk.TclError: pass

    def _on_item_selected(self, event):
        if not self.tree.winfo_exists(): return
        selected_items = self.tree.selection()
        if not selected_items: return

        item_iid_str = selected_items[0] 
        try:
            if item_iid_str.startswith("st_"):
                actual_st_idx = int(item_iid_str.split("_")[1])
            else:
                _error(f" SupertileUsageWindow: Could not parse st_index from iid '{item_iid_str}'.")
                return
        except (ValueError, IndexError) as e:
            _error(f" SupertileUsageWindow: Error parsing st_index from iid '{item_iid_str}': {e}")
            return
        
        if 0 <= actual_st_idx < len(supertiles_data): 
            _debug(f" SupertileUsageWindow: Item selected, st_index: {actual_st_idx}")
            if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'):
                self.app_ref.synchronize_selection_from_usage_window("supertile", actual_st_idx)
        else:
            _debug(f" SupertileUsageWindow: Parsed invalid st_index {actual_st_idx} (len(supertiles_data): {len(supertiles_data)}) for selection sync.")

    def request_refresh(self, delay_ms=300):
        # _debug(f" SupertileUsageWindow: request_refresh called. Current timer: {self.refresh_timer_id}")
        if not self.winfo_exists():
            return
        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id)
            except tk.TclError: pass
        self.refresh_timer_id = self.after(delay_ms, self._perform_debounced_refresh)
        # _debug(f" SupertileUsageWindow: new refresh_timer_id set to: {self.refresh_timer_id}")

    def _perform_debounced_refresh(self):
        # _debug(f" SupertileUsageWindow: _perform_debounced_refresh executing for timer {self.refresh_timer_id}.")
        self.refresh_timer_id = None
        if self.winfo_exists() and self.winfo_ismapped(): 
            self.refresh_data()

    def _on_close(self):
        # If the app is handling the closure, do not update config from here
        if getattr(self.app_ref, 'is_changing_projects', False):
            if self.winfo_exists():
                 self.destroy()
            return

        # Update in-memory config before destroying
        if hasattr(self.app_ref, 'update_window_config') and self.winfo_exists():
            current_geo = ""
            try:
                current_geo = self.winfo_geometry()
            except tk.TclError: pass
            self.app_ref.update_window_config(
                self.window_class_name,
                geometry=current_geo,
                tree_config=self._get_current_tree_config(),
                is_open=False
            )

        if self.refresh_timer_id is not None:
            try: self.after_cancel(self.refresh_timer_id) 
            except tk.TclError: pass
            self.refresh_timer_id = None
        
        if hasattr(self, '_treeview_refresh_timer_id') and self._treeview_refresh_timer_id:
            try: self.after_cancel(self._treeview_refresh_timer_id) 
            except tk.TclError: pass
            self._treeview_refresh_timer_id = None

        if hasattr(self, '_update_images_timer_id') and self._update_images_timer_id is not None:
            try: self.after_cancel(self._update_images_timer_id)
            except tk.TclError: pass
            self._update_images_timer_id = None

        _debug(" SupertileUsageWindow closed.")
        if self.app_ref: 
            self.app_ref.supertile_usage_window = None 
        try: 
            if self.winfo_exists(): self.destroy()
        except tk.TclError: pass
        
    def _on_tree_configure_debounced(self, event=None):
        if not self.winfo_exists(): return
        if event and event.widget != self.tree: return

        if self._treeview_refresh_timer_id:
            self.after_cancel(self._treeview_refresh_timer_id)
        # Refresh data if tree is configured, as column widths might affect image rendering for col #0
        self._treeview_refresh_timer_id = self.after(150, self._do_populate_if_tree_valid_from_configure)

    def _do_populate_if_tree_valid_from_configure(self):
        self._treeview_refresh_timer_id = None 
        if self.winfo_exists() and self.winfo_ismapped():
            _debug(" SupertileUsageWindow: Tree <Configure> -> Refreshing data (due to potential col width change).")
            self.refresh_data() # This will trigger lazy image loading
        else:
            _debug(" SupertileUsageWindow: Tree <Configure> -> Skipped refresh (window not valid/mapped).")

    def _on_tree_button_press(self, event):
        if not self.winfo_exists(): return
        region = self.tree.identify_region(event.x, event.y)
        
        if region == "separator":
            self._is_dragging_col_separator = True
            column_id_pressed = self.tree.identify_column(event.x) # Get which separator line
            try:
                # Store width of the column to the LEFT of the separator
                # For tree.column("#0"), it's simple. For others, it's column_id_pressed.
                # However, identify_column often gives the column to the RIGHT of separator.
                # The important part is knowing a drag started. We'll get all widths on release.
                if column_id_pressed == "#0": # Dragging separator for the first column
                    self._col0_width_at_drag_start = self.tree.column("#0", "width")
                # For other columns, the Treeview handles resize, we just save on release.
            except tk.TclError: 
                self._is_dragging_col_separator = False 
                return
            _debug(f" SupertileUsageWindow: Drag started on separator. Col ID: {column_id_pressed}")
        elif region == "cell" or region == "tree": # A click on either the preview or a data cell
            item_iid = self.tree.identify_row(event.y)
            if not item_iid: return # Clicked on empty space

            try:
                st_index = int(item_iid.split("_")[1])
                if not (0 <= st_index < len(supertiles_data)): return

                # If the click was on a data cell (not the preview image)...
                if region == "cell":
                    # ...check if the supertile is actually used on the map.
                    usage_count = int(self.tree.set(item_iid, "uses_on_map_val"))
                    if usage_count > 0 and hasattr(self.app_ref, 'show_map_locations_using_supertile'):
                        # ...trigger the "Find All References" action.
                        self.app_ref.show_map_locations_using_supertile(st_index)
                        return "break" # Stop further processing

                # For any other click on a row (including the preview in the 'tree' region), select the supertile.
                if hasattr(self.app_ref, 'synchronize_selection_from_usage_window'):
                    self.app_ref.synchronize_selection_from_usage_window("supertile", st_index)

            except (ValueError, IndexError) as e:
                _error(f" SupertileUsageWindow: Error processing click: {e}")
                return
        else:
            self._is_dragging_col_separator = False

    def _on_window_button_release(self, event):
        if not self.winfo_exists(): return
        if self._is_dragging_col_separator:
            self._is_dragging_col_separator = False 
            _debug(" SupertileUsageWindow: Column drag ended. Scheduling width check/config save.")
            self.after_idle(self._check_col_widths_and_update_config_after_drag)

    def _check_col_widths_and_update_config_after_drag(self):
        if not self.winfo_exists() or not self.tree.winfo_exists(): return
        
        config_changed_by_drag = False
        try:
            current_col0_width = self.tree.column("#0", "width")
            if hasattr(self, '_col0_width_at_drag_start') and current_col0_width != self._col0_width_at_drag_start:
                _debug(f" SupertileUsageWindow: Col #0 width changed by drag: {self._col0_width_at_drag_start} -> {current_col0_width}. Refreshing for new image crops.")
                if self.winfo_ismapped():
                    self.refresh_data() # This will re-crop images for col #0
                config_changed_by_drag = True
            
            # Even if col #0 didn't change, other columns might have. Update config.
            if hasattr(self.app_ref, 'update_window_config'):
                 self.app_ref.update_window_config(
                    self.window_class_name,
                    tree_config=self._get_current_tree_config() # This gets all current widths
                )
                 if not config_changed_by_drag: # If only other columns changed, mark config as changed
                     _debug(" SupertileUsageWindow: Data column widths may have changed. Config updated.")


        except tk.TclError:
            _debug(" SupertileUsageWindow: TclError during _check_col_widths_after_drag.")
    
    # --- Lazy Loading Methods (Copied from previous successful implementation) ---
    def _schedule_update_visible_images(self, delay_ms=50):
        if not self.winfo_exists():
            return
        if hasattr(self, '_update_images_timer_id') and self._update_images_timer_id is not None:
            try:
                self.after_cancel(self._update_images_timer_id)
            except tk.TclError: 
                pass
        self._update_images_timer_id = self.after(delay_ms, self._update_visible_item_images)

    def _update_visible_item_images(self):
        self._update_images_timer_id = None
        if not self.winfo_exists() or not hasattr(self, 'tree') or not self.tree.winfo_exists() or not self.app_ref:
            return

        children = self.tree.get_children()
        if not children:
            return

        num_items = len(children)
        try:
            yview = self.tree.yview() 
            tree_height_px = self.tree.winfo_height()
        except tk.TclError: 
            return

        row_h = self.styled_row_height 
        if row_h <= 0 or tree_height_px <= 0 : return
        
        buffer_items = 3 
        num_items_on_screen_estimate = math.ceil(tree_height_px / row_h) if row_h > 0 else num_items
        first_visible_model_idx = int(yview[0] * num_items)
        start_load_idx = max(0, first_visible_model_idx - buffer_items)
        end_load_idx = min(num_items, first_visible_model_idx + num_items_on_screen_estimate + buffer_items)

        total_col0_width = 0
        try:
            total_col0_width = self.tree.column("#0", "width")
        except tk.TclError: return 

        effective_total_col0_width = max(total_col0_width, self.min_col0_total_width)
        image_content_area_width = max(1, effective_total_col0_width - SUPERTILE_USAGE_COL0_OFFSET_GUESS)
        newly_added_images = []

        for i in range(start_load_idx, end_load_idx):
            item_iid = children[i]
            current_img_name_in_tree_list = self.tree.item(item_iid, "image")
            current_img_name_in_tree = ""
            if isinstance(current_img_name_in_tree_list, (list, tuple)) and current_img_name_in_tree_list:
                current_img_name_in_tree = str(current_img_name_in_tree_list[0])
            elif isinstance(current_img_name_in_tree_list, str):
                current_img_name_in_tree = current_img_name_in_tree_list
            
            if not current_img_name_in_tree: 
                try:
                    if item_iid.startswith("st_"): st_idx = int(item_iid.split("_")[1])
                    else: continue
                except (ValueError, IndexError): continue
                photo = None
                try:
                    if hasattr(self.app_ref, 'create_cropped_supertile_preview_for_usage_window'):
                        photo = self.app_ref.create_cropped_supertile_preview_for_usage_window(
                            st_idx, image_content_area_width, self.preview_target_content_h 
                        )
                        if photo:
                            newly_added_images.append(photo)
                            self.tree.item(item_iid, image=photo)
                except Exception as e_photo:
                    _error(f" SupertileUsageWindow: Error lazy-load preview ST {st_idx}: {e_photo}")
        
        if newly_added_images:
            self._image_references.extend(newly_added_images)

    def _on_tree_motion(self, event):
        """Changes the mouse cursor when hovering over different regions of the treeview."""
        if not self.winfo_exists(): return
        
        region = self.tree.identify_region(event.x, event.y)
        new_cursor = "" # Default to standard arrow

        if region == "separator":
            new_cursor = "sb_h_double_arrow"
        
        # If hovering over the image area of the first column...
        elif region == "tree": 
            item_iid = self.tree.identify_row(event.y)
            if item_iid: # If we are on a valid row item...
                # ...the supertile preview is always clickable to select it.
                new_cursor = "hand2"

        # If hovering over a regular data cell...
        elif region == "cell":
            item_iid = self.tree.identify_row(event.y)
            if item_iid:
                # Check for the tag we added in refresh_data, not the text value
                item_tags = self.tree.item(item_iid, "tags")
                if 'has_map_refs' in item_tags:
                    new_cursor = "hand2"
                
        # Only re-configure the widget if the cursor style needs to change
        if self.tree.cget("cursor") != new_cursor:
            self.tree.config(cursor=new_cursor)

class ExportDialog(tk.Toplevel):
    def __init__(self, parent, app_instance, project_path):
        super().__init__(parent)
        self.transient(parent)
        self.grab_set()
        self.title("Export Raw Project")
        self.resizable(False, False)

        self.parent_app = app_instance
        self.project_path = project_path
        
        self.output_dir_var = tk.StringVar()
        self.basename_var = tk.StringVar()
        self.gen_asm_var = tk.BooleanVar(value=True)
        self.gen_c_header_var = tk.BooleanVar(value=True)

        if self.project_path:
            self.output_dir_var.set(os.path.dirname(self.project_path))
            self.basename_var.set(os.path.splitext(os.path.basename(self.project_path))[0])

        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(expand=True, fill="both")

        # Destination Directory
        dir_frame = ttk.LabelFrame(main_frame, text="Destination Folder")
        dir_frame.pack(fill="x", padx=5, pady=5)
        dir_entry = ttk.Entry(dir_frame, textvariable=self.output_dir_var, width=60)
        dir_entry.pack(side="left", fill="x", expand=True, padx=5, pady=5)
        browse_button = ttk.Button(dir_frame, text="Browse...", command=self.browse_directory)
        browse_button.pack(side="left", padx=5, pady=5)

        # Basename
        base_frame = ttk.LabelFrame(main_frame, text="Output Basename")
        base_frame.pack(fill="x", padx=5, pady=5)
        base_entry = ttk.Entry(base_frame, textvariable=self.basename_var, width=60)
        base_entry.pack(fill="x", expand=True, padx=5, pady=5)

        # Options
        options_frame = ttk.LabelFrame(main_frame, text="Generate Include Files")
        options_frame.pack(fill="x", padx=5, pady=5)
        asm_check = ttk.Checkbutton(options_frame, text="Assembly Include File (.s)", variable=self.gen_asm_var)
        asm_check.pack(anchor="w", padx=10, pady=2)
        c_check = ttk.Checkbutton(options_frame, text="C Header Files (.h)", variable=self.gen_c_header_var)
        c_check.pack(anchor="w", padx=10, pady=2)

        # Log
        log_frame = ttk.LabelFrame(main_frame, text="Export Log")
        log_frame.pack(padx=5, pady=10, fill=tk.BOTH, expand=True)
        self.log_text = tk.Text(log_frame, height=12, width=80, wrap=tk.WORD, state=tk.DISABLED, bg="#2E2E2E", fg="#D0D0D0", font=("Consolas", 9))
        scrollbar = ttk.Scrollbar(log_frame, command=self.log_text.yview)
        self.log_text['yscrollcommand'] = scrollbar.set
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(padx=5, pady=(5, 0))
        self.export_button = ttk.Button(button_frame, text="Export", command=self.start_export)
        self.close_button = ttk.Button(button_frame, text="Close", command=self.on_close)
        self.export_button.pack(side=tk.LEFT, padx=5)
        self.close_button.pack(side=tk.LEFT, padx=5)
        
        self.protocol("WM_DELETE_WINDOW", self.on_close)
        self.center_window()

    def center_window(self):
        self.update_idletasks()
        parent = self.master
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_reqwidth() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_reqheight() // 2)
        self.geometry(f"+{x}+{y}")

    def browse_directory(self):
        directory = filedialog.askdirectory(parent=self, title="Select Output Directory")
        if directory:
            self.output_dir_var.set(directory)

    def start_export(self):
        self.export_button.config(state=tk.DISABLED)
        self.close_button.config(state=tk.DISABLED)
        self.log_text.config(state=tk.NORMAL)
        self.log_text.delete('1.0', tk.END)
        self.log_text.config(state=tk.DISABLED)

        output_dir = self.output_dir_var.get()
        basename = self.basename_var.get()

        if not output_dir or not basename:
            messagebox.showerror("Input Error", "Output directory and basename cannot be empty.", parent=self)
            self.on_export_complete(success=False)
            return

        script_base_path = os.path.dirname(sys.argv[0])
        cli_script = os.path.join(script_base_path, "msxtileexport.py")
        
        if not os.path.exists(cli_script):
            messagebox.showerror("Script Error", f"Exporter script 'msxtileexport.py' not found in application directory:\n{script_base_path}", parent=self)
            self.on_export_complete(success=False)
            return

        source_file = self.project_path + ".SC4Map"

        command = [
            sys.executable,
            cli_script,
            source_file,
            "--output-dir", output_dir,
            "--output-basename", basename
        ]
        if self.gen_asm_var.get():
            command.append("--asm")
        if self.gen_c_header_var.get():
            command.append("--c-header")
        
        self.parent_app._run_script_and_stream_output(
            command, 
            self.log_text, 
            self.on_export_complete
        )

    def on_export_complete(self, success=True):
        self.export_button.config(state=tk.NORMAL)
        self.close_button.config(state=tk.NORMAL)
        if success:
            messagebox.showinfo("Export Complete", "Export process finished successfully.", parent=self)
        
    def on_close(self):
        if self.export_button['state'] == tk.DISABLED:
            messagebox.showwarning("Export in Progress", "Please wait for the process to complete.", parent=self)
        else:
            self.destroy()

class ImageImportDialog(tk.Toplevel):
    def __init__(self, parent, app_instance, image_path):
        super().__init__(parent)
        self.transient(parent)
        self.grab_set()
        self.title("Create Project from Image")
        self.resizable(False, False)

        self.app_ref = app_instance
        self.image_path = image_path
        self.result = None 

        self.palette_slot_states = ["auto"] * 16
        self.slot_canvases = []
        self._build_ui()
        self._initial_draw_all_slots()

        self.bind("<Escape>", lambda e: self._on_cancel_click())
        self.protocol("WM_DELETE_WINDOW", self._on_cancel_click)
        self._center_on_parent()

    def _build_ui(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(expand=True, fill="both")

        # --- Source Image Frame ---
        source_frame = ttk.LabelFrame(main_frame, text="Source Image")
        source_frame.pack(fill="x", padx=5, pady=(0, 10))
        
        source_grid = ttk.Frame(source_frame, padding=(10, 5))
        source_grid.pack(fill="x")
        source_grid.columnconfigure(0, weight=1)
        
        self.path_label_var = tk.StringVar(value=self.image_path)
        path_label = ttk.Label(source_grid, textvariable=self.path_label_var, wraplength=450, justify="left")
        path_label.grid(row=0, column=0, sticky="ew")
        
        change_button = ttk.Button(source_grid, text="Change...", command=self._change_source_image)
        change_button.grid(row=0, column=1, sticky="e", padx=(10, 0))

        # --- Palette Constraints Frame ---
        palette_frame = ttk.LabelFrame(main_frame, text="Palette Constraints")
        palette_frame.pack(fill="x", padx=5, pady=5)
        
        palette_grid = ttk.Frame(palette_frame, padding=(10, 5))
        palette_grid.pack(fill="x")
        palette_grid.columnconfigure(1, weight=1)

        canvas_grid = ttk.Frame(palette_grid)
        canvas_grid.grid(row=0, column=0, sticky="ns")

        for i in range(16):
            row = i // 4
            col = i % 4
            slot_canvas = tk.Canvas(canvas_grid, width=32, height=32, highlightthickness=1, highlightbackground="grey")
            slot_canvas.grid(row=row, column=col, padx=2, pady=2)
            slot_canvas.bind("<Button-1>", lambda e, index=i: self._on_slot_click(index))
            self.slot_canvases.append(slot_canvas)
            
        right_panel_frame = ttk.Frame(palette_grid)
        right_panel_frame.grid(row=0, column=1, sticky="ns", padx=(20, 0))
        right_panel_frame.rowconfigure(0, weight=1)

        legend_frame = ttk.Frame(right_panel_frame)
        legend_frame.pack(anchor="nw")
        
        icon_font = font.Font(family="Segoe UI Emoji", size=10)
        
        auto_frame = ttk.Frame(legend_frame)
        auto_frame.pack(anchor="w")
        ttk.Label(auto_frame, text="", font=icon_font).pack(side="left")
        ttk.Label(auto_frame, text="= Auto: Script chooses the best color.").pack(side="left", padx=5)
        
        fixed_frame = ttk.Frame(legend_frame)
        fixed_frame.pack(anchor="w", pady=5)
        ttk.Label(fixed_frame, text="", font=icon_font).pack(side="left")
        ttk.Label(fixed_frame, text="= Fixed: This exact color must be used.").pack(side="left", padx=5)
        
        blocked_frame = ttk.Frame(legend_frame)
        blocked_frame.pack(anchor="w")
        ttk.Label(blocked_frame, text="\u26D4", font=icon_font).pack(side="left")
        ttk.Label(blocked_frame, text="= Blocked: This slot will not be used.").pack(side="left", padx=5)

        reset_button = ttk.Button(right_panel_frame, text="Reset All to Auto", command=self._reset_all_to_auto)
        reset_button.pack(side="bottom", anchor="e")

        # --- Import Settings Frame ---
        # --- Import Settings Frame ---
        settings_frame = ttk.LabelFrame(main_frame, text="Import Settings")
        settings_frame.pack(fill="x", padx=5, pady=5)
        
        settings_grid = ttk.Frame(settings_frame, padding=5)
        settings_grid.pack(fill="x")
        settings_grid.columnconfigure(1, weight=1)
        settings_grid.columnconfigure(3, weight=1)
        
        # Row 0: Max Tiles and Optimization
        ttk.Label(settings_grid, text="Max Tiles:").grid(row=0, column=0, sticky="w", padx=(0, 5))
        self.max_tiles_var = tk.IntVar(value=256)
        ttk.Spinbox(settings_grid, from_=1, to=256, textvariable=self.max_tiles_var, width=5).grid(row=0, column=1, sticky="w")
        
        ttk.Label(settings_grid, text="Optimization:").grid(row=0, column=2, sticky="w", padx=(10, 5))
        self.opt_mode_var = tk.StringVar(value="neutral")
        ttk.Combobox(settings_grid, textvariable=self.opt_mode_var, values=['neutral', 'sharp', 'balanced', 'soft'], state="readonly", width=12).grid(row=0, column=3, sticky="w")
        
        # Row 1: Sort Tileset and Color Metric
        ttk.Label(settings_grid, text="Sort Tileset:").grid(row=1, column=0, sticky="w", pady=(5,0))
        self.sort_tiles_var = tk.StringVar(value="cluster")
        ttk.Combobox(settings_grid, textvariable=self.sort_tiles_var, values=['none', 'greedy', 'cluster'], state="readonly", width=12).grid(row=1, column=1, sticky="w", pady=(5,0))

        ttk.Label(settings_grid, text="Color Metric:").grid(row=1, column=2, sticky="w", padx=(10, 5), pady=(5,0))
        self.metric_var = tk.StringVar(value="weighted-rgb")
        metric_values = ['rgb', 'weighted-rgb']
        if 'colour' in sys.modules:
            metric_values.extend(['cie76', 'ciede2000'])
        ttk.Combobox(settings_grid, textvariable=self.metric_var, values=metric_values, state="readonly", width=12).grid(row=1, column=3, sticky="w", pady=(5,0))
        
        # Row 2: Supertile dimensions
        self.st_label = ttk.Label(settings_grid, text="Supertile:")
        self.st_label.grid(row=2, column=0, sticky="w", pady=(5,0))
        self.st_frame = ttk.Frame(settings_grid)
        self.st_frame.grid(row=2, column=1, sticky="w", pady=(5,0))
        self.st_w_var = tk.IntVar(value=4)
        self.st_h_var = tk.IntVar(value=4)
        ttk.Spinbox(self.st_frame, from_=1, to=32, textvariable=self.st_w_var, width=3).pack(side="left")
        ttk.Label(self.st_frame, text=" x ").pack(side="left")
        ttk.Spinbox(self.st_frame, from_=1, to=32, textvariable=self.st_h_var, width=3).pack(side="left")

        # --- Advanced Options Frame ---
        advanced_frame = ttk.LabelFrame(main_frame, text="Advanced Options")
        advanced_frame.pack(fill="x", padx=5, pady=5)

        self.dither_var = tk.BooleanVar(value=False)
        self.offset_var = tk.BooleanVar(value=False)
        self.synth_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(advanced_frame, text="Enable Dithering", variable=self.dither_var).pack(anchor="w", padx=10, pady=2)
        ttk.Checkbutton(advanced_frame, text="Find best grid offset", variable=self.offset_var).pack(anchor="w", padx=10, pady=2)
        ttk.Checkbutton(advanced_frame, text="Synthesize new tiles for merged groups", variable=self.synth_var).pack(anchor="w", padx=10, pady=2)
        
        # --- Core Limiter Frame ---
        cores_frame = ttk.Frame(advanced_frame)
        cores_frame.pack(fill="x", padx=10, pady=(5,2))
        self.limit_cores_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(cores_frame, text="Limit processor cores to:", variable=self.limit_cores_var, command=self._on_limit_cores_toggle).pack(side="left")
        
        n_cores = os.cpu_count() or 1
        self.cores_var = tk.IntVar(value=max(1, n_cores - 1))
        core_values = list(range(1, n_cores + 1))
        self.cores_combo = ttk.Combobox(cores_frame, textvariable=self.cores_var, values=core_values, state="disabled", width=4)
        self.cores_combo.pack(side="left", padx=5)

        # --- Main Buttons Frame ---
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x", padx=5, pady=10)
        
        ttk.Button(button_frame, text="Import", command=self._on_import_click).pack(side="right", padx=(5,0))
        ttk.Button(button_frame, text="Cancel", command=self._on_cancel_click).pack(side="right")
    
    def _initial_draw_all_slots(self):
        for i in range(16):
            self._redraw_slot(i)

    def _change_source_image(self):
        new_path = filedialog.askopenfilename(
            parent=self, # Make dialog modal to this dialog
            title="Select New Source Image",
            filetypes=[
                ("All Supported Images", "*.png *.bmp *.gif *.jpg *.jpeg"),
                ("PNG files", "*.png"),
                ("BMP files", "*.bmp"),
                ("All files", "*.*")
            ]
        )
        if new_path:
            self.image_path = new_path
            self.path_label_var.set(self.image_path)
 
    def _redraw_slot(self, slot_index):
        canvas = self.slot_canvases[slot_index]
        state = self.palette_slot_states[slot_index]
        color_hex = self.app_ref.active_msx_palette[slot_index]
        
        canvas.delete("all")
        
        bg_color = "grey50" if state == "blocked" else color_hex
        canvas.create_rectangle(0, 0, 33, 33, fill=bg_color, outline="grey70")
        
        icon = ""
        if state == "auto": icon = "" # Brush emoji
        elif state == "fixed": icon = ""
        elif state == "blocked": icon = "\u26D4" # Prohibited/No Entry sign
        
        if icon:
            font_size = 14
            icon_font = font.Font(family="Segoe UI Emoji", size=font_size)
            
            # Stroked text for contrast
            canvas.create_text(17, 18, text=icon, font=icon_font, fill="white")
            canvas.create_text(16, 17, text=icon, font=icon_font, fill="black")

    def _on_slot_click(self, index):
        current_state = self.palette_slot_states[index]
        if current_state == "auto":
            self.palette_slot_states[index] = "fixed"
        elif current_state == "fixed":
            self.palette_slot_states[index] = "blocked"
        else: # blocked
            self.palette_slot_states[index] = "auto"
        self._redraw_slot(index)

    def _reset_all_to_auto(self):
        self.palette_slot_states = ["auto"] * 16
        self._initial_draw_all_slots()

    def _on_limit_cores_toggle(self):
        if self.limit_cores_var.get():
            self.cores_combo.config(state="readonly")
        else:
            self.cores_combo.config(state="disabled")

    def _on_import_click(self):
        palette_rules = []
        for i, state in enumerate(self.palette_slot_states):
            if state == "auto":
                palette_rules.append(state)
            elif state == "blocked":
                palette_rules.append("block")
            elif state == "fixed":
                hex_color = self.app_ref.active_msx_palette[i]
                r, g, b = self.app_ref._hex_to_rgb7(hex_color)
                palette_rules.append(f"{r}{g}{b}")
        
        self.result = {
            "max_tiles": self.max_tiles_var.get(),
            "opt_mode": self.opt_mode_var.get(),
            "st_width": self.st_w_var.get(),
            "st_height": self.st_h_var.get(),
            "metric": self.metric_var.get(),
            "sort_tiles": self.sort_tiles_var.get(),
            "dithering": self.dither_var.get(),
            "find_offset": self.offset_var.get(),
            "synthesize": self.synth_var.get(),
            "limit_cores": self.limit_cores_var.get(),
            "cores": self.cores_var.get(),
            "palette_rules": palette_rules
        }
        self.destroy()

    def _on_cancel_click(self):
        self.result = None
        self.destroy()
        
    def _center_on_parent(self):
        self.update_idletasks()
        parent = self.master
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (self.winfo_reqwidth() // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (self.winfo_reqheight() // 2)
        self.geometry(f"+{x}+{y}")

class ImageTileImportDialog(ImageImportDialog):
    def __init__(self, parent, app_instance, image_path):
        super().__init__(parent, app_instance, image_path)
        self.title("Import Tiles from Image")

    def _build_ui(self):
        super()._build_ui()
        self.st_label.grid_forget()
        self.st_frame.grid_forget()

# --- Color tooltip Class  ---------------------------------------------------------------------------------------------
class ColorTooltip:
    """Creates a floating tooltip window for displaying color information."""
    def __init__(self, parent):
        self.parent = parent
        self.tip_window = None
        self.label = None

    def show(self, text, x, y):
        """Display the tooltip with the given text at the specified screen coordinates."""
        if self.tip_window is None:
            self.tip_window = tk.Toplevel(self.parent)
            self.tip_window.overrideredirect(True) # No window border, title bar, etc.
            self.label = ttk.Label(
                self.tip_window, 
                text=text, 
                justify=tk.LEFT, 
                background="#FFFFE0", # Classic tooltip color
                relief=tk.SOLID, 
                borderwidth=1, 
                padding=4
            )
            self.label.pack()
            self.tip_window.withdraw() # Start hidden

        self.label.config(text=text)
        # Position is offset slightly from the cursor
        self.tip_window.geometry(f"+{x + 15}+{y + 10}")
        self.tip_window.deiconify() # Show the window

    def hide(self):
        """Hide the tooltip window."""
        if self.tip_window:
            self.tip_window.withdraw()


# --- Application Class  -----------------------------------------------------------------------------------------------
class TileEditorApp:
    def __init__(self, root):
        # --- 1. Basic App/Root Window Setup ---
        if root.app_debug_mode:
            logger.setLevel(logging.DEBUG)

        _debug("TileEditorApp __init__ started.")
        
        self.root = root
        self.root.title("MSX Tile Forge - Untitled") 
        with suppress(tk.TclError): # Try to maximize window
            self.root.state("zoomed")

        try:
            image_data = base64.b64decode(ICON_IMAGE)
            app_icon = tk.PhotoImage(data=image_data)
            self.root.iconphoto(True, app_icon)
            self.root.app_icon_ref = app_icon
            _debug(" Successfully set application icon from embedded data.")
        except Exception as e:
            _error(f"Failed to set application icon: {e}")
    
        # --- All instance attributes are initialized first ---
        self.undo_manager = UndoManager(self)
        self.current_project_base_path = None
        self.project_modified = False
        self.project_tile_limit = MAX_TILES
        self.scroll_speed_units = 3 
        self.is_currently_painting_tile = False
        self.pending_command_list = []
        self.is_changing_projects = False

        self.config_app_name = "MSXTileForge" 
        self.config_file_name = "settings.json"
        self.app_settings = {}
        
        self.active_msx_palette = []
        self.selected_palette_slot = 0

        self._is_updating_color_inputs = False # Recursion guard for traces
        self.msx2_color_preview_canvas = None
        self.hex24_color_preview_canvas = None
        self.rgb9_r_var, self.rgb9_g_var, self.rgb9_b_var = None, None, None
        self.rgb24_r_var, self.rgb24_g_var, self.rgb24_b_var = None, None, None
        self.color_tooltip = ColorTooltip(self.root)

        self._main_window_configure_timer = None 
        self._map_canvas_configure_timer = None
        self._palette_pane_resize_timer = None
        self.single_click_timer = None

        self.supertile_grid_width = DEFAULT_SUPERTILE_GRID_WIDTH
        self.supertile_grid_height = DEFAULT_SUPERTILE_GRID_HEIGHT
        self.is_setting_programmatic_highlight = False

        default_font_info = font.nametofont("TkDefaultFont")
        self.normal_font = font.Font(font=default_font_info)
        self.link_font = font.Font(font=default_font_info)
        self.link_font.configure(underline=True)

        self.tile_image_cache = {}      
        self.supertile_image_cache = {} 
        self.map_render_cache = {}      
        self.pil_map_viewport_image = None 
        self.tk_map_photoimage = None      

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        self.drag_indicator_id = None

        self.map_zoom_level = 1.0
        self.show_supertile_grid = tk.BooleanVar(value=False)
        self.show_window_view = tk.BooleanVar(value=False)
        self.grid_color_index = 1 
        self.window_view_tile_x = 0
        self.window_view_tile_y = 0
        self.window_view_tile_w = tk.IntVar(value=DEFAULT_WIN_VIEW_WIDTH_TILES)
        self.window_view_tile_h = tk.IntVar(value=DEFAULT_WIN_VIEW_HEIGHT_TILES)
        self.tile_limit_var = tk.IntVar(value=MAX_TILES)

        # Variables for the Supertile limit feature
        self.project_supertile_limit = MAX_SUPERTILES
        self.supertile_limit_var = tk.IntVar(value=MAX_SUPERTILES)
    
        self.window_view_resize_handle = None
        self.drag_start_x = 0 
        self.drag_start_y = 0
        self.drag_start_win_tx = 0
        self.drag_start_win_ty = 0
        self.drag_start_win_tw = 0
        self.drag_start_win_th = 0
        self.map_controls_min_width = 0 

        self.minimap_window = None
        self.minimap_canvas = None
        self.MINIMAP_VIEWPORT_COLOR = "#FF0000"
        self.MINIMAP_WIN_VIEW_COLOR = "#0000FF"
        self.minimap_background_cache = None
        self.minimap_bg_rendered_width = 0
        self.minimap_bg_rendered_height = 0
        self.minimap_resize_timer = None
        self._minimap_resizing_internally = False

        self.is_ctrl_pressed = False
        self.is_alt_pressed = False
        self.current_mouse_action = None 
        self.pan_start_x = 0
        self.pan_start_y = 0
        self.last_placed_supertile_cell = None 
        self.is_shift_pressed = False

        self.map_selection_active = False
        self.map_selection_rect_id = None
        self.map_selection_start_st = None
        self.map_selection_end_st = None
        self.map_clipboard_data = None
        self.map_paste_preview_rect_id = None
        
        self.edit_menu = None 
        self.copy_menu_item_index = -1
        self.paste_menu_item_index = -1
        self.recent_projects_menu = None
        self.recent_modules_menu = None

        self.marked_unused_tiles = set()
        self.marked_unused_supertiles = set()
        self.highlighted_map_cells = set()

        self.rom_import_dialog = None
        self.color_usage_window = None
        self.tile_usage_window = None
        self.supertile_usage_window = None 

        # --- Load settings, which will be used later ---
        self._load_app_settings()

        # --- Create ALL UI widgets and bind events BEFORE loading data ---
        self.create_menu()
        self._setup_global_key_bindings()

        self.notebook = ttk.Notebook(root) 
        self.notebook.pack(pady=10, padx=10, expand=True, fill="both")
        self.tab_palette_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_tile_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_supertile_editor = ttk.Frame(self.notebook, padding="10")
        self.tab_map_editor = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(self.tab_palette_editor, text="Palette Editor")
        self.notebook.add(self.tab_tile_editor, text="Tile Editor")
        self.notebook.add(self.tab_supertile_editor, text="Supertile Editor")
        self.notebook.add(self.tab_map_editor, text="Map Editor")

        self.create_palette_editor_widgets(self.tab_palette_editor)
        self.create_tile_editor_widgets(self.tab_tile_editor)
        self.create_supertile_editor_widgets(self.tab_supertile_editor)
        self.create_map_editor_widgets(self.tab_map_editor) 
        
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_change)
        self._setup_map_canvas_bindings() 
        self.root.protocol("WM_DELETE_WINDOW", self.confirm_quit)
        self.root.bind("<Configure>", self._on_main_window_configure)

        # This ensures methods like _clear_map_selection have access to self.map_canvas
        self._perform_initial_project_setup()
        
        # --- Final UI State Updates & Refresh ---
        self._update_window_title() 
        self.update_all_displays(changed_level="all") 
        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()
        self._update_map_cursor()
        
        self._restore_window_states()
        
        # --- Restore Geometry and Sash Positions ---
        if 'main_window_geometry' in self.app_settings and self.app_settings['main_window_geometry']:
            try:
                self.root.state('normal')
                self.root.geometry(self.app_settings['main_window_geometry'])
            except tk.TclError as e:
                _error(f"Could not apply main window geometry: {e}")
        
        # This update allows the geometry manager to process the main window size
        self.root.update_idletasks()

        # Restore ST sash by temporarily setting the paned window's width
        st_sash_pos = self.app_settings.get('st_editor_sash_pos')
        st_pane_width = self.app_settings.get('st_editor_pane_width')
        if st_sash_pos is not None and st_pane_width is not None:
            try:
                if hasattr(self, 'st_editor_paned_window') and self.st_editor_paned_window.winfo_exists():
                    # Temporarily give the widget its saved size
                    self.st_editor_paned_window.config(width=st_pane_width)
                    # Force an update so the width is recognized
                    self.st_editor_paned_window.update_idletasks()
                    # Now set the sash position, which will work correctly
                    self.st_editor_paned_window.sashpos(0, st_sash_pos)
                    _debug(f" Applied ST sash: pos={st_sash_pos} with temp width={st_pane_width}")
            except (tk.TclError, KeyError) as e:
                _error(f"Could not apply supertile editor sash position: {e}")

        # Restore Map sash (this one is simpler and should still work directly)
        if 'map_editor_sash_pos' in self.app_settings and self.app_settings['map_editor_sash_pos']:
            try:
                if hasattr(self, 'map_paned_window') and self.map_paned_window.winfo_exists():
                    self.map_paned_window.sashpos(0, self.app_settings['map_editor_sash_pos'])
            except (tk.TclError, KeyError) as e:
                _error(f"Could not apply map editor sash position: {e}")

        _debug(" TileEditorApp __init__ finished.")

    # --- Palette Conversion Helpers ---
    def _hex_to_rgb7(self, hex_color):
        try:
            if not isinstance(hex_color, str):
                raise TypeError("Input must be a string.")
            if not hex_color.startswith("#") or len(hex_color) != 7:
                raise ValueError(f"Input '{hex_color}' is not a valid #RRGGBB format.")
            lookup_hex = hex_color.lower()
            idx512 = msx2_512_colors_hex.index(lookup_hex)
            return msx2_512_colors_rgb7[idx512]
        except ValueError:
            _warning(f"Could not find exact MSX2 RGB7 mapping for hex '{hex_color}'. Returning (0,0,0).")
            return (0, 0, 0)
        except TypeError as e:
            _error(f"Error in _hex_to_rgb7: Input type error for '{hex_color}'. {e}")
            return (0, 0, 0)
        except Exception as e:
            _error(f"Unexpected error in _hex_to_rgb7 for '{hex_color}': {e}")
            return (0, 0, 0)

    def _rgb7_to_hex(self, r, g, b):
        try:
            safe_r = max(0, min(7, int(r)))
            safe_g = max(0, min(7, int(g)))
            safe_b = max(0, min(7, int(b)))
            r_255 = min(255, safe_r * 36)
            g_255 = min(255, safe_g * 36)
            b_255 = min(255, safe_b * 36)
            hex_color = f"#{r_255:02x}{g_255:02x}{b_255:02x}"
            return hex_color
        except (ValueError, TypeError) as e:
            _error(f"Error in _rgb7_to_hex converting input ({r},{g},{b}): {e}")
            return "#000000"
        except Exception as e:
            _error(f"Unexpected error in _rgb7_to_hex for ({r},{g},{b}): {e}")
            return "#000000"

    # --- Cache Management ---
    def invalidate_tile_cache(self, tile_index):
        keys_to_remove = [k for k in self.tile_image_cache if k[0] == tile_index]
        for key in keys_to_remove:
            self.tile_image_cache.pop(key, None)
        for st_index in range(len(supertiles_data)):
            definition = supertiles_data[st_index]
            used = False
            # Check if definition is valid for current dimensions before iterating
            if len(definition) == self.supertile_grid_height and \
               (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0) :
                for r_st_def in range(self.supertile_grid_height):
                    # Ensure row exists (it should if height check passed)
                    if r_st_def < len(definition):
                        for c_st_def in range(self.supertile_grid_width):
                             # Ensure column exists within row
                            if c_st_def < len(definition[r_st_def]):
                                if definition[r_st_def][c_st_def] == tile_index:
                                    used = True
                                    break
                            else: # Should not happen if width check above is good
                                _warning(f"Invalidate tile cache, ST {st_index} row {r_st_def} too short for width {self.supertile_grid_width}")
                                break
                    else: # Should not happen if height check passed
                        _warning(f"Invalidate tile cache, ST {st_index} definition too short for height {self.supertile_grid_height}")
                        break
                    if used:
                        break
            else:
                # This case indicates an inconsistency between self.supertile_grid_width/height
                # and the actual structure of supertiles_data[st_index].
                # This might happen if dimensions change but data isn't properly migrated/reinitialized.
                # For now, we'll skip invalidating supertile cache if the structure is unexpected,
                # or one could choose to invalidate all supertile caches as a precaution.
                _error(f"Supertile {st_index} definition dimensions mismatch project settings during tile cache invalidation. Skipping ST cache invalidation for this ST.")
                pass # Or: self.invalidate_supertile_cache(st_index) if aggressive


            if used:
                self.invalidate_supertile_cache(st_index)

    def invalidate_supertile_cache(self, supertile_index):
        keys_to_remove_st_img = [
            k for k in self.supertile_image_cache if k[0] == supertile_index
        ]
        for key_st_img in keys_to_remove_st_img:
            self.supertile_image_cache.pop(key_st_img, None)

        # Also invalidate corresponding entries in map_render_cache
        keys_to_remove_map_render = [
            k for k in self.map_render_cache if k[0] == supertile_index
        ]
        for key_map_render in keys_to_remove_map_render:
            self.map_render_cache.pop(key_map_render, None)

    def clear_all_caches(self):
        self.tile_image_cache.clear()
        self.supertile_image_cache.clear()
        self.map_render_cache.clear() # Added to clear the new map render cache

    # --- Image Generation ---
    def create_tile_image(self, tile_index, size):
        cache_key = (tile_index, size)
        if cache_key in self.tile_image_cache:
            return self.tile_image_cache[cache_key]
        render_size = max(1, int(size))
        img = tk.PhotoImage(width=render_size, height=render_size)
        if not (0 <= tile_index < len(tileset_patterns)):
            img.put(INVALID_TILE_COLOR, to=(0, 0, render_size, render_size))
            self.tile_image_cache[cache_key] = img
            return img
        pattern = tileset_patterns[tile_index]
        colors = tileset_colors[tile_index]
        pixel_w_ratio = TILE_WIDTH / render_size
        pixel_h_ratio = TILE_HEIGHT / render_size
        for y in range(render_size):
            tile_r = min(TILE_HEIGHT - 1, int(y * pixel_h_ratio))
            try:
                fg_idx, bg_idx = colors[tile_r]
                fg_color = self.active_msx_palette[fg_idx]
                bg_color = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color, bg_color = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            row_colors_hex = []
            for x in range(render_size):
                tile_c = min(TILE_WIDTH - 1, int(x * pixel_w_ratio))
                try:
                    pixel_val = pattern[tile_r][tile_c]
                except IndexError:
                    pixel_val = 0
                color_hex = fg_color if pixel_val == 1 else bg_color
                row_colors_hex.append(color_hex)
            try:
                img.put("{" + " ".join(row_colors_hex) + "}", to=(0, y))
            except tk.TclError as e:
                print(
                    f"Warning [create_tile_image]: TclError tile {tile_index} size {size} row {y}: {e}"
                )
                if row_colors_hex:
                    img.put(row_colors_hex[0], to=(0, y, render_size, y + 1))
        self.tile_image_cache[cache_key] = img
        return img

    def create_supertile_image(self, supertile_index, target_preview_width, target_preview_height): # Renamed parameters
        # Ensure target dimensions are at least 1x1
        safe_target_preview_width = max(1, int(target_preview_width))
        safe_target_preview_height = max(1, int(target_preview_height))

        # Cache key now includes actual target dimensions and source supertile grid dimensions
        cache_key = (supertile_index, safe_target_preview_width, safe_target_preview_height, self.supertile_grid_width, self.supertile_grid_height)
        if cache_key in self.supertile_image_cache: # Use supertile_image_cache
            return self.supertile_image_cache[cache_key]

        img = tk.PhotoImage(width=safe_target_preview_width, height=safe_target_preview_height)

        if not (0 <= supertile_index < len(supertiles_data)):
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img

        definition = supertiles_data[supertile_index]
        src_st_tile_grid_w = self.supertile_grid_width
        src_st_tile_grid_h = self.supertile_grid_height

        if src_st_tile_grid_w <= 0 or src_st_tile_grid_h <= 0:
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img
        
        if len(definition) != src_st_tile_grid_h or \
           (src_st_tile_grid_h > 0 and (len(definition[0]) != src_st_tile_grid_w)):
            _warning(f"Supertile {supertile_index} internal dim mismatch for create_supertile_image. Expected {src_st_tile_grid_w}x{src_st_tile_grid_h}")
            img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
            self.supertile_image_cache[cache_key] = img
            return img

        # --- Letterboxing/Pillarboxing logic REMOVED ---
        # The image is created with exact target dimensions, and we render directly into it.

        # Pixels of one original base tile (e.g., 8x8) when rendered within the target_preview_width/height
        output_pixels_per_base_tile_w = safe_target_preview_width / src_st_tile_grid_w
        output_pixels_per_base_tile_h = safe_target_preview_height / src_st_tile_grid_h
        
        # Heuristic: if rendering a source tile column/row to less than 1 pixel on average.
        if safe_target_preview_width < src_st_tile_grid_w or safe_target_preview_height < src_st_tile_grid_h:
             img.put(INVALID_SUPERTILE_COLOR, to=(0, 0, safe_target_preview_width, safe_target_preview_height))
             self.supertile_image_cache[cache_key] = img
             return img

        # Ratio of source base tile pixels (e.g., TILE_WIDTH) to its display size in the preview.
        src_pixels_per_output_pixel_w_ratio = TILE_WIDTH / output_pixels_per_base_tile_w if output_pixels_per_base_tile_w > 1e-9 else float('inf')
        src_pixels_per_output_pixel_h_ratio = TILE_HEIGHT / output_pixels_per_base_tile_h if output_pixels_per_base_tile_h > 1e-9 else float('inf')

        for y_out_preview in range(safe_target_preview_height):
            row_colors_hex_preview = []
            for x_out_preview in range(safe_target_preview_width):
                src_base_tile_c_in_st_grid_preview = min(src_st_tile_grid_w - 1, int(x_out_preview / output_pixels_per_base_tile_w))
                src_base_tile_r_in_st_grid_preview = min(src_st_tile_grid_h - 1, int(y_out_preview / output_pixels_per_base_tile_h))

                x_in_scaled_base_tile_area_preview = (x_out_preview / output_pixels_per_base_tile_w - src_base_tile_c_in_st_grid_preview) * output_pixels_per_base_tile_w
                y_in_scaled_base_tile_area_preview = (y_out_preview / output_pixels_per_base_tile_h - src_base_tile_r_in_st_grid_preview) * output_pixels_per_base_tile_h
                
                src_pixel_c_in_base_tile_preview = min(TILE_WIDTH - 1, int(x_in_scaled_base_tile_area_preview * src_pixels_per_output_pixel_w_ratio))
                src_pixel_r_in_base_tile_preview = min(TILE_HEIGHT - 1, int(y_in_scaled_base_tile_area_preview * src_pixels_per_output_pixel_h_ratio))

                pixel_color_hex_final_preview = INVALID_TILE_COLOR

                try:
                    tile_idx_from_st_def_preview = definition[src_base_tile_r_in_st_grid_preview][src_base_tile_c_in_st_grid_preview]
                    if 0 <= tile_idx_from_st_def_preview < len(tileset_patterns):
                        if not (0 <= src_pixel_r_in_base_tile_preview < TILE_HEIGHT and \
                                len(tileset_patterns[tile_idx_from_st_def_preview]) > src_pixel_r_in_base_tile_preview and \
                                0 <= src_pixel_c_in_base_tile_preview < TILE_WIDTH and \
                                len(tileset_patterns[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview]) > src_pixel_c_in_base_tile_preview and \
                                len(tileset_colors[tile_idx_from_st_def_preview]) > src_pixel_r_in_base_tile_preview):
                            pixel_color_hex_final_preview = INVALID_TILE_COLOR
                        else:
                            pattern_pixel_val_preview = tileset_patterns[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview][src_pixel_c_in_base_tile_preview]
                            fg_idx_val_preview, bg_idx_val_preview = tileset_colors[tile_idx_from_st_def_preview][src_pixel_r_in_base_tile_preview]
                            
                            if not (0 <= fg_idx_val_preview < len(self.active_msx_palette) and 0 <= bg_idx_val_preview < len(self.active_msx_palette)):
                                fg_color_preview = INVALID_TILE_COLOR; bg_color_preview = INVALID_TILE_COLOR
                            else:
                                fg_color_preview = self.active_msx_palette[fg_idx_val_preview]
                                bg_color_preview = self.active_msx_palette[bg_idx_val_preview]
                            pixel_color_hex_final_preview = fg_color_preview if pattern_pixel_val_preview == 1 else bg_color_preview
                except IndexError:
                    pixel_color_hex_final_preview = INVALID_TILE_COLOR
                
                row_colors_hex_preview.append(pixel_color_hex_final_preview)
            
            try:
                if safe_target_preview_width > 0:
                    img.put("{" + " ".join(row_colors_hex_preview) + "}", to=(0, y_out_preview))
            except tk.TclError as e:
                if row_colors_hex_preview and safe_target_preview_width > 0:
                    img.put(row_colors_hex_preview[0], to=(0, y_out_preview, safe_target_preview_width, y_out_preview + 1))
        
        self.supertile_image_cache[cache_key] = img # Store in the original cache
        return img

    # --- Menu Creation ---
    def create_menu(self):
        # Creates the main application menu bar and its items.
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        self.file_menu = tk.Menu(menubar, tearoff=0) # Store a reference to the file menu
        menubar.add_cascade(label="File", menu=self.file_menu)
        self.file_menu.add_command(
            label="New Project (All)", command=self._handle_new_project_action, accelerator="Ctrl+N"
        )
        self.file_menu.add_separator()
        self.file_menu.add_command(
            label="Open Project...", command=self._handle_open_project_action, accelerator="Ctrl+O"
        )
        self.file_menu.add_command(
            label="Save Project", command=self.save_project, accelerator="Ctrl+S"
        )
        self.file_menu.add_command(
            label="Save Project As...",
            command=self.save_project_as,
            accelerator="Ctrl+Shift+S",
        )
        self.file_menu.add_separator()
        self.file_menu.add_command(
            label="Open Palette...", command=self.open_palette 
        )
        self.file_menu.add_command(
            label="Save Palette...", command=self.save_palette
        )
        self.file_menu.add_separator()
        self.file_menu.add_command(
            label="Open Tileset...", command=self.open_tileset
        )
        self.file_menu.add_command(
            label="Save Tileset...", command=self.save_tileset
        )
        self.file_menu.add_separator()
        self.file_menu.add_command(
            label="Open Supertiles...", command=self.open_supertiles
        )
        self.file_menu.add_command(
            label="Save Supertiles...", command=self.save_supertiles
        )
        self.file_menu.add_separator()
        self.file_menu.add_command(label="Open Map...", command=self.open_map)
        self.file_menu.add_command(label="Save Map...", command=self.save_map)
        self.file_menu.add_separator()
        self.recent_projects_menu = tk.Menu(self.file_menu, tearoff=0)
        self.file_menu.add_cascade(label="Open Recent Projects", menu=self.recent_projects_menu, accelerator="Ctrl+R")
        self.recent_modules_menu = tk.Menu(self.file_menu, tearoff=0)
        self.file_menu.add_cascade(label="Open Recent Modules", menu=self.recent_modules_menu, accelerator="Alt+R")
        self._update_recent_files_menu()
        self.file_menu.add_separator()
        self.file_menu.add_command(
            label="Exit", command=self.confirm_quit, accelerator="Ctrl+Q"
        )

        self.edit_menu = tk.Menu(menubar, tearoff=0) 
        menubar.add_cascade(label="Edit", menu=self.edit_menu)
        self.edit_menu.add_command(
            label="Copy",
            command=self.handle_generic_copy,
            state=tk.DISABLED,
            accelerator="Ctrl+C",
        )
        self.copy_menu_item_index = 0 
        self.edit_menu.add_command(
            label="Paste",
            command=self.handle_generic_paste,
            state=tk.DISABLED,
            accelerator="Ctrl+V",
        )
        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Undo",
            command=self.undo_manager.undo,
            state=tk.DISABLED,
            accelerator="Ctrl+Z"
        )
        self.edit_menu.add_command(
            label="Redo",
            command=self.undo_manager.redo,
            state=tk.DISABLED,
            accelerator="Ctrl+Y"
        )
        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Clear Current Tile", command=self.clear_current_tile
        )
        self.edit_menu.add_command(
            label="Clear Current Supertile", command=self.clear_current_supertile
        )
        self.edit_menu.add_command(label="Clear Map", command=self.clear_map)
        self.edit_menu.add_separator()
        self.edit_menu.add_command(
            label="Set Map Dimensions...", command=self.set_map_dimensions
        ) 

        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_command(
            label="Show/Hide Minimap", command=self.toggle_minimap, accelerator="Ctrl+M"
        )
        view_menu.add_separator() 
        view_menu.add_command(label="Color Usage", command=self.toggle_color_usage_window, accelerator="F1")
        view_menu.add_command(label="Tile Usage", command=self.toggle_tile_usage_window, accelerator="F2")
        view_menu.add_command(label="Supertile Usage", command=self.toggle_supertile_usage_window, accelerator="F3")

        import_export_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Import/Export", menu=import_export_menu)
        import_export_menu.add_command(
            label="Create Project from Image...",
            command=self.handle_import_project_from_image
        )
        import_export_menu.add_separator()
        import_export_menu.add_command(
            label="Import Tiles from ROM...", 
            command=self.open_rom_importer
        )
        import_export_menu.add_command(
            label="Import Tiles from Image...",
            command=self.import_tiles_from_image
        )
        import_export_menu.add_command(
            label="Import Tiles from File...", 
            command=self.handle_import_tiles_from_file
        )
        #import_export_menu.add_separator()
        #import_export_menu.add_command(
        #    label="Append Supertiles from File...", 
        #        command=self.append_supertiles_from_file
        #)
        import_export_menu.add_separator()
        import_export_menu.add_command(
            label="Export Raw Project...",
            command=self.handle_export_raw
        )

        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About...", command=self.show_about_box)

    # --- Widget Creation ---
    def create_palette_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")
        left_frame = ttk.Frame(main_frame, padding=5)
        left_frame.grid(row=0, column=0, sticky="ns")
        right_frame = ttk.Frame(main_frame, padding=5)
        right_frame.grid(row=0, column=1, sticky="nsew")
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=0)
        main_frame.grid_columnconfigure(1, weight=1)
        
        # --- Left Frame Contents ---
        current_palette_frame = ttk.LabelFrame(left_frame, text="Active Palette (16 colors)")
        current_palette_frame.pack(pady=(0, 10), fill="x")
        cp_canvas_width = 4 * (CURRENT_PALETTE_SLOT_SIZE + 2) + 2
        cp_canvas_height = 4 * (CURRENT_PALETTE_SLOT_SIZE + 2) + 2
        self.current_palette_canvas = tk.Canvas(current_palette_frame, width=cp_canvas_width, height=cp_canvas_height, borderwidth=0, highlightthickness=0)
        self.current_palette_canvas.pack()
        self.current_palette_canvas.bind("<Button-1>", self.handle_current_palette_click)
        self.current_palette_canvas.bind("<B1-Motion>", self.handle_palette_drag_motion)
        self.current_palette_canvas.bind("<ButtonRelease-1>", self.handle_palette_drag_release)
        self.current_palette_canvas.bind("<Motion>", self._handle_palette_tooltip_motion)
        self.current_palette_canvas.bind("<Leave>", self._hide_color_tooltip)

        info_frame = ttk.LabelFrame(left_frame, text="Selected Slot Info")
        info_frame.pack(pady=(0, 10), fill="x")
        preview_canvas_size = 48 
        self.selected_color_preview_canvas = tk.Canvas(info_frame, width=preview_canvas_size, height=preview_canvas_size, bg="darkgrey", highlightthickness=0)
        self.selected_color_preview_canvas.grid(row=0, column=0, rowspan=3, padx=5, pady=5)
        self.selected_slot_label = ttk.Label(info_frame, text="Slot: 0")
        self.selected_slot_label.grid(row=0, column=1, padx=(0, 5), sticky="sw")
        self.selected_slot_rgb_label = ttk.Label(info_frame, text="RGB: #000000")
        self.selected_slot_rgb_label.grid(row=1, column=1, padx=(0, 5), sticky="nw")
        self.selected_color_usage_label = tk.Label(info_frame, text="Usage: N/A", anchor="w", justify=tk.LEFT)
        self.selected_color_usage_label.grid(row=2, column=1, padx=(0, 5), sticky="nw")
        self.selected_color_usage_label.bind("<Button-1>", self._handle_usage_label_click)
        info_frame.grid_rowconfigure(0, weight=1); info_frame.grid_rowconfigure(1, weight=1); info_frame.grid_rowconfigure(2, weight=1)
        info_frame.grid_columnconfigure(1, weight=1)

        # --- New consolidated frame for setting colors ---
        set_color_frame = ttk.LabelFrame(left_frame, text="Set Selected Color")
        set_color_frame.pack(pady=(0, 10), fill="x")

        # Row 1: Preview Canvases
        preview_frame = ttk.Frame(set_color_frame, padding=(5, 5, 5, 0))
        preview_frame.pack(fill="x") # Let it fill horizontally to the compact width
        preview_frame.grid_columnconfigure(0, weight=1)
        preview_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(preview_frame, text="MSX2 (9 bits)", font=("TkSmallCaptionFont",)).grid(row=0, column=0)
        ttk.Label(preview_frame, text="RGB (24 bits)", font=("TkSmallCaptionFont",)).grid(row=0, column=1)

        preview_canvas_container = ttk.Frame(preview_frame)
        preview_canvas_container.grid(row=1, column=0, columnspan=2, sticky="ew")
        preview_canvas_container.grid_columnconfigure(0, weight=1)
        preview_canvas_container.grid_columnconfigure(1, weight=1)
        
        self.msx2_color_preview_canvas = tk.Canvas(preview_canvas_container, height=50, width=100, bg="black", highlightthickness=0)
        self.msx2_color_preview_canvas.pack(side="left")
        self.hex24_color_preview_canvas = tk.Canvas(preview_canvas_container, height=50, width=100, bg="black", highlightthickness=0)
        self.hex24_color_preview_canvas.pack(side="left")

        # Container for aligned input rows
        input_container_frame = ttk.Frame(set_color_frame, padding=5)
        input_container_frame.pack(pady=5) # pack without fill/expand
        
        # Validation commands
        vcmd_9bit = (self.root.register(self._validate_9bit_input), '%P')
        vcmd_24bit = (self.root.register(self._validate_24bit_input), '%P')

        # Row 2: 9-bit (MSX2) RGB Inputs
        ttk.Label(input_container_frame, text="MSX (0-7)").grid(row=0, column=0, columnspan=6, sticky="w")
        ttk.Label(input_container_frame, text="R:").grid(row=1, column=0, sticky="e", padx=(0,2))
        self.rgb9_r_var = tk.StringVar()
        rgb9_r_entry = ttk.Entry(input_container_frame, textvariable=self.rgb9_r_var, width=4, justify='center', validate='key', validatecommand=vcmd_9bit)
        rgb9_r_entry.grid(row=1, column=1)
        ttk.Label(input_container_frame, text="G:").grid(row=1, column=2, sticky="e", padx=(5,2))
        self.rgb9_g_var = tk.StringVar()
        rgb9_g_entry = ttk.Entry(input_container_frame, textvariable=self.rgb9_g_var, width=4, justify='center', validate='key', validatecommand=vcmd_9bit)
        rgb9_g_entry.grid(row=1, column=3)
        ttk.Label(input_container_frame, text="B:").grid(row=1, column=4, sticky="e", padx=(5,2))
        self.rgb9_b_var = tk.StringVar()
        rgb9_b_entry = ttk.Entry(input_container_frame, textvariable=self.rgb9_b_var, width=4, justify='center', validate='key', validatecommand=vcmd_9bit)
        rgb9_b_entry.grid(row=1, column=5)

        # Row 3: 24-bit (Standard) RGB Inputs
        ttk.Label(input_container_frame, text="RGB (0-255)").grid(row=2, column=0, columnspan=6, sticky="w", pady=(5,0))
        ttk.Label(input_container_frame, text="R:").grid(row=3, column=0, sticky="e", padx=(0,2))
        self.rgb24_r_var = tk.StringVar()
        rgb24_r_entry = ttk.Entry(input_container_frame, textvariable=self.rgb24_r_var, width=4, justify='center', validate='key', validatecommand=vcmd_24bit)
        rgb24_r_entry.grid(row=3, column=1)
        ttk.Label(input_container_frame, text="G:").grid(row=3, column=2, sticky="e", padx=(5,2))
        self.rgb24_g_var = tk.StringVar()
        rgb24_g_entry = ttk.Entry(input_container_frame, textvariable=self.rgb24_g_var, width=4, justify='center', validate='key', validatecommand=vcmd_24bit)
        rgb24_g_entry.grid(row=3, column=3)
        ttk.Label(input_container_frame, text="B:").grid(row=3, column=4, sticky="e", padx=(5,2))
        self.rgb24_b_var = tk.StringVar()
        rgb24_b_entry = ttk.Entry(input_container_frame, textvariable=self.rgb24_b_var, width=4, justify='center', validate='key', validatecommand=vcmd_24bit)
        rgb24_b_entry.grid(row=3, column=5)

        # Row 4 & 5: Action Buttons
        ttk.Button(set_color_frame, text="Set Color", command=self.handle_rgb_apply, width=28).pack(padx=5, pady=(5,2))
        ttk.Button(set_color_frame, text="Reset to MSX2 Default", command=self.reset_palette_to_default, width=28).pack(padx=5, pady=(2,5))
        
        # --- Bindings for Coercion and Tracing ---
        rgb9_entries = (rgb9_r_entry, rgb9_g_entry, rgb9_b_entry)
        rgb24_entries = (rgb24_r_entry, rgb24_g_entry, rgb24_b_entry)
        for var, entry in zip((self.rgb9_r_var, self.rgb9_g_var, self.rgb9_b_var), rgb9_entries):
            entry.bind("<FocusOut>", lambda e, v=var, t="9bit": self._handle_color_input_coerce(v, t))
        for var, entry in zip((self.rgb24_r_var, self.rgb24_g_var, self.rgb24_b_var), rgb24_entries):
            entry.bind("<FocusOut>", lambda e, v=var, t="24bit": self._handle_color_input_coerce(v, t))
        self.rgb9_r_var.trace_add("write", lambda *args: self._on_9bit_input_change())
        self.rgb9_g_var.trace_add("write", lambda *args: self._on_9bit_input_change())
        self.rgb9_b_var.trace_add("write", lambda *args: self._on_9bit_input_change())
        self.rgb24_r_var.trace_add("write", lambda *args: self._on_24bit_input_change())
        self.rgb24_g_var.trace_add("write", lambda *args: self._on_24bit_input_change())
        self.rgb24_b_var.trace_add("write", lambda *args: self._on_24bit_input_change())
        
        # --- Right Frame Contents ---
        picker_frame = ttk.LabelFrame(right_frame, text="MSX2 512 Color Picker")
        picker_frame.pack(expand=True, fill="both")
        picker_canvas_width = MSX2_PICKER_COLS * (MSX2_PICKER_SQUARE_SIZE + 1) + 1
        picker_canvas_height = MSX2_PICKER_ROWS * (MSX2_PICKER_SQUARE_SIZE + 1) + 1
        picker_hbar = ttk.Scrollbar(picker_frame, orient=tk.HORIZONTAL)
        picker_vbar = ttk.Scrollbar(picker_frame, orient=tk.VERTICAL)
        self.msx2_picker_canvas = tk.Canvas(picker_frame, bg="lightgrey", scrollregion=(0, 0, picker_canvas_width, picker_canvas_height), xscrollcommand=picker_hbar.set, yscrollcommand=picker_vbar.set)
        picker_hbar.config(command=self.msx2_picker_canvas.xview)
        picker_vbar.config(command=self.msx2_picker_canvas.yview)
        self.msx2_picker_canvas.grid(row=0, column=0, sticky="nsew")
        picker_vbar.grid(row=0, column=1, sticky="ns")
        picker_hbar.grid(row=1, column=0, sticky="ew")
        picker_frame.grid_rowconfigure(0, weight=1)
        picker_frame.grid_columnconfigure(0, weight=1)
        self.msx2_picker_canvas.bind("<Button-1>", self.handle_512_picker_click)
        self.msx2_picker_canvas.bind("<Motion>", self._handle_picker_tooltip_motion)
        self.msx2_picker_canvas.bind("<Leave>", self._hide_color_tooltip)
        self.draw_512_picker()
   

    def _validate_9bit_input(self, P):
        """Validation command for 9-bit (0-7) RGB Entry widgets."""
        if P == "":
            return True
        if P.isdigit() and len(P) == 1:
            return True
        return False

    def _validate_24bit_input(self, P):
        """Validation command for 24-bit (0-255) RGB Entry widgets."""
        if P == "":
            return True
        if P.isdigit() and len(P) <= 3:
            return True
        return False

    def _handle_color_input_coerce(self, string_var, input_type):
        """Coerces out-of-range values when an Entry widget loses focus."""
        if self._is_updating_color_inputs:
            return
        try:
            current_val_str = string_var.get()
            if not current_val_str:
                string_var.set("0")
                return

            val = int(current_val_str)
            if input_type == "9bit":
                if val > 7:
                    string_var.set("7")
            elif input_type == "24bit":
                if val > 255:
                    string_var.set("255")
        except (ValueError, tk.TclError):
            # If value is invalid for some reason, reset to 0
            if input_type == "9bit": string_var.set("0")
            if input_type == "24bit": string_var.set("0")

    def _on_9bit_input_change(self):
        """Trace callback for when a 9-bit (MSX) RGB value is changed."""
        if self._is_updating_color_inputs:
            return
        self._is_updating_color_inputs = True
        try:
            r9 = int(self.rgb9_r_var.get() or 0)
            g9 = int(self.rgb9_g_var.get() or 0)
            b9 = int(self.rgb9_b_var.get() or 0)

            # Convert 0-7 range to 0-255 range
            r24 = min(255, r9 * 36)
            g24 = min(255, g9 * 36)
            b24 = min(255, b9 * 36)

            self.rgb24_r_var.set(str(r24))
            self.rgb24_g_var.set(str(g24))
            self.rgb24_b_var.set(str(b24))

            msx2_hex = self._rgb7_to_hex(r9, g9, b9)
            self.msx2_color_preview_canvas.config(bg=msx2_hex)
            self.hex24_color_preview_canvas.config(bg=msx2_hex) # For 9->24 bit, they are the same
        except (ValueError, tk.TclError):
            pass # Ignore errors during typing
        finally:
            self._is_updating_color_inputs = False

    def _on_24bit_input_change(self):
        """Trace callback for when a 24-bit (Standard) RGB value is changed."""
        if self._is_updating_color_inputs:
            return
        self._is_updating_color_inputs = True
        try:
            r24 = int(self.rgb24_r_var.get() or 0)
            g24 = int(self.rgb24_g_var.get() or 0)
            b24 = int(self.rgb24_b_var.get() or 0)

            user_hex = f"#{r24:02x}{g24:02x}{b24:02x}"
            self.hex24_color_preview_canvas.config(bg=user_hex)

            # Find closest MSX2 color
            r9, g9, b9 = self._find_closest_msx2_color(user_hex)

            self.rgb9_r_var.set(str(r9))
            self.rgb9_g_var.set(str(g9))
            self.rgb9_b_var.set(str(b9))
            
            msx2_hex = self._rgb7_to_hex(r9, g9, b9)
            self.msx2_color_preview_canvas.config(bg=msx2_hex)
        except (ValueError, tk.TclError):
            pass # Ignore errors during typing
        finally:
            self._is_updating_color_inputs = False

    def _handle_palette_tooltip_motion(self, event):
        """Shows and updates the color tooltip for the active 16-color palette."""
        canvas = event.widget
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        
        if 0 <= col < 4 and 0 <= row < 4:
            slot_idx = row * 4 + col
            if 0 <= slot_idx < len(self.active_msx_palette):
                hex_color = self.active_msx_palette[slot_idx]
                r9,g9,b9 = self._hex_to_rgb7(hex_color)
                r24, g24, b24 = int(hex_color[1:3], 16), int(hex_color[3:5], 16), int(hex_color[5:7], 16)
                tooltip_text = (
                    f"Slot: {slot_idx}\n"
                    f"MSX (9-bit): {r9},{g9},{b9}\n"
                    f"RGB (24-bit): {r24},{g24},{b24}"
                )
                self.color_tooltip.show(tooltip_text, event.x_root, event.y_root)
                return

        self.color_tooltip.hide()

    def _handle_picker_tooltip_motion(self, event):
        """Shows and updates the color tooltip for the 512-color picker."""
        canvas = event.widget
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS
        
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)
        col = int(canvas_x // (size + padding))
        row = int(canvas_y // (size + padding))

        if 0 <= col < MSX2_PICKER_COLS:
            color_idx = row * cols + col
            if 0 <= color_idx < len(msx2_512_colors_hex):
                hex_color = msx2_512_colors_hex[color_idx]
                r9,g9,b9 = msx2_512_colors_rgb7[color_idx]
                r24, g24, b24 = int(hex_color[1:3], 16), int(hex_color[3:5], 16), int(hex_color[5:7], 16)
                tooltip_text = (
                    f"Index: {color_idx}\n"
                    f"MSX (9-bit): {r9},{g9},{b9}\n"
                    f"RGB (24-bit): {r24},{g24},{b24}"
                )
                self.color_tooltip.show(tooltip_text, event.x_root, event.y_root)
                return
                
        self.color_tooltip.hide()

    def _hide_color_tooltip(self, event=None):
        """Event handler to explicitly hide the color tooltip."""
        self.color_tooltip.hide()

    def create_tile_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")

        # Left Frame (Editor, Attributes, Transform)
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=tk.N, padx=(0, 10))

        editor_frame = ttk.LabelFrame(
            left_frame, text="Tile Editor (Left: FG, Right: BG)"
        )
        editor_frame.grid(row=0, column=0, pady=(0, 10), sticky="ew") 
        
        self.editor_canvas = tk.Canvas(
            editor_frame,
            width=TILE_WIDTH * EDITOR_PIXEL_SIZE,
            height=TILE_HEIGHT * EDITOR_PIXEL_SIZE,
            bg="grey",
        )
        self.editor_canvas.grid(row=0, column=0, sticky=tk.NSEW) 
        editor_frame.grid_rowconfigure(0, weight=1) 
        editor_frame.grid_columnconfigure(0, weight=0) 

        self.editor_canvas.bind("<Button-1>", self.handle_editor_click)
        self.editor_canvas.bind("<B1-Motion>", self.handle_editor_drag)
        self.editor_canvas.bind(
            "<Button-3>", self.handle_editor_click
        ) 
        self.editor_canvas.bind(
            "<B3-Motion>", self.handle_editor_drag
        ) 
        self.editor_canvas.bind("<Enter>", self._set_pencil_cursor)
        self.editor_canvas.bind("<Leave>", self._reset_cursor)

        self.editor_canvas.bind("<ButtonRelease-1>", self._handle_editor_paint_release, add="+")
        self.editor_canvas.bind("<ButtonRelease-3>", self._handle_editor_paint_release, add="+")

        fg_bg_buttons_container = ttk.Frame(editor_frame)
        fg_bg_buttons_container.grid(row=0, column=1, sticky=(tk.N, tk.S), padx=(10, 0))
        editor_frame.grid_columnconfigure(1, weight=0) 
        
        self.attr_row_frames = [] 
        self.attr_fg_labels = []
        self.attr_bg_labels = []

        for r_idx in range(TILE_HEIGHT):
            row_control_frame = ttk.Frame(fg_bg_buttons_container)
            row_control_frame.grid(row=r_idx, column=0, sticky=tk.EW)
            fg_bg_buttons_container.grid_rowconfigure(r_idx, weight=1) 

            row_control_frame.grid_columnconfigure(0, weight=0)  
            row_control_frame.grid_columnconfigure(1, weight=1)  
            row_control_frame.grid_columnconfigure(2, weight=0)  

            row_num_label = ttk.Label(row_control_frame, text=f"{r_idx}:")
            row_num_label.grid(row=0, column=0, padx=(0, 5), sticky=tk.W)

            fg_label = tk.Label(
                row_control_frame, text=" FG ", width=3, relief="raised", borderwidth=2
            )
            fg_label.grid(row=0, column=1, padx=(0, 2), sticky=tk.E) 
            fg_label.bind("<Button-1>", lambda e, row=r_idx: self.set_row_color(row, "fg"))
            self.attr_fg_labels.append(fg_label)

            bg_label = tk.Label(
                row_control_frame, text=" BG ", width=3, relief="raised", borderwidth=2
            )
            bg_label.grid(row=0, column=2, padx=(2, 0), sticky=tk.W) 
            bg_label.bind("<Button-1>", lambda e, row=r_idx: self.set_row_color(row, "bg"))
            self.attr_bg_labels.append(bg_label)
            
            self.attr_row_frames.append(row_control_frame)

        selected_tile_info_frame = ttk.LabelFrame(left_frame, text="Selected Tile Info")
        selected_tile_info_frame.grid(row=1, column=0, pady=(10, 5), sticky="ew")
        
        self.selected_tile_preview_image_ref = None

        preview_canvas_size = 48 
        self.selected_tile_preview_canvas = tk.Canvas(
            selected_tile_info_frame, 
            width=preview_canvas_size, 
            height=preview_canvas_size, 
            bg="darkgrey",
            highlightthickness=0
        )
        self.selected_tile_preview_canvas.grid(row=0, column=0, rowspan=2, padx=5, pady=5)

        self.selected_tile_info_label = ttk.Label(selected_tile_info_frame, text="Tile: 0")
        self.selected_tile_info_label.grid(row=0, column=1, padx=5, sticky="sw")
        
        self.selected_tile_usage_label = tk.Label(selected_tile_info_frame, text="Used: N/A", anchor="w", justify=tk.LEFT)
        self.selected_tile_usage_label.grid(row=1, column=1, padx=5, sticky="nw")
        self.selected_tile_usage_label.bind("<Button-1>", self._handle_tile_usage_label_click)
        
        selected_tile_info_frame.grid_rowconfigure(0, weight=1)
        selected_tile_info_frame.grid_rowconfigure(1, weight=1)

        transform_frame = ttk.LabelFrame(left_frame, text="Transform")
        transform_frame.grid(row=2, column=0, pady=(0, 5), sticky="ew") 
        
        flip_h_button = ttk.Button(
            transform_frame, text="Flip H", command=self.flip_tile_horizontal
        )
        flip_h_button.grid(row=0, column=0, padx=3, pady=3)
        flip_v_button = ttk.Button(
            transform_frame, text="Flip V", command=self.flip_tile_vertical
        )
        flip_v_button.grid(row=0, column=1, padx=3, pady=3)
        rotate_button = ttk.Button(
            transform_frame, text="Rotate", command=self.rotate_tile_90cw
        )
        rotate_button.grid(row=0, column=2, padx=3, pady=3)
        shift_up_button = ttk.Button(
            transform_frame, text="Shift Up", command=self.shift_tile_up
        )
        shift_up_button.grid(row=1, column=0, padx=3, pady=3)
        shift_down_button = ttk.Button(
            transform_frame, text="Shift Down", command=self.shift_tile_down
        )
        shift_down_button.grid(row=1, column=1, padx=3, pady=3)
        shift_left_button = ttk.Button(
            transform_frame, text="Shift Left", command=self.shift_tile_left
        )
        shift_left_button.grid(row=1, column=2, padx=3, pady=3)
        shift_right_button = ttk.Button(
            transform_frame, text="Shift Right", command=self.shift_tile_right
        )
        shift_right_button.grid(row=1, column=3, padx=3, pady=3)
        
        self.mark_unused_tiles_button = ttk.Button(
            left_frame, text="Mark Unused", command=self.handle_mark_unused_tiles
        )
        self.mark_unused_tiles_button.grid(row=3, column=0, pady=(5, 10), sticky="ew") 

        # Right Frame (Palette, Tileset Viewer, Buttons)
        right_frame = ttk.Frame(main_frame)
        right_frame.grid(
            row=0, column=1, sticky=(tk.N, tk.S, tk.W, tk.E)
        ) 
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_columnconfigure(0, weight=0) 
        main_frame.grid_columnconfigure(1, weight=1) 

        # Change columnconfigure for right_frame to prevent horizontal expansion.
        right_frame.grid_columnconfigure(0, weight=0) # Changed from 1 to 0
        right_frame.grid_rowconfigure(3, weight=1) # Let empty space go to the bottom

        palette_frame = ttk.LabelFrame(
            right_frame, text="Color Selector (Click to select color for FG/BG)"
        )
        palette_frame.grid(row=0, column=0, pady=(0, 10), sticky="nw") # Use "nw" anchor
        self.tile_editor_palette_canvas = tk.Canvas(
            palette_frame,
            width=4 * (PALETTE_SQUARE_SIZE + 2) + 2,
            height=4 * (PALETTE_SQUARE_SIZE + 2) + 2,
            borderwidth=0,
            highlightthickness=0,
        )
        self.tile_editor_palette_canvas.grid(row=0, column=0)
        self.tile_editor_palette_canvas.bind(
            "<Button-1>", self.handle_tile_editor_palette_click
        )
        self.tile_editor_palette_canvas.bind("<Double-Button-1>", self._on_canvas_double_click)

        viewer_frame = ttk.LabelFrame(right_frame, text="Tileset (Click to select for edition)")
        viewer_frame.grid(row=1, column=0, pady=(0,10), sticky="nw") # Use "nw" anchor
        
        right_frame.grid_rowconfigure(0, weight=0) 
        right_frame.grid_rowconfigure(1, weight=0) 
        right_frame.grid_rowconfigure(2, weight=0)

        padding = 1
        num_rows_fixed = 16
        fixed_viewer_width = NUM_TILES_ACROSS * (VIEWER_TILE_SIZE + padding) + padding
        fixed_viewer_height = num_rows_fixed * (VIEWER_TILE_SIZE + padding) + padding
        
        viewer_hbar = ttk.Scrollbar(viewer_frame, orient=tk.HORIZONTAL)
        viewer_vbar = ttk.Scrollbar(viewer_frame, orient=tk.VERTICAL)
        self.tileset_canvas = tk.Canvas(
            viewer_frame,
            bg="lightgrey",
            width=fixed_viewer_width,
            height=fixed_viewer_height,
            xscrollcommand=viewer_hbar.set,
            yscrollcommand=viewer_vbar.set,
        )
        viewer_hbar.config(command=self.tileset_canvas.xview)
        viewer_vbar.config(command=self.tileset_canvas.yview)
        self.tileset_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        viewer_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        viewer_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        viewer_frame.grid_rowconfigure(0, weight=1)
        viewer_frame.grid_columnconfigure(0, weight=1)

        self.tileset_canvas.bind("<Button-1>", self.handle_tileset_click)
        self.tileset_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.tileset_canvas.bind("<ButtonRelease-1>", self.handle_viewer_drag_release)
        self.tileset_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+") 
        self.tileset_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")   
        self.tileset_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")   

        tile_button_frame = ttk.Frame(right_frame)
        tile_button_frame.grid(row=2, column=0, sticky="nw", pady=(5, 0))

        # Row 0: Add buttons and Limit controls
        self.add_tile_button = ttk.Button(tile_button_frame, text="Add New", command=self.handle_add_tile)
        self.add_tile_button.grid(row=0, column=0, padx=(0, 3))

        self.add_many_tiles_button = ttk.Button(tile_button_frame, text="Add Many...", command=self.handle_add_many_tiles)
        self.add_many_tiles_button.grid(row=0, column=1, padx=3)

        self.tile_info_label = ttk.Label(tile_button_frame, text="Tiles: 1 / 256")
        self.tile_info_label.grid(row=0, column=2, padx=(10, 2))

        self.tile_limit_entry = ttk.Entry(tile_button_frame, textvariable=self.tile_limit_var, width=4)
        self.tile_limit_entry.grid(row=0, column=3, padx=2)
        self.tile_limit_entry.bind("<Return>", self._apply_tile_limit_from_entry)

        self.apply_limit_button = ttk.Button(tile_button_frame, text="Set Limit", command=self._apply_tile_limit_from_entry)
        self.apply_limit_button.grid(row=0, column=4, padx=(2, 0))

        # Row 1: Insert and Delete buttons
        self.insert_tile_button = ttk.Button(tile_button_frame, text="Insert", command=self.handle_insert_tile)
        self.insert_tile_button.grid(row=1, column=0, padx=(0, 3), pady=(5, 0))

        self.delete_tile_button = ttk.Button(tile_button_frame, text="Delete", command=self.handle_delete_tile)
        self.delete_tile_button.grid(row=1, column=1, padx=3, pady=(5, 0))

    def create_supertile_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky=tk.N, padx=(0, 10)) 

        def_frame = ttk.LabelFrame(
            left_frame, text="Supertile Definition (Click to place selected tile)"
        )
        def_frame.grid(row=0, column=0, pady=(0, 5), sticky="ew") 
        
        def_canvas_width_actual = self.supertile_grid_width * SUPERTILE_DEF_TILE_SIZE
        def_canvas_height_actual = self.supertile_grid_height * SUPERTILE_DEF_TILE_SIZE
        def_canvas_width_actual = max(SUPERTILE_DEF_TILE_SIZE, def_canvas_width_actual)
        def_canvas_height_actual = max(SUPERTILE_DEF_TILE_SIZE, def_canvas_height_actual)

        self.supertile_def_canvas = tk.Canvas(
            def_frame, width=def_canvas_width_actual, height=def_canvas_height_actual, bg="darkgrey"
        )
        self.supertile_def_canvas.grid(row=0, column=0, sticky="nw") 
        def_frame.grid_rowconfigure(0, weight=0) 
        def_frame.grid_columnconfigure(0, weight=0)

        self.supertile_def_canvas.bind("<Button-1>", self.handle_supertile_def_click)
        self.supertile_def_canvas.bind("<Double-Button-1>", self._on_canvas_double_click)
        self.supertile_def_canvas.bind("<B1-Motion>", self.handle_supertile_def_drag)
        self.supertile_def_canvas.bind(
            "<ButtonRelease-1>", self.handle_supertile_def_release
        )
        self.supertile_def_canvas.bind(
            "<Button-3>", self.handle_supertile_def_right_click
        )
        self.supertile_def_canvas.bind("<Enter>", self._set_pencil_cursor)
        self.supertile_def_canvas.bind("<Leave>", self._reset_cursor)

        st_tab_tile_info_frame = ttk.LabelFrame(left_frame, text="Selected Tile Info")
        st_tab_tile_info_frame.grid(row=1, column=0, pady=(10, 5), sticky="ew")

        self.st_tab_selected_tile_preview_image_ref = None

        preview_canvas_size_tile = 64
        self.st_tab_selected_tile_preview_canvas = tk.Canvas(
            st_tab_tile_info_frame,
            width=preview_canvas_size_tile,
            height=preview_canvas_size_tile,
            bg="darkgrey",
            highlightthickness=0
        )
        self.st_tab_selected_tile_preview_canvas.grid(row=0, column=0, rowspan=3, padx=5, pady=5, sticky="n")

        self.st_tab_selected_tile_info_label = ttk.Label(st_tab_tile_info_frame, text="Tile: 0")
        self.st_tab_selected_tile_info_label.grid(row=0, column=1, padx=5, sticky="nw")

        self.st_tab_global_usage_label = tk.Label(st_tab_tile_info_frame, text="Used: N/A", anchor="w", justify=tk.LEFT)
        self.st_tab_global_usage_label.grid(row=1, column=1, padx=5, sticky="nw")
        self.st_tab_global_usage_label.bind("<Button-1>", self._handle_st_tab_global_usage_click)

        self.st_tab_local_usage_label = ttk.Label(st_tab_tile_info_frame, text="Used in this ST: N/A")
        self.st_tab_local_usage_label.grid(row=2, column=1, padx=5, sticky="nw")

        st_tab_tile_info_frame.grid_rowconfigure(0, weight=1)
        st_tab_tile_info_frame.grid_rowconfigure(1, weight=1)
        st_tab_tile_info_frame.grid_rowconfigure(2, weight=1)

        selected_st_info_frame = ttk.LabelFrame(left_frame, text="Selected Supertile Info")
        selected_st_info_frame.grid(row=2, column=0, pady=(10, 5), sticky="ew")

        self.selected_supertile_preview_image_ref = None

        preview_canvas_size = 64
        self.selected_supertile_preview_canvas = tk.Canvas(
            selected_st_info_frame,
            width=preview_canvas_size,
            height=preview_canvas_size,
            bg="darkgrey",
            highlightthickness=0
        )
        self.selected_supertile_preview_canvas.grid(row=0, column=0, rowspan=3, padx=5, pady=5, sticky="n")

        self.selected_supertile_info_label = ttk.Label(selected_st_info_frame, text="Supertile: 0")
        self.selected_supertile_info_label.grid(row=0, column=1, padx=5, sticky="nw")

        self.selected_supertile_composition_label = ttk.Label(selected_st_info_frame, text="Contains: N/A")
        self.selected_supertile_composition_label.grid(row=1, column=1, padx=5, sticky="nw")
        
        self.selected_supertile_usage_label = tk.Label(selected_st_info_frame, text="Used on Map: N/A", anchor="w", justify=tk.LEFT)
        self.selected_supertile_usage_label.grid(row=2, column=1, padx=5, sticky="nw")
        self.selected_supertile_usage_label.bind("<Button-1>", self._handle_supertile_map_usage_label_click)

        selected_st_info_frame.grid_rowconfigure(0, weight=1)
        selected_st_info_frame.grid_rowconfigure(1, weight=1)
        selected_st_info_frame.grid_rowconfigure(2, weight=1)

        st_transform_frame = ttk.LabelFrame(left_frame, text="Transform Supertile")
        st_transform_frame.grid(
            row=3, column=0, pady=(0, 5), sticky="ew"
        )

        st_flip_h_button = ttk.Button(
            st_transform_frame, text="Flip H", command=self.flip_supertile_horizontal
        )
        st_flip_h_button.grid(row=0, column=0, padx=3, pady=(5, 3))
        st_flip_v_button = ttk.Button(
            st_transform_frame, text="Flip V", command=self.flip_supertile_vertical
        )
        st_flip_v_button.grid(row=0, column=1, padx=3, pady=(5, 3))
        
        self.st_rotate_button = ttk.Button(
            st_transform_frame, text="Rotate", command=self.rotate_supertile_90cw
        )
        self.st_rotate_button.grid(row=0, column=2, padx=3, pady=(5, 3))

        st_shift_up_button = ttk.Button(
            st_transform_frame, text="Shift Up", command=self.shift_supertile_up
        )
        st_shift_up_button.grid(row=1, column=0, padx=3, pady=3)
        st_shift_down_button = ttk.Button(
            st_transform_frame, text="Shift Down", command=self.shift_supertile_down
        )
        st_shift_down_button.grid(row=1, column=1, padx=3, pady=3)
        st_shift_left_button = ttk.Button(
            st_transform_frame, text="Shift Left", command=self.shift_supertile_left
        )
        st_shift_left_button.grid(row=1, column=2, padx=3, pady=3)
        st_shift_right_button = ttk.Button(
            st_transform_frame, text="Shift Right", command=self.shift_supertile_right
        )
        st_shift_right_button.grid(row=1, column=3, padx=3, pady=3)

        self.mark_unused_st_button = ttk.Button(
            left_frame, text="Mark Unused", command=self.handle_mark_unused_supertiles_and_tiles
        )
        self.mark_unused_st_button.grid(row=4, column=0, pady=(5, 10), sticky="ew")

        right_frame = ttk.Frame(main_frame)
        right_frame.grid(row=0, column=1, sticky=(tk.N, tk.S, tk.W, tk.E))
        main_frame.grid_columnconfigure(1, weight=1)
        main_frame.grid_rowconfigure(0, weight=1)
        
        tileset_viewer_frame = ttk.LabelFrame(
            right_frame, text="Tileset (Click to select tile to draw supertile)"
        )
        # Use pack with anchor="nw" to align left and prevent horizontal/vertical expansion.
        tileset_viewer_frame.pack(side=tk.TOP, expand=False, pady=(0, 10), anchor="nw")

        padding = 1
        num_rows_fixed = 16
        fixed_viewer_width = NUM_TILES_ACROSS * (VIEWER_TILE_SIZE + padding) + padding
        fixed_viewer_height = num_rows_fixed * (VIEWER_TILE_SIZE + padding) + padding
        
        st_viewer_hbar = ttk.Scrollbar(tileset_viewer_frame, orient=tk.HORIZONTAL)
        st_viewer_vbar = ttk.Scrollbar(tileset_viewer_frame, orient=tk.VERTICAL)
        self.st_tileset_canvas = tk.Canvas(
            tileset_viewer_frame,
            bg="lightgrey",
            width=fixed_viewer_width,
            height=fixed_viewer_height,
            xscrollcommand=st_viewer_hbar.set,
            yscrollcommand=st_viewer_vbar.set,
        )

        st_viewer_hbar.config(command=self.st_tileset_canvas.xview)
        st_viewer_vbar.config(command=self.st_tileset_canvas.yview)
        self.st_tileset_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        st_viewer_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        st_viewer_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        tileset_viewer_frame.grid_rowconfigure(0, weight=1)
        tileset_viewer_frame.grid_columnconfigure(0, weight=1)

        self.st_tileset_canvas.bind("<Button-1>", self.handle_st_tileset_click)
        self.st_tileset_canvas.bind("<Double-Button-1>", self._on_canvas_double_click)
        self.st_tileset_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.st_tileset_canvas.bind(
            "<ButtonRelease-1>", self.handle_viewer_drag_release
        )
        self.st_tileset_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.st_tileset_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.st_tileset_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")

        bottom_controls_frame = ttk.Frame(right_frame)
        bottom_controls_frame.pack(side=tk.BOTTOM, fill=tk.X, expand=False, pady=(5, 0))

        st_editor_paned_window = ttk.PanedWindow(right_frame, orient=tk.HORIZONTAL)
        st_editor_paned_window.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.st_editor_paned_window = st_editor_paned_window
        st_editor_paned_window.bind("<ButtonRelease-1>", self._capture_sash_position)

        st_selector_frame = ttk.LabelFrame(
            st_editor_paned_window, text="Supertile Selector (Click to select for edition)",
            name="st_editor_selector_frame"
        )
        st_editor_paned_window.add(st_selector_frame, weight=0)
        
        st_selector_frame.bind("<Configure>", self._on_resizable_selector_pane_configure)
        
        inert_panel = ttk.Frame(st_editor_paned_window)
        st_editor_paned_window.add(inert_panel, weight=0)

        target_selector_width = 256 
        self.supertile_selector_canvas = tk.Canvas(
            st_selector_frame,
            bg="lightgrey",
            scrollregion=(0, 0, 1, 1), 
            width=target_selector_width 
        )
        st_sel_hbar = ttk.Scrollbar(st_selector_frame, orient=tk.HORIZONTAL)
        st_sel_vbar = ttk.Scrollbar(st_selector_frame, orient=tk.VERTICAL)
        def st_sel_canvas_xview_wrapper(*args):
            _debug(f" ST Editor - Supertile Selector XScrollbar: args={args}")
            self.supertile_selector_canvas.xview(*args)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
        def st_sel_canvas_yview_wrapper(*args):
            _debug(f" ST Editor - Supertile Selector YScrollbar: args={args}")
            self.supertile_selector_canvas.yview(*args)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
        self.supertile_selector_canvas.config(
            xscrollcommand=st_sel_hbar.set,
            yscrollcommand=st_sel_vbar.set
        )
        st_sel_hbar.config(command=st_sel_canvas_xview_wrapper)
        st_sel_vbar.config(command=st_sel_canvas_yview_wrapper)
        self.supertile_selector_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        st_sel_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        st_sel_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        st_selector_frame.grid_rowconfigure(0, weight=1)
        st_selector_frame.grid_columnconfigure(0, weight=1)
        self.supertile_selector_canvas.bind("<Button-1>", self.handle_supertile_selector_click)
        self.supertile_selector_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.supertile_selector_canvas.bind("<ButtonRelease-1>", self.handle_viewer_drag_release)
        self.supertile_selector_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.supertile_selector_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.supertile_selector_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")

        self.add_supertile_button = ttk.Button(bottom_controls_frame, text="Add New", command=self.handle_add_supertile)
        self.add_supertile_button.grid(row=0, column=0, padx=(0, 3))

        self.add_many_supertiles_button = ttk.Button(bottom_controls_frame, text="Add Many...", command=self.handle_add_many_supertiles)
        self.add_many_supertiles_button.grid(row=0, column=1, padx=3)

        self.supertile_sel_info_label = ttk.Label(bottom_controls_frame, text=f"Supertiles: 1 / {MAX_SUPERTILES}")
        self.supertile_sel_info_label.grid(row=0, column=2, padx=(10, 2))

        self.supertile_limit_entry = ttk.Entry(bottom_controls_frame, textvariable=self.supertile_limit_var, width=5)
        self.supertile_limit_entry.grid(row=0, column=3, padx=2)
        self.supertile_limit_entry.bind("<Return>", lambda e: self._apply_supertile_limit_from_entry())

        self.apply_supertile_limit_button = ttk.Button(bottom_controls_frame, text="Set Limit", command=self._apply_supertile_limit_from_entry)
        self.apply_supertile_limit_button.grid(row=0, column=4, padx=(2, 0))

        # Row 1: Insert and Delete buttons
        self.insert_supertile_button = ttk.Button(bottom_controls_frame, text="Insert", command=self.handle_insert_supertile)
        self.insert_supertile_button.grid(row=1, column=0, padx=(0, 3), pady=(5, 0))

        self.delete_supertile_button = ttk.Button(bottom_controls_frame, text="Delete", command=self.handle_delete_supertile)
        self.delete_supertile_button.grid(row=1, column=1, padx=3, pady=(5, 0))

    def create_map_editor_widgets(self, parent_frame):
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(expand=True, fill="both")

        self.map_paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        self.map_paned_window.pack(expand=True, fill="both", padx=5, pady=5)

        map_area_frame = ttk.Frame(self.map_paned_window, padding=(0,0,5,0)) 
        self.map_paned_window.add(map_area_frame, weight=3) 
        self.map_editor_map_pane_container = map_area_frame 

        palette_area_frame = ttk.Frame(self.map_paned_window, padding=(5,0,0,0)) 
        self.map_paned_window.add(palette_area_frame, weight=1) 
        self.map_editor_palette_pane_container = palette_area_frame

        map_area_frame.grid_columnconfigure(0, weight=1)
        map_area_frame.grid_rowconfigure(3, weight=1) 
        
        controls_frame = ttk.Frame(map_area_frame)
        controls_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        size_label = ttk.Label(controls_frame, text="Map Size:")
        size_label.grid(row=0, column=0, padx=(0, 5), pady=2)
        self.map_size_label = ttk.Label(controls_frame, text=f"{map_width} x {map_height}")
        self.map_size_label.grid(row=0, column=1, padx=(0, 10), pady=2)
        zoom_frame = ttk.Frame(controls_frame)
        zoom_frame.grid(row=0, column=2, padx=(10, 0), pady=2)
        zoom_out_button = ttk.Button(zoom_frame,text="-",width=2,command=lambda: self.change_map_zoom_mult(1 / 1.25))
        zoom_out_button.pack(side=tk.LEFT)
        self.map_zoom_label = ttk.Label(zoom_frame, text="100%", width=5, anchor=tk.CENTER)
        self.map_zoom_label.pack(side=tk.LEFT, padx=2)
        zoom_in_button = ttk.Button(zoom_frame,text="+",width=2,command=lambda: self.change_map_zoom_mult(1.25))
        zoom_in_button.pack(side=tk.LEFT)
        zoom_reset_button = ttk.Button(zoom_frame, text="Reset", width=5, command=lambda: self.set_map_zoom(1.0))
        zoom_reset_button.pack(side=tk.LEFT, padx=(5, 0))
        self.map_coords_label = ttk.Label(controls_frame, text="ST Coords: -, -", width=15)
        self.map_coords_label.grid(row=0, column=3, padx=(10, 5), sticky="w")

        win_controls_frame = ttk.Frame(map_area_frame)
        win_controls_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        win_view_check = ttk.Checkbutton(win_controls_frame,text="Show Window View",variable=self.show_window_view,command=self.toggle_window_view)
        win_view_check.grid(row=0, column=0, padx=5, sticky="w")
        win_w_label = ttk.Label(win_controls_frame, text="Width:")
        win_w_label.grid(row=0, column=1, padx=(10, 0))
        self.win_view_w_entry = ttk.Entry(win_controls_frame, textvariable=self.window_view_tile_w, width=4)
        self.win_view_w_entry.grid(row=0, column=2)
        win_h_label = ttk.Label(win_controls_frame, text="Height:")
        win_h_label.grid(row=0, column=3, padx=(5, 0))
        self.win_view_h_entry = ttk.Entry(win_controls_frame, textvariable=self.window_view_tile_h, width=4)
        self.win_view_h_entry.grid(row=0, column=4)
        win_apply_button = ttk.Button(win_controls_frame,text="Apply Size",command=self.apply_window_size_from_entries)
        win_apply_button.grid(row=0, column=5, padx=5)
        self.win_view_w_entry.bind("<Return>", lambda e: self.apply_window_size_from_entries())
        self.win_view_h_entry.bind("<Return>", lambda e: self.apply_window_size_from_entries())

        grid_controls_frame = ttk.Frame(map_area_frame)
        grid_controls_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(0, 5))
        st_grid_check = ttk.Checkbutton(grid_controls_frame,text="Show Supertile Grid (Press 'G' to Cycle Colors)",variable=self.show_supertile_grid,command=self.toggle_supertile_grid)
        st_grid_check.grid(row=0, column=0, padx=5, sticky="w")
        
        map_area_frame.update_idletasks() 
        controls_frame_width = controls_frame.winfo_reqwidth()
        win_controls_frame_width = win_controls_frame.winfo_reqwidth()
        grid_controls_frame_width = grid_controls_frame.winfo_reqwidth()
        self.map_controls_min_width = max(controls_frame_width, win_controls_frame_width, grid_controls_frame_width) + 10 
        _debug(f" create_map_editor_widgets: Calculated map_controls_min_width = {self.map_controls_min_width}")

        map_canvas_frame = ttk.LabelFrame(map_area_frame, text="Map")
        map_canvas_frame.grid(row=3, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        map_canvas_frame.grid_rowconfigure(0, weight=1)
        map_canvas_frame.grid_columnconfigure(0, weight=1)
        self.map_hbar = ttk.Scrollbar(map_canvas_frame, orient=tk.HORIZONTAL)
        self.map_vbar = ttk.Scrollbar(map_canvas_frame, orient=tk.VERTICAL)
        self.map_canvas = tk.Canvas(map_canvas_frame,bg="black", xscrollcommand=self.map_hbar.set,yscrollcommand=self.map_vbar.set)
        self.map_hbar.config(command=self.map_canvas.xview)
        self.map_vbar.config(command=self.map_canvas.yview)
        self.map_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        self.map_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        self.map_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))

        self.map_canvas.bind("<Double-Button-1>", self._on_canvas_double_click)
        self.map_canvas.bind("<Configure>", self._on_map_canvas_configure)

        palette_area_frame.grid_rowconfigure(0, weight=1)
        palette_area_frame.grid_columnconfigure(0, weight=1)
        st_selector_frame = ttk.LabelFrame(palette_area_frame, text="Supertile Palette (Click to select supertile to draw map)")
        st_selector_frame.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E), pady=(0,5))
        st_selector_frame.grid_rowconfigure(0, weight=1)
        st_selector_frame.grid_columnconfigure(0, weight=1)
        padding = 1 
        min_one_supertile_preview_width = (self.supertile_grid_width * TILE_WIDTH) + (2 * padding)
        min_one_supertile_preview_width = max(32, min_one_supertile_preview_width) 
        self.map_supertile_selector_canvas = tk.Canvas(st_selector_frame,bg="lightgrey", scrollregion=(0, 0, 1, 1), width=min_one_supertile_preview_width)
        map_st_sel_hbar = ttk.Scrollbar(st_selector_frame, orient=tk.HORIZONTAL)
        map_st_sel_vbar = ttk.Scrollbar(st_selector_frame, orient=tk.VERTICAL)

        def map_st_sel_canvas_xview_wrapper(*args):
            _debug(f" Map Editor - Supertile Palette XScrollbar: args={args}")
            self.map_supertile_selector_canvas.xview(*args)
            self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

        def map_st_sel_canvas_yview_wrapper(*args):
            _debug(f" Map Editor - Supertile Palette YScrollbar: args={args}")
            self.map_supertile_selector_canvas.yview(*args)
            self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

        self.map_supertile_selector_canvas.config(xscrollcommand=map_st_sel_hbar.set, yscrollcommand=map_st_sel_vbar.set)
        map_st_sel_hbar.config(command=map_st_sel_canvas_xview_wrapper)
        map_st_sel_vbar.config(command=map_st_sel_canvas_yview_wrapper)

        self.map_supertile_selector_canvas.grid(row=0, column=0, sticky=(tk.N, tk.S, tk.W, tk.E))
        map_st_sel_vbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        map_st_sel_hbar.grid(row=1, column=0, sticky=(tk.W, tk.E))
        self.map_supertile_select_label = ttk.Label(palette_area_frame, text=f"Selected Supertile for Painting: {selected_supertile_for_map}")
        self.map_supertile_select_label.grid(row=1, column=0, sticky=tk.W, pady=(0, 0))
        self.map_supertile_selector_canvas.bind("<Button-1>", self.handle_map_supertile_selector_click)
        self.map_supertile_selector_canvas.bind("<Double-Button-1>", self._on_canvas_double_click)
        self.map_supertile_selector_canvas.bind("<B1-Motion>", self.handle_viewer_drag_motion)
        self.map_supertile_selector_canvas.bind("<ButtonRelease-1>", self.handle_viewer_drag_release)
        self.map_supertile_selector_canvas.bind("<MouseWheel>", self._on_mousewheel_scroll, add="+")
        self.map_supertile_selector_canvas.bind("<Button-4>", self._on_mousewheel_scroll, add="+")
        self.map_supertile_selector_canvas.bind("<Button-5>", self._on_mousewheel_scroll, add="+")
        
        # Bind the entire pane container to the generalized configure handler.
        self.map_editor_palette_pane_container.bind("<Configure>", self._on_resizable_selector_pane_configure)
        
        self.map_paned_window.bind("<ButtonRelease-1>", self._capture_sash_position)

    # --- Use this as the SINGLE definition for setting up bindings ---
    def _setup_map_canvas_bindings(self):
        """Sets up ALL event bindings for the map canvas and related root bindings.
        Includes initial unbind step for robustness.
        """
        canvas = self.map_canvas

        # --- Unbind ALL PREVIOUSLY POTENTIAL MAP CANVAS BINDINGS ---
        canvas.unbind("<Button-1>")
        canvas.unbind("<B1-Motion>")
        canvas.unbind("<ButtonRelease-1>")
        canvas.unbind("<Button-3>")
        canvas.unbind("<Control-ButtonPress-1>")
        canvas.unbind("<Control-B1-Motion>")
        canvas.unbind("<Shift-ButtonPress-1>") 
        canvas.unbind("<Shift-B1-Motion>") 
        canvas.unbind("<Shift-ButtonRelease-1>") 
        canvas.unbind("<Control-MouseWheel>")
        canvas.unbind("<Control-Button-4>")
        canvas.unbind("<Control-Button-5>")
        canvas.unbind("<FocusIn>")
        canvas.unbind("<FocusOut>")
        canvas.unbind("<KeyPress-w>")
        canvas.unbind("<KeyPress-a>")
        canvas.unbind("<KeyPress-s>")
        canvas.unbind("<KeyPress-d>")
        canvas.unbind("<KeyPress-W>")
        canvas.unbind("<KeyPress-A>")
        canvas.unbind("<KeyPress-S>")
        canvas.unbind("<KeyPress-D>")
        canvas.unbind("<KeyPress-Escape>") 
        canvas.unbind("<Enter>")
        canvas.unbind("<Leave>")
        canvas.unbind("<Motion>")
        canvas.unbind("<MouseWheel>")
        canvas.unbind("<Button-4>")
        canvas.unbind("<Button-5>")

        # --- Mouse Button 1 (Primary) - Checks Shift/Ctrl internally ---
        canvas.bind("<Button-1>", self.handle_map_click_or_drag_start)
        canvas.bind("<B1-Motion>", self.handle_map_drag)
        canvas.bind("<ButtonRelease-1>", self.handle_map_drag_release)

        # --- Mouse Button 3 (Right-Click for Selection) ---
        canvas.bind("<Button-3>", self.handle_map_canvas_right_click)

        # --- Panning (Ctrl + Mouse Button 1) - Checks Shift internally ---
        canvas.bind("<Control-ButtonPress-1>", self.handle_pan_start)
        canvas.bind("<Control-B1-Motion>", self.handle_pan_motion) 

        # --- Selection (Shift + Mouse Button 1) ---
        canvas.bind("<Shift-ButtonPress-1>", self.handle_map_selection_start)
        canvas.bind("<Shift-B1-Motion>", self.handle_map_selection_motion)
        canvas.bind("<Shift-ButtonRelease-1>", self.handle_map_selection_release)

        # --- Zooming (Ctrl + Mouse Wheel) ---
        canvas.bind("<Control-MouseWheel>", self.handle_map_zoom_scroll)
        canvas.bind("<Control-Button-4>", self.handle_map_zoom_scroll)
        canvas.bind("<Control-Button-5>", self.handle_map_zoom_scroll)
        
        # --- Standard Scrolling (No Modifiers + Mouse Wheel) ---
        canvas.bind("<MouseWheel>", self._on_mousewheel_scroll)
        canvas.bind("<Button-4>", self._on_mousewheel_scroll)  
        canvas.bind("<Button-5>", self._on_mousewheel_scroll)  

        # --- Keyboard ---
        canvas.bind("<FocusIn>", lambda e: self.map_canvas.focus_set())
        canvas.bind("<FocusOut>", lambda e: self._update_map_cursor())
        canvas.bind("<KeyPress-w>", self.handle_map_keypress)
        canvas.bind("<KeyPress-a>", self.handle_map_keypress)
        canvas.bind("<KeyPress-s>", self.handle_map_keypress)
        canvas.bind("<KeyPress-d>", self.handle_map_keypress)
        canvas.bind("<KeyPress-W>", self.handle_map_keypress)
        canvas.bind("<KeyPress-A>", self.handle_map_keypress)
        canvas.bind("<KeyPress-S>", self.handle_map_keypress)
        canvas.bind("<KeyPress-D>", self.handle_map_keypress)
        canvas.bind("<KeyPress-Escape>", self.handle_map_escape)

        # --- Modifier Key State Tracking (Bound to root window) ---
        self.root.bind("<KeyPress-Control_L>", self.handle_ctrl_press, add="+")
        self.root.bind("<KeyPress-Control_R>", self.handle_ctrl_press, add="+")
        self.root.bind("<KeyRelease-Control_L>", self.handle_ctrl_release, add="+")
        self.root.bind("<KeyRelease-Control_R>", self.handle_ctrl_release, add="+")
        self.root.bind("<KeyPress-Shift_L>", self.handle_shift_press, add="+")
        self.root.bind("<KeyPress-Shift_R>", self.handle_shift_press, add="+")
        self.root.bind("<KeyRelease-Shift_L>", self.handle_shift_release, add="+")
        self.root.bind("<KeyRelease-Shift_R>", self.handle_shift_release, add="+")
        self.root.bind("<KeyPress-Alt_L>", self.handle_alt_press, add="+")
        self.root.bind("<KeyPress-Alt_R>", self.handle_alt_press, add="+")
        self.root.bind("<KeyRelease-Alt_L>", self.handle_alt_release, add="+")
        self.root.bind("<KeyRelease-Alt_R>", self.handle_alt_release, add="+")

        # --- Mouse Enter/Leave/Motion Canvas (for cursor updates) ---
        canvas.bind("<Enter>", self.handle_canvas_enter)
        canvas.bind("<Leave>", self.handle_canvas_leave)
        canvas.bind("<Motion>", self._update_map_cursor_and_coords)

        # --- Scrollbar Interaction (Update map canvas AND minimap) ---
        if hasattr(self, "map_hbar") and self.map_hbar:
            self.map_hbar.bind("<B1-Motion>", self._handle_map_scroll_event)
            self.map_hbar.bind("<ButtonRelease-1>", self._handle_map_scroll_event) 
        if hasattr(self, "map_vbar") and self.map_vbar:
            self.map_vbar.bind("<B1-Motion>", self._handle_map_scroll_event)
            self.map_vbar.bind("<ButtonRelease-1>", self._handle_map_scroll_event)

    # --- Drawing Functions ---
    def update_all_displays(self, changed_level="all"):
        current_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab = self.notebook.select()
                if selected_tab:
                    current_tab_index = self.notebook.index(selected_tab)
        except tk.TclError:
            _warning("Could not get current tab index in update_all_displays.")
            return

        palette_changed = changed_level in ["all", "palette"]
        if palette_changed:
            self.draw_current_palette()
            self.update_palette_info_labels()

        if current_tab_index == 0:
            _debug("Updating Palette Tab (Visible)")

        elif current_tab_index == 1:
            if changed_level in ["all", "tile_select", "tile_edit"] or palette_changed:
                _debug(f"Updating Tile Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_editor_canvas()
                self.draw_attribute_editor()
                self.draw_palette()
                self.draw_tileset_viewer(
                    self.tileset_canvas, current_tile_index
                )
                self.update_tile_info_label()
                recalc_usage = changed_level != 'tile_edit'
                self._update_selected_tile_info_panel(update_usage_counts=recalc_usage)

        elif current_tab_index == 2:
            if changed_level in ["all", "supertile", "tile_select", "tile_edit"] or palette_changed:
                _debug(f"Updating Supertile Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_supertile_definition_canvas()
                self.draw_tileset_viewer(
                    self.st_tileset_canvas, selected_tile_for_supertile
                )
                self.draw_supertile_selector(
                    self.supertile_selector_canvas, current_supertile_index
                )
                self._update_selected_supertile_info_panel()
                self._update_st_tab_selected_tile_info_panel()
                self._update_supertile_info_label()

        elif current_tab_index == 3:
            if changed_level in ["all", "map", "supertile", "tile_select", "tile_edit"] or palette_changed:
                _debug(f"Updating Map Tab (Visible), Level: {changed_level}, PaletteChanged: {palette_changed}")
                self.draw_map_canvas()
                self.draw_supertile_selector(
                    self.map_supertile_selector_canvas, selected_supertile_for_map
                )
                self.update_map_info_labels()
                self.draw_minimap()

    # ... (draw_editor_canvas, draw_attribute_editor, draw_palette unchanged) ...
    def draw_editor_canvas(self):
        self.editor_canvas.delete("all")
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return
        pattern = tileset_patterns[current_tile_index]
        colors = tileset_colors[current_tile_index]
        for r in range(TILE_HEIGHT):
            try:
                fg_idx, bg_idx = colors[r]
                fg_color = self.active_msx_palette[fg_idx]
                bg_color = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color, bg_color = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            for c in range(TILE_WIDTH):
                try:
                    pixel_val = pattern[r][c]
                except IndexError:
                    pixel_val = 0
                color = fg_color if pixel_val == 1 else bg_color
                x1 = c * EDITOR_PIXEL_SIZE
                y1 = r * EDITOR_PIXEL_SIZE
                x2 = x1 + EDITOR_PIXEL_SIZE
                y2 = y1 + EDITOR_PIXEL_SIZE
                self.editor_canvas.create_rectangle(
                    x1, y1, x2, y2, fill=color, outline="darkgrey", width=1
                )

    def draw_attribute_editor(self):
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return
        colors = tileset_colors[current_tile_index]
        for r in range(TILE_HEIGHT):
            try:
                fg_idx, bg_idx = colors[r]
                fg_color_hex = self.active_msx_palette[fg_idx]
                bg_color_hex = self.active_msx_palette[bg_idx]
            except IndexError:
                fg_color_hex, bg_color_hex = INVALID_TILE_COLOR, INVALID_TILE_COLOR
            self.attr_fg_labels[r].config(
                bg=fg_color_hex, fg=get_contrast_color(fg_color_hex)
            )
            self.attr_bg_labels[r].config(
                bg=bg_color_hex, fg=get_contrast_color(bg_color_hex)
            )

    def draw_palette(self):  # Renamed draw_palette to this for clarity
        """Draws the 16-color selector palette in the Tile Editor tab."""
        canvas = self.tile_editor_palette_canvas
        canvas.delete("all")
        size = PALETTE_SQUARE_SIZE
        padding = 2
        for i in range(16):
            row, col = divmod(i, 4)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            color = self.active_msx_palette[i]  # Use active palette
            outline_color = "red" if i == selected_color_index else "grey"
            outline_width = 2 if i == selected_color_index else 1
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=color,
                outline=outline_color,
                width=outline_width,
                tags=f"pal_sel_{i}",
            )

    def draw_current_palette(self):
        canvas = self.current_palette_canvas
        canvas.delete("all")
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        for i in range(16):
            row, col = divmod(i, 4)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            color = self.active_msx_palette[i]
            outline_color = "red" if i == self.selected_palette_slot else "grey"
            outline_width = 3 if i == self.selected_palette_slot else 1
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=color,
                outline=outline_color,
                width=outline_width,
                tags=f"pal_slot_{i}",
            )

    def draw_512_picker(self):
        canvas = self.msx2_picker_canvas
        canvas.delete("all")
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS
        for i in range(512):
            row, col = divmod(i, cols)
            x1 = col * (size + padding) + padding
            y1 = row * (size + padding) + padding
            x2 = x1 + size
            y2 = y1 + size
            hex_color = msx2_512_colors_hex[i]
            r, g, b = msx2_512_colors_rgb7[i]
            canvas.create_rectangle(
                x1,
                y1,
                x2,
                y2,
                fill=hex_color,
                outline="grey",
                width=1,
                tags=(f"msx2_picker_{i}", f"msx2_rgb_{r}_{g}_{b}"),
            )

    def update_palette_info_labels(self):
        slot = self.selected_palette_slot
        self._is_updating_color_inputs = True # Prevent traces from firing during this programmatic update
        try:
            if 0 <= slot < 16:
                color_hex = self.active_msx_palette[slot]
                rgb7 = self._hex_to_rgb7(color_hex)
                r9, g9, b9 = rgb7

                # Update info labels
                self.selected_slot_label.config(text=f"Slot: {slot}")
                self.selected_slot_rgb_label.config(text=f"RGB: {color_hex} ({r9},{g9},{b9})")
                
                # --- Explicitly update all UI elements ---
                # Set 9-bit input variables
                if self.rgb9_r_var: self.rgb9_r_var.set(str(r9))
                if self.rgb9_g_var: self.rgb9_g_var.set(str(g9))
                if self.rgb9_b_var: self.rgb9_b_var.set(str(b9))

                # Directly calculate and set 24-bit values
                r24 = min(255, r9 * 36)
                g24 = min(255, g9 * 36)
                b24 = min(255, b9 * 36)
                if self.rgb24_r_var: self.rgb24_r_var.set(str(r24))
                if self.rgb24_g_var: self.rgb24_g_var.set(str(g24))
                if self.rgb24_b_var: self.rgb24_b_var.set(str(b24))

                # Update all preview canvases
                if self.msx2_color_preview_canvas: self.msx2_color_preview_canvas.config(bg=color_hex)
                if self.hex24_color_preview_canvas: self.hex24_color_preview_canvas.config(bg=color_hex)
                if self.selected_color_preview_canvas:
                    self.selected_color_preview_canvas.delete("all")
                    if self.selected_color_preview_canvas.winfo_exists():
                        w, h = self.selected_color_preview_canvas.winfo_width(), self.selected_color_preview_canvas.winfo_height()
                        if w > 1 and h > 1:
                            self.selected_color_preview_canvas.create_rectangle(0,0,w,h,fill=color_hex,outline=color_hex)
                # --- End explicit updates ---

                if hasattr(self, 'selected_color_usage_label'):
                    _, _, tile_refs_count = self._calculate_single_color_usage(slot)
                    self.selected_color_usage_label.config(text=f"Used in {tile_refs_count} tiles.")
                    if tile_refs_count > 0:
                        self.selected_color_usage_label.config(fg="blue", font=self.link_font, cursor="hand2")
                    else:
                        default_fg = self.selected_slot_label.cget("foreground") or "#000000"
                        self.selected_color_usage_label.config(fg=default_fg, font=self.normal_font, cursor="")
            else:
                # Handle case where no slot is selected (clear all fields)
                self.selected_slot_label.config(text="Slot: -")
                self.selected_slot_rgb_label.config(text="RGB: -")
                if self.rgb9_r_var: self.rgb9_r_var.set("")
                if self.rgb9_g_var: self.rgb9_g_var.set("")
                if self.rgb9_b_var: self.rgb9_b_var.set("")
                if self.rgb24_r_var: self.rgb24_r_var.set("")
                if self.rgb24_g_var: self.rgb24_g_var.set("")
                if self.rgb24_b_var: self.rgb24_b_var.set("")
                if self.msx2_color_preview_canvas: self.msx2_color_preview_canvas.config(bg="darkgrey")
                if self.hex24_color_preview_canvas: self.hex24_color_preview_canvas.config(bg="darkgrey")
                if self.selected_color_preview_canvas: self.selected_color_preview_canvas.delete("all")
                if hasattr(self, 'selected_color_usage_label'):
                    default_fg = self.selected_slot_label.cget("foreground") or "#000000"
                    self.selected_color_usage_label.config(text="Usage: N/A", fg=default_fg, font=self.normal_font, cursor="")
        finally:
            self.root.after_idle(lambda: setattr(self, '_is_updating_color_inputs', False))

    def draw_tileset_viewer(self, canvas, highlighted_tile_index):
        """Draws tileset viewer, highlighting selected, dragged, or unused tile."""
        _debug(f"\n--- DRAW: draw_tileset_viewer called for canvas {canvas._name}.")
        _debug(f"\n--- DRAW: draw_tileset_viewer called. Drawing {len(tileset_patterns)} tiles.")
        _debug(f"--- DRAW: AT THIS MOMENT, self.marked_unused_tiles is: {self.marked_unused_tiles}")

        is_dragging_tile = self.drag_active and self.drag_item_type == "tile"
        dragged_tile_index = self.drag_start_index if is_dragging_tile else -1

        try:
            canvas.delete("all")
            padding = 1
            size = VIEWER_TILE_SIZE
            max_rows = math.ceil(len(tileset_patterns) / NUM_TILES_ACROSS)
            canvas_height = max(1, max_rows * (size + padding) + padding)  
            canvas_width = max(
                1, NUM_TILES_ACROSS * (size + padding) + padding
            )  
            str_scroll = f"0 0 {float(canvas_width)} {float(canvas_height)}"

            current_scroll = ""
            try:
                current_scroll_val = canvas.cget("scrollregion")
                if isinstance(current_scroll_val, tuple):
                    current_scroll = " ".join(map(str, current_scroll_val))
                else:
                    current_scroll = str(current_scroll_val)
            except tk.TclError:
                pass

            if current_scroll != str_scroll:
                canvas.config(scrollregion=(0, 0, canvas_width, canvas_height))

            for i in range(len(tileset_patterns)):
                tile_r, tile_c = divmod(i, NUM_TILES_ACROSS)
                base_x = tile_c * (size + padding) + padding
                base_y = tile_r * (size + padding) + padding

                img = self.create_tile_image(i, size)
                canvas.create_image(
                    base_x,
                    base_y,
                    image=img,
                    anchor=tk.NW,
                    tags=(f"tile_img_{i}", "tile_image"),
                )

                outline_color = "grey" 
                outline_width = 1
                if i == dragged_tile_index:
                    outline_color = "yellow" 
                    outline_width = 3
                elif i == highlighted_tile_index:
                    outline_color = "red"
                    outline_width = 2
                elif i in self.marked_unused_tiles:
                    _debug(f"--- DRAW: Highlighting tile {i} because it's in the marked set.")
                    outline_color = "blue"
                    outline_width = 3

                bx1 = max(0, base_x - padding / 2)
                by1 = max(0, base_y - padding / 2)
                bx2 = base_x + size + padding / 2
                by2 = base_y + size + padding / 2
                canvas.create_rectangle(
                    bx1,
                    by1,
                    bx2,
                    by2,
                    outline=outline_color,
                    width=outline_width,
                    tags=f"tile_border_{i}",
                )

        except tk.TclError as e:
            print(f"TclError during draw_tileset_viewer: {e}")
        except Exception as e:
            _error(f"Unexpected error during draw_tileset_viewer: {e}")

    def update_tile_info_label(self):
        self.tile_info_label.config(text=f"Tiles: {len(tileset_patterns)} /")

    def _update_supertile_info_label(self):
        self.supertile_sel_info_label.config(text=f"Supertiles: {len(supertiles_data)} /")

    def draw_supertile_definition_canvas(self):
        canvas = self.supertile_def_canvas
        canvas.delete("all")
        if not (0 <= current_supertile_index < len(supertiles_data)):
            return

        definition = supertiles_data[current_supertile_index]
        
        # Ensure definition has expected structure based on current project dimensions
        # This is a safeguard. Data should ideally be consistent.
        _debug(f"Definition: {str(definition)}")
        if not definition or len(definition) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(definition[0]) != self.supertile_grid_width)):
            _error(f"Supertile {current_supertile_index} definition dimensions mismatch in draw_supertile_definition_canvas.")
            # Optionally draw an error indicator on the canvas
            canvas_w = canvas.winfo_width()
            canvas_h = canvas.winfo_height()
            canvas.create_text(canvas_w/2, canvas_h/2, text="Dim Mismatch!", fill="red", anchor="center")
            return

        # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile (e.g., 32x32 pixels)
        mini_tile_display_size = SUPERTILE_DEF_TILE_SIZE 

        for r_def in range(self.supertile_grid_height):
            for c_def in range(self.supertile_grid_width):
                try:
                    tile_idx = definition[r_def][c_def]
                except IndexError: # Should be caught by the check above, but for safety
                    _error(f"Error drawing ST def: index out of bounds for ST {current_supertile_index} at {r_def},{c_def}")
                    tile_idx = 0 # Default to tile 0 on error

                base_x = c_def * mini_tile_display_size
                base_y = r_def * mini_tile_display_size
                
                img = self.create_tile_image(tile_idx, mini_tile_display_size)
                canvas.create_image(
                    base_x, base_y, image=img, anchor=tk.NW, tags=f"def_tile_{r_def}_{c_def}"
                )
                canvas.create_rectangle(
                    base_x, base_y, base_x + mini_tile_display_size, base_y + mini_tile_display_size, outline="grey"
                )
    
    def draw_supertile_selector(self, canvas, highlighted_supertile_index):
        is_dragging_supertile = self.drag_active and self.drag_item_type == "supertile"
        dragged_supertile_index = self.drag_start_index if is_dragging_supertile else -1

        try:
            if not canvas.winfo_exists():
                return
            canvas.delete("all") # Clear previous items
            
            item_pixel_w = self.supertile_grid_width * TILE_WIDTH
            item_pixel_h = self.supertile_grid_height * TILE_HEIGHT
            padding = 1 

            if item_pixel_w <= 0 or item_pixel_h <= 0:
                _debug(f" draw_supertile_selector: Invalid item_pixel_w/h ({item_pixel_w}x{item_pixel_h}). Aborting.")
                return

            actual_canvas_width = canvas.winfo_width()
            if actual_canvas_width <= 1: 
                 # Canvas not yet sized, reschedule.
                 # Ensure we don't get into an infinite after loop if it never gets size.
                 # Add a counter or a flag if this becomes an issue.
                 canvas.after(100, lambda: self.draw_supertile_selector(canvas, highlighted_supertile_index))
                 return
            
            _debug(f" draw_supertile_selector: Actual Canvas Width: {actual_canvas_width}, Item Pixel W: {item_pixel_w}")

            # Calculate how many items can fit, ensuring at least one if possible.
            if item_pixel_w + 2 * padding > actual_canvas_width : # Not even one fits with padding on both sides
                items_across = 0 # Or 1 if you want to force one and let it clip/be tiny
                if item_pixel_w <= actual_canvas_width : # Fits without padding
                    items_across = 1
                # else: it's wider than canvas, items_across remains 0 (or handle as error/special case)
            else:
                # Calculate max integer number of items that can fit
                items_across = (actual_canvas_width - padding) // (item_pixel_w + padding)
            
            items_across = max(1, items_across) # Ensure at least 1 item is planned if possible, even if it overflows slightly
                                                # or if the canvas is very narrow. If item_pixel_w itself is > canvas_width,
                                                # it will still draw 1 item that will be clipped by the canvas viewport.

            _debug(f" draw_supertile_selector: Calculated items_across: {items_across}")

            num_logical_rows = math.ceil(len(supertiles_data) / items_across) if items_across > 0 else len(supertiles_data)
            # Scrollregion width should be based on the calculated items_across to fit them snugly
            scroll_content_width = (items_across * item_pixel_w) + ((items_across + 1) * padding)
            scroll_content_height = (num_logical_rows * item_pixel_h) + ((num_logical_rows + 1) * padding)
            scroll_content_width = max(1.0, float(scroll_content_width))
            scroll_content_height = max(1.0, float(scroll_content_height))

            str_scroll = f"0 0 {scroll_content_width} {scroll_content_height}"
            current_scroll_val_str = ""
            try:
                current_scroll_val = canvas.cget("scrollregion")
                current_scroll_val_str = " ".join(map(str, current_scroll_val)) if isinstance(current_scroll_val, tuple) else str(current_scroll_val)
            except tk.TclError: pass

            if current_scroll_val_str != str_scroll :
                try:
                    canvas.config(scrollregion=(0, 0, scroll_content_width, scroll_content_height))
                    _debug(f" draw_supertile_selector: Scrollregion set to: {scroll_content_width}x{scroll_content_height}")
                except tk.TclError: _debug(" draw_supertile_selector: TclError setting scrollregion."); return

            # Optimized drawing for visible rows (same as before)
            view_y1 = canvas.canvasy(0)
            view_y2 = canvas.canvasy(canvas.winfo_height())
            # For a vertically scrolling list, start_draw_col is always 0, end_draw_col is items_across
            start_draw_row = max(0, int(view_y1 // (item_pixel_h + padding)))
            end_draw_row = min(num_logical_rows, int(math.ceil(view_y2 / (item_pixel_h + padding))))
            # Ensure at least one row is attempted if there's content, and end_draw_row covers partials
            if num_logical_rows > 0 and end_draw_row == start_draw_row and view_y2 > view_y1:
                 end_draw_row = max(end_draw_row, start_draw_row +1) # Ensure at least one iteration if content exists and view is valid
            end_draw_row = min(num_logical_rows, end_draw_row) # Clamp to actual rows

            _debug(f" draw_supertile_selector: Drawing rows {start_draw_row} to {end_draw_row-1}")


            for r_grid in range(start_draw_row, end_draw_row):
                for c_grid in range(items_across):
                    st_idx = r_grid * items_across + c_grid
                    if st_idx >= len(supertiles_data): break

                    base_x = (c_grid * (item_pixel_w + padding)) + padding
                    base_y = (r_grid * (item_pixel_h + padding)) + padding

                    img = self.create_supertile_image(st_idx, item_pixel_w, item_pixel_h) 
                    
                    if not canvas.winfo_exists(): return
                    canvas.create_image(
                        base_x, base_y, image=img, anchor=tk.NW, tags=(f"st_img_{st_idx}", "st_image")
                    )

                    outline_color = "grey"; outline_width = 1
                    if st_idx == dragged_supertile_index: outline_color = "yellow"; outline_width = 3
                    elif st_idx == highlighted_supertile_index: outline_color = "red"; outline_width = 2
                    elif st_idx in self.marked_unused_supertiles: outline_color = "blue"; outline_width = 3
                    
                    bx1 = base_x - (padding / 2 if padding > 0 else 0.5) 
                    by1 = base_y - (padding / 2 if padding > 0 else 0.5)
                    bx2 = base_x + item_pixel_w + (padding / 2 if padding > 0 else 0.5)
                    by2 = base_y + item_pixel_h + (padding / 2 if padding > 0 else 0.5)
                    
                    if not canvas.winfo_exists(): return
                    canvas.create_rectangle(
                        bx1, by1, bx2, by2, outline=outline_color, width=outline_width, tags=f"st_border_{st_idx}"
                    )
                if st_idx >= len(supertiles_data) -1 : break # Break outer loop if all STs processed
        except tk.TclError as e: _error(f" TclError in draw_supertile_selector: {e}")
        except Exception as e: _error(f" Unexpected error in draw_supertile_selector: {e}")

    def draw_map_canvas(self):
        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return
        
        # Delete old canvas items first (specifically map content, not overlays yet)
        # The main image will be tagged "map_render_image", selection and grids are separate.
        canvas.delete("map_render_image") # Delete only the main rendered image for now

        _debug(f" draw_map_canvas: Start. Zoom: {self.map_zoom_level:.2f}")

        # --- 1. Calculate Sizes ---
        zoomed_tile_size = self.get_zoomed_tile_size() 
        if zoomed_tile_size <= 0: 
            _debug(" draw_map_canvas: zoomed_tile_size <= 0. Aborting.")
            return

        zoomed_supertile_pixel_width, zoomed_supertile_pixel_height = self._get_zoomed_supertile_pixel_dims()
        if zoomed_supertile_pixel_width <= 0 or zoomed_supertile_pixel_height <= 0:
            _debug(" draw_map_canvas: zoomed_supertile_pixel_width/height <= 0. Aborting.")
            return
        
        _debug(f" draw_map_canvas: Zoomed ST dims (WxH): {zoomed_supertile_pixel_width}x{zoomed_supertile_pixel_height}")


        # --- 2. Update Scroll Region (based on total map content size at current zoom) ---
        map_content_pixel_width_total = map_width * zoomed_supertile_pixel_width
        map_content_pixel_height_total = map_height * zoomed_supertile_pixel_height
        
        safe_scroll_width = max(1.0, float(map_content_pixel_width_total))
        safe_scroll_height = max(1.0, float(map_content_pixel_height_total))
        
        # Only update scrollregion if it actually changed to avoid unnecessary internal Tk processing
        current_scroll_region_str = ""
        try:
            sr = canvas.cget("scrollregion")
            if sr and isinstance(sr, str) and len(sr.split()) == 4: # Basic check for valid format
                current_scroll_region_str = sr
        except tk.TclError: pass # Canvas might not be fully ready on first call

        new_scroll_region_str = f"0 0 {safe_scroll_width} {safe_scroll_height}"
        if current_scroll_region_str != new_scroll_region_str:
            try:
                canvas.config(scrollregion=(0, 0, safe_scroll_width, safe_scroll_height))
                _debug(f" draw_map_canvas: Scrollregion set to {new_scroll_region_str}")
            except tk.TclError: 
                _debug(" draw_map_canvas: TclError setting scrollregion.")
                return # Cannot proceed if scrollregion fails
        
        # --- 3. Get Viewport Info ---
        canvas_viewport_width = canvas.winfo_width()
        canvas_viewport_height = canvas.winfo_height()

        if canvas_viewport_width <= 0 or canvas_viewport_height <= 0:
            _debug(" draw_map_canvas: Viewport width/height <= 0. Aborting.")
            return

        view_content_x1 = canvas.canvasx(0) # Top-left X of visible part of content
        view_content_y1 = canvas.canvasy(0) # Top-left Y of visible part of content
        _debug(f" draw_map_canvas: Viewport WxH: {canvas_viewport_width}x{canvas_viewport_height}, Content scroll: ({view_content_x1:.1f}, {view_content_y1:.1f})")


        # --- 4. Create/Resize Pillow Viewport Image Buffer ---
        # self.pil_map_viewport_image stores the Pillow Image
        # self.tk_map_photoimage stores the Tk PhotoImage for display (and keeps a reference)
        if self.pil_map_viewport_image is None or \
           self.pil_map_viewport_image.width != canvas_viewport_width or \
           self.pil_map_viewport_image.height != canvas_viewport_height:
            try:
                self.pil_map_viewport_image = Image.new('RGB', 
                                                        (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), 
                                                        canvas.cget("bg")) # Fill with canvas BG
                _debug(f" draw_map_canvas: Created/Resized self.pil_map_viewport_image to {canvas_viewport_width}x{canvas_viewport_height}")
            except ValueError as e_pil_new:
                _error(f" draw_map_canvas: Error creating pil_map_viewport_image: {e_pil_new}")
                return
        else:
            # Fill existing image with background color
            try:
                self.pil_map_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height) )
            except Exception as e_fill: # Catch potential errors if canvas.cget("bg") is not a valid color for paste
                _error(f" draw_map_canvas: Error filling pil_map_viewport_image: {e_fill}. Filling with black.")
                self.pil_map_viewport_image.paste("black", (0,0,canvas_viewport_width,canvas_viewport_height) )


        # --- 5. Determine Visible Supertile Range & Composite onto Pillow Viewport Image ---
        start_st_col = max(0, int(view_content_x1 // zoomed_supertile_pixel_width))
        start_st_row = max(0, int(view_content_y1 // zoomed_supertile_pixel_height))
        
        # End column/row (exclusive) needed to cover the viewport
        end_st_col = min(map_width, int(math.ceil((view_content_x1 + canvas_viewport_width) / zoomed_supertile_pixel_width)))
        end_st_row = min(map_height, int(math.ceil((view_content_y1 + canvas_viewport_height) / zoomed_supertile_pixel_height)))
        
        _debug(f" draw_map_canvas: Visible STs - Cols: {start_st_col}-{end_st_col-1}, Rows: {start_st_row}-{end_st_row-1}")

        rendered_st_count = 0
        for r_map in range(start_st_row, end_st_row):
            for c_map in range(start_st_col, end_st_col):
                if not (0 <= r_map < map_height and 0 <= c_map < map_width): # Should be redundant due to loop bounds
                    continue
                
                try:
                    supertile_idx = map_data[r_map][c_map]
                    
                    # Get the scaled Pillow Image for this supertile
                    pil_supertile_render = self.create_map_render_of_supertile(
                        supertile_idx, 
                        round(zoomed_supertile_pixel_width), # Pass rounded int sizes
                        round(zoomed_supertile_pixel_height)
                    )

                    if pil_supertile_render:
                        # Calculate paste position on the pil_map_viewport_image
                        # Target X,Y on the viewport image is the ST's content position MINUS the scroll offset
                        content_st_x = c_map * zoomed_supertile_pixel_width
                        content_st_y = r_map * zoomed_supertile_pixel_height
                        
                        paste_x_on_viewport_img = round(content_st_x - view_content_x1)
                        paste_y_on_viewport_img = round(content_st_y - view_content_y1)
                        
                        # Paste (Pillow handles clipping if ST partially outside viewport bounds for paste)
                        self.pil_map_viewport_image.paste(pil_supertile_render, (paste_x_on_viewport_img, paste_y_on_viewport_img))
                        rendered_st_count +=1
                except IndexError:
                    _error(f" draw_map_canvas: IndexError for map_data[{r_map}][{c_map}]")
                except Exception as e_render_st:
                    _error(f" draw_map_canvas: Error rendering/pasting ST ({r_map},{c_map}): {e_render_st}")
        
        _debug(f" draw_map_canvas: Rendered {rendered_st_count} supertiles onto Pillow viewport image.")

        # --- 6. Convert Pillow Viewport Image to Tk PhotoImage and Display ---
        try:
            self.tk_map_photoimage = ImageTk.PhotoImage(self.pil_map_viewport_image)
        except Exception as e_photoimg:
            _error(f" draw_map_canvas: Error converting PIL to Tk PhotoImage: {e_photoimg}")
            return

        # Place the single viewport image onto the canvas at the current scroll position
        # This ensures it aligns with other canvas items drawn using content coordinates.
        try:
            if canvas.winfo_exists():
                canvas.create_image(view_content_x1, view_content_y1, 
                                    image=self.tk_map_photoimage, 
                                    anchor=tk.NW, 
                                    tags=("map_render_image", "all_map_content")) # New specific tag
        except tk.TclError as e_create_img:
            _debug(f" draw_map_canvas: TclError creating canvas image: {e_create_img}")


        # --- 7. Re-draw Overlays (Grid, Selection, Window View, Paste Preview, HIGHLIGHTS) ---
        # These are drawn directly on the canvas, on top of the "map_render_image".
        
        canvas.delete("supertile_grid") # Delete old grid lines
        if self.show_supertile_grid.get():
            grid_color = GRID_COLOR_CYCLE[self.grid_color_index]
            # Draw vertical lines
            for c_grid in range(map_width + 1):
                x_line = c_grid * zoomed_supertile_pixel_width
                if x_line >= view_content_x1 and x_line <= view_content_x1 + canvas_viewport_width + zoomed_supertile_pixel_width : # Optimization for visibility
                     canvas.create_line(x_line, 0, x_line, map_content_pixel_height_total, 
                                        fill=grid_color, dash=GRID_DASH_PATTERN, tags="supertile_grid")
            # Draw horizontal lines
            for r_grid in range(map_height + 1):
                y_line = r_grid * zoomed_supertile_pixel_height
                if y_line >= view_content_y1 and y_line <= view_content_y1 + canvas_viewport_height + zoomed_supertile_pixel_height: # Optimization
                    canvas.create_line(0, y_line, map_content_pixel_width_total, y_line,
                                       fill=grid_color, dash=GRID_DASH_PATTERN, tags="supertile_grid")
            if canvas.find_withtag("map_render_image"): # Ensure grid is above map image if both exist
                canvas.tag_raise("supertile_grid", "map_render_image")


        self._draw_selection_rectangle() # This deletes old and draws new selection_rect_id
        
        canvas.delete("map_highlight_border") # Delete old highlight frames
        if self.highlighted_map_cells:
            for r_highlight, c_highlight in self.highlighted_map_cells:
                # Calculate pixel coordinates for this highlighted cell
                px1_h = c_highlight * zoomed_supertile_pixel_width
                py1_h = r_highlight * zoomed_supertile_pixel_height
                px2_h = px1_h + zoomed_supertile_pixel_width
                py2_h = py1_h + zoomed_supertile_pixel_height
                
                # Check if this cell is even potentially visible before creating the rectangle
                if (px2_h > view_content_x1 and px1_h < view_content_x1 + canvas_viewport_width and
                    py2_h > view_content_y1 and py1_h < view_content_y1 + canvas_viewport_height):
                    canvas.create_rectangle(
                        px1_h, py1_h, px2_h, py2_h,
                        outline="blue",
                        width=3, # Use a thick outline consistent with other highlights
                        tags=("map_highlight_border", "all_map_content")
                    )

        canvas.delete("window_view_item") # Delete all old window view components
        if self.show_window_view.get():
            win_px_start = self.window_view_tile_x * zoomed_tile_size
            win_py_start = self.window_view_tile_y * zoomed_tile_size
            win_pixel_width_total = self.window_view_tile_w.get() * zoomed_tile_size
            win_pixel_height_total = self.window_view_tile_h.get() * zoomed_tile_size
            win_color = GRID_COLOR_CYCLE[self.grid_color_index] # Or a dedicated window view color

            canvas.create_rectangle(win_px_start, win_py_start, 
                                    win_px_start + win_pixel_width_total, 
                                    win_py_start + win_pixel_height_total, 
                                    outline=win_color, width=2, tags=("window_view_rect", "window_view_item"))
            
            if self.window_view_tile_h.get() == MAX_WIN_VIEW_HEIGHT_TILES: 
                half_tile_h_px_zoomed = zoomed_tile_size / 2
                dark_y1 = win_py_start + win_pixel_height_total - half_tile_h_px_zoomed
                dark_y2 = win_py_start + win_pixel_height_total
                canvas.create_rectangle(win_px_start, dark_y1, 
                                        win_px_start + win_pixel_width_total, dark_y2, 
                                        fill="gray50", stipple="gray50", outline="", tags=("window_view_overscan", "window_view_item"))
            
            handle_size = WIN_VIEW_HANDLE_SIZE; hs2 = handle_size // 2
            handle_fill = win_color
            handle_outline = "black" if win_color != "#000000" else "white"
            handles_coords = { 
                "nw": (win_px_start, win_py_start), 
                "n": (win_px_start + win_pixel_width_total / 2, win_py_start), 
                "ne": (win_px_start + win_pixel_width_total, win_py_start),
                "w": (win_px_start, win_py_start + win_pixel_height_total / 2),
                "e": (win_px_start + win_pixel_width_total, win_py_start + win_pixel_height_total / 2),
                "sw": (win_px_start, win_py_start + win_pixel_height_total), 
                "s": (win_px_start + win_pixel_width_total / 2, win_py_start + win_pixel_height_total), 
                "se": (win_px_start + win_pixel_width_total, win_py_start + win_pixel_height_total),
            }
            for tag_handle, (cx_handle, cy_handle) in handles_coords.items():
                x1h, y1h, x2h, y2h = cx_handle - hs2, cy_handle - hs2, cx_handle + hs2, cy_handle + hs2
                canvas.create_rectangle(x1h, y1h, x2h, y2h, fill=handle_fill, outline=handle_outline, width=1, tags=("window_view_handle", f"handle_{tag_handle}", "window_view_item"))

            if canvas.find_withtag("map_render_image"): # Ensure window view is on top
                canvas.tag_raise("window_view_item", "map_render_image")
            if canvas.find_withtag("selection_rect"):
                canvas.tag_raise("window_view_item", "selection_rect") # Window view on top of selection
            if canvas.find_withtag("supertile_grid"):
                 canvas.tag_raise("window_view_item", "supertile_grid")

        if self.map_paste_preview_rect_id:
            canvas.tag_raise(self.map_paste_preview_rect_id)


        # --- 8. Update Zoom Label ---
        if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
            self.map_zoom_label.config(text=f"{int(self.map_zoom_level * 100)}%")
        
        _debug(" draw_map_canvas: End.")

    def update_map_info_labels(self):
        self.map_size_label.config(text=f"{map_width} x {map_height}")
        self.map_supertile_select_label.config(
            text=f"Selected Supertile for Painting: {selected_supertile_for_map}"
        )
        # Update window size entries from state variables
        self.window_view_tile_w.set(
            self.window_view_tile_w.get()
        )  # Ensure IntVar reflects internal state if needed
        self.window_view_tile_h.set(self.window_view_tile_h.get())
        # Zoom label updated in draw_map_canvas

    def on_tab_change(self, event):
        current_tab_index = -1
        new_tab_index = -1
        selected_tab_widget = None

        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab_path = self.notebook.select()
                if selected_tab_path:
                    new_tab_index = self.notebook.index(selected_tab_path)
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
        except tk.TclError:
            _debug(" on_tab_change: TclError getting current tab info.")
            pass 

        if self.map_paste_preview_rect_id: 
            self._clear_paste_preview_rect()

        if selected_tab_widget == self.tab_palette_editor:
            self.update_palette_info_labels()

        self.update_all_displays(changed_level="all")

        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()

        try:
            self.root.unbind("<KeyPress-g>") 
            self.root.unbind("<KeyPress-G>")
            self.root.unbind("<Escape>")
        except tk.TclError:
            pass 

        if selected_tab_widget == self.tab_map_editor: 
            _debug(" on_tab_change: Map Editor tab selected.")
            self.root.bind("<KeyPress-g>", self.handle_map_tab_keypress, add="+")
            self.root.bind("<KeyPress-G>", self.handle_map_tab_keypress, add="+")
            
            if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                self.root.after_idle(self.map_canvas.focus_set)

            def enforce_map_pane_minimums_after_tab_change():
                _debug(" on_tab_change: Map tab visible, performing delayed pane minimum check.")
                if hasattr(self, 'map_paned_window') and self.map_paned_window.winfo_exists() and self.map_paned_window.winfo_ismapped():
                    self._do_check_and_enforce_palette_min_width()
                else:
                    _debug(" on_tab_change: Map paned window not ready for min width enforcement yet.")
            
            self.root.after_idle(enforce_map_pane_minimums_after_tab_change)
            
        elif selected_tab_widget in [self.tab_tile_editor, self.tab_supertile_editor]:
            _debug(f" on_tab_change: Binding Escape key for {selected_tab_widget.winfo_class()} tab.")
            self.root.bind("<Escape>", self.handle_editor_escape)

        self.root.after_idle(self._update_map_cursor)

    # --- Palette Editor Handlers ---
    def handle_current_palette_click(self, event):
        canvas = self.current_palette_canvas
        size = CURRENT_PALETTE_SLOT_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        clicked_slot = row * 4 + col

        if not (0 <= clicked_slot < 16):
            return

        if self.selected_palette_slot != clicked_slot:
            self.selected_palette_slot = clicked_slot
            self.draw_current_palette()
            self.update_palette_info_labels()
        
        self.drag_item_type = "palette_color"
        self.drag_start_index = clicked_slot
        self.drag_press_x = event.x
        self.drag_press_y = event.y
        self.drag_canvas = canvas

    def handle_512_picker_click(self, event):
        if not (0 <= self.selected_palette_slot < 16):
            messagebox.showwarning("Palette Picker", "No active palette slot selected to apply color to.", parent=self.root)
            return
            
        canvas = self.msx2_picker_canvas
        size = MSX2_PICKER_SQUARE_SIZE
        padding = 1
        cols = MSX2_PICKER_COLS

        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        col = int(canvas_x // (size + padding))
        row = int(canvas_y // (size + padding))
        
        if not (0 <= col < MSX2_PICKER_COLS and 0 <= row < MSX2_PICKER_ROWS):
            _debug("512 Picker click outside valid grid.")
            return

        clicked_index_in_512_palette = row * MSX2_PICKER_COLS + col
        
        if 0 <= clicked_index_in_512_palette < 512:
            new_color_hex = msx2_512_colors_hex[clicked_index_in_512_palette]
            target_slot_in_active_palette = self.selected_palette_slot

            if self.active_msx_palette[target_slot_in_active_palette] != new_color_hex:
                command = SetPaletteColorCommand(self, target_slot_in_active_palette, new_color_hex)
                self.undo_manager.execute(command)
        else:
            _debug(f"512 Picker clicked_index {clicked_index_in_512_palette} out of 0-511 range.")

    def handle_rgb_apply(self):
        if not (0 <= self.selected_palette_slot < 16):
            messagebox.showwarning("Set Color", "No active palette slot selected.", parent=self.root)
            return
        try:
            # Coerce final values before applying
            self._handle_color_input_coerce(self.rgb9_r_var, "9bit")
            self._handle_color_input_coerce(self.rgb9_g_var, "9bit")
            self._handle_color_input_coerce(self.rgb9_b_var, "9bit")

            r_val = int(self.rgb9_r_var.get())
            g_val = int(self.rgb9_g_var.get())
            b_val = int(self.rgb9_b_var.get())

            # Validation is implicitly handled by the coercion logic
            new_color_hex = self._rgb7_to_hex(r_val, g_val, b_val)
            target_slot = self.selected_palette_slot
            
            if self.active_msx_palette[target_slot] != new_color_hex:
                command = SetPaletteColorCommand(self, target_slot, new_color_hex)
                self.undo_manager.execute(command)

        except (ValueError, tk.TclError) as e:
            messagebox.showerror("Invalid Input", f"Could not set color due to invalid input values.", parent=self.root)
        except Exception as e_unexp:
            messagebox.showerror("Error Applying Color", f"An unexpected error occurred: {e_unexp}", parent=self.root)
            _error(f" Unexpected error in handle_rgb_apply: {e_unexp}")

    def reset_palette_to_default(self):
        confirm = messagebox.askokcancel(
            "Reset Palette",
            "Reset the active palette to the MSX2 default colors?\nThis will affect the appearance of all tiles and supertiles.",
            parent=self.root
        )
        if confirm:
            new_default_palette_hex = []
            for r_val, g_val, b_val in MSX2_RGB7_VALUES: 
                new_default_palette_hex.append(self._rgb7_to_hex(r_val, g_val, b_val))
        
            if self.active_msx_palette != new_default_palette_hex:
                
                # The setter should modify the list's contents, not replace the list object itself.
                def palette_setter(palette_data):
                    global selected_color_index
                    self.active_msx_palette[:] = palette_data
                    self.selected_palette_slot = 0
                    selected_color_index = WHITE_IDX
                    # These side-effects are still needed here because they are
                    # specific to this high-level "reset" action.
                    self.clear_all_caches()
                    self.invalidate_minimap_background_cache()
                    self._request_color_usage_refresh()
                    self._request_tile_usage_refresh()
                    self._request_supertile_usage_refresh()

                command = SetDataCommand(
                    "Reset Palette",
                    self,
                    palette_setter,
                    new_default_palette_hex,
                    list(self.active_msx_palette) # Pass a copy of the old data
                )
                self.undo_manager.execute(command)
                _debug("Palette reset to MSX2 defaults.")
            else:
                _debug("Palette is already set to MSX2 defaults. No changes made.")

    # --- Tile Editor Handlers ---
    def handle_editor_click(self, event):
        global last_drawn_pixel, current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return
        
        self.pending_command_list.clear()
        self.is_currently_painting_tile = True 
        c = event.x // EDITOR_PIXEL_SIZE
        r = event.y // EDITOR_PIXEL_SIZE

        if 0 <= r < TILE_HEIGHT and 0 <= c < TILE_WIDTH:
            if r >= len(tileset_patterns[current_tile_index]) or c >= len(tileset_patterns[current_tile_index][r]):
                _debug(f"Editor click out of pattern bounds for tile {current_tile_index} at {r},{c}")
                last_drawn_pixel = (r, c)
                return

            pixel_value_to_set = 1 if event.num == 1 else 0
            
            if tileset_patterns[current_tile_index][r][c] != pixel_value_to_set:
                command = PaintPixelCommand(self, current_tile_index, r, c, pixel_value_to_set)
                command.execute() # Apply change immediately for visual feedback
                self.pending_command_list.append(command)
                self.update_all_displays(changed_level="tile_edit")
                
            last_drawn_pixel = (r, c)

    def handle_editor_drag(self, event):
        global last_drawn_pixel, current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return
        
        self.is_currently_painting_tile = True 
        c = event.x // EDITOR_PIXEL_SIZE
        r = event.y // EDITOR_PIXEL_SIZE

        if 0 <= r < TILE_HEIGHT and 0 <= c < TILE_WIDTH:
            if (r, c) != last_drawn_pixel:
                # This critical bounds check is preserved.
                if r >= len(tileset_patterns[current_tile_index]) or c >= len(tileset_patterns[current_tile_index][r]):
                    _debug(f"Editor drag out of pattern bounds for tile {current_tile_index} at {r},{c}")
                    last_drawn_pixel = (r, c)
                    return

                pixel_value_to_set = -1
                if event.state & 0x100: # Left mouse button drag
                    pixel_value_to_set = 1
                elif event.state & 0x400: # Right mouse button drag
                    pixel_value_to_set = 0
                
                if (pixel_value_to_set != -1 and
                    tileset_patterns[current_tile_index][r][c] != pixel_value_to_set):
                  
                    command = PaintPixelCommand(self, current_tile_index, r, c, pixel_value_to_set)
                    command.execute() # Apply change immediately for visual feedback
                    self.pending_command_list.append(command)
                    self.update_all_displays(changed_level="tile_edit")

                last_drawn_pixel = (r, c)

    def handle_tile_editor_palette_click(self, event):
        global selected_color_index
        
        # Cancel any pending single-click action from a previous click
        if self.single_click_timer is not None:
            self.root.after_cancel(self.single_click_timer)
            self.single_click_timer = None

        canvas = self.tile_editor_palette_canvas
        size = PALETTE_SQUARE_SIZE
        padding = 2
        col = event.x // (size + padding)
        row = event.y // (size + padding)
        clicked_index = row * 4 + col

        def select_color(index_to_select):
            global selected_color_index
            if 0 <= index_to_select < 16:
                if selected_color_index != index_to_select:
                    selected_color_index = index_to_select
                    self.draw_palette()

        # Schedule the selection to happen after a delay
        if 0 <= clicked_index < 16:
            self.single_click_timer = self.root.after(250, lambda: select_color(clicked_index))

    def set_row_color(self, row, fg_or_bg):
        global tileset_colors, current_tile_index, selected_color_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return
        if not (0 <= selected_color_index < 16):
            messagebox.showwarning("Set Row Color", "No valid color selected from palette.", parent=self.root)
            return
            
        if 0 <= row < TILE_HEIGHT:
            if row >= len(tileset_colors[current_tile_index]):
                _error(f"Row {row} out of bounds for tile {current_tile_index} color data.")
                return

            current_fg_idx, current_bg_idx = tileset_colors[current_tile_index][row]
            changed = False
            
            if fg_or_bg == "fg" and current_fg_idx != selected_color_index:
                changed = True
            elif fg_or_bg == "bg" and current_bg_idx != selected_color_index:
                changed = True
            
            if changed:
                command = SetRowColorCommand(self, current_tile_index, row, fg_or_bg, selected_color_index)
                self.undo_manager.execute(command)

    def handle_tileset_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "tile"
        )

        self.drag_active = False 
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0 
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id) # Use current canvas
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < len(tileset_patterns):
            self.drag_item_type = "tile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x 
            self.drag_press_y = event.y 
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def flip_tile_horizontal(self):
        global tileset_patterns, current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return

        command = TransformCommand("Flip Tile Horizontal", self, tileset_patterns, current_tile_index, self.invalidate_tile_cache)

        # Original flip logic (modifies global state)
        current_pattern = tileset_patterns[current_tile_index]
        new_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        for r in range(TILE_HEIGHT):
            new_pattern[r] = current_pattern[r][::-1]
        tileset_patterns[current_tile_index] = new_pattern
        
        # Capture the result of the modification
        command.capture_new_state()
        self.undo_manager.execute(command)

    def flip_tile_vertical(self):
        global tileset_patterns, tileset_colors, current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return

        # Create a command for each data list that will be changed
        pattern_command = TransformCommand("Flip Tile Vertical", self, tileset_patterns, current_tile_index, self.invalidate_tile_cache)
        color_command = TransformCommand("Flip Tile Vertical", self, tileset_colors, current_tile_index, self.invalidate_tile_cache)

        # Original flip logic
        tileset_patterns[current_tile_index].reverse()
        tileset_colors[current_tile_index].reverse()
        
        # Capture the new state for both commands
        pattern_command.capture_new_state()
        color_command.capture_new_state()
        
        # Group them into a single undoable action
        composite_command = CompositeCommand("Flip Tile Vertical", [pattern_command, color_command])
        self.undo_manager.execute(composite_command)

    def rotate_tile_90cw(self):
        global tileset_patterns, tileset_colors, current_tile_index, WHITE_IDX, BLACK_IDX
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return

        pattern_command = TransformCommand("Rotate Tile", self, tileset_patterns, current_tile_index, self.invalidate_tile_cache)
        color_command = TransformCommand("Rotate Tile", self, tileset_colors, current_tile_index, self.invalidate_tile_cache)

        # Original rotate logic
        current_pattern = tileset_patterns[current_tile_index]
        new_pattern = [[0 for _ in range(TILE_WIDTH)] for _ in range(TILE_HEIGHT)]
        for r in range(TILE_HEIGHT):
            for c in range(TILE_WIDTH):
                new_pattern[c][(TILE_HEIGHT - 1) - r] = current_pattern[r][c]
        tileset_patterns[current_tile_index] = new_pattern
        tileset_colors[current_tile_index] = [
            (WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)
        ]  
        
        pattern_command.capture_new_state()
        color_command.capture_new_state()

        composite_command = CompositeCommand("Rotate Tile", [pattern_command, color_command])
        self.undo_manager.execute(composite_command)
        
        messagebox.showinfo(
            "Rotation Complete", "Tile rotated.\nRow colors have been reset to default."
        )

    def shift_tile_up(self):
        global tileset_patterns, tileset_colors, current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            messagebox.showwarning("Shift Tile", "No valid tile selected to shift.", parent=self.root)
            return
        if not (len(tileset_patterns[current_tile_index]) == TILE_HEIGHT and 
                len(tileset_colors[current_tile_index]) == TILE_HEIGHT):
            _error(f"Tile {current_tile_index} data is malformed. Cannot shift up.")
            messagebox.showerror("Shift Error", f"Tile {current_tile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return

        pattern_command = TransformCommand("Shift Tile Up", self, tileset_patterns, current_tile_index, self.invalidate_tile_cache)
        color_command = TransformCommand("Shift Tile Up", self, tileset_colors, current_tile_index, self.invalidate_tile_cache)

        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        first_pattern_row = current_pattern.pop(0)
        first_color_row = current_colors.pop(0)
        current_pattern.append(first_pattern_row)
        current_colors.append(first_color_row)
        
        pattern_command.capture_new_state()
        color_command.capture_new_state()
        
        composite_command = CompositeCommand("Shift Tile Up", [pattern_command, color_command])
        self.undo_manager.execute(composite_command)
        
    def shift_tile_down(self):
        global tileset_patterns, tileset_colors, current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            messagebox.showwarning("Shift Tile", "No valid tile selected to shift.", parent=self.root)
            return
        if not (len(tileset_patterns[current_tile_index]) == TILE_HEIGHT and 
                len(tileset_colors[current_tile_index]) == TILE_HEIGHT):
            _error(f"Tile {current_tile_index} data is malformed. Cannot shift down.")
            messagebox.showerror("Shift Error", f"Tile {current_tile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return

        pattern_command = TransformCommand("Shift Tile Down", self, tileset_patterns, current_tile_index, self.invalidate_tile_cache)
        color_command = TransformCommand("Shift Tile Down", self, tileset_colors, current_tile_index, self.invalidate_tile_cache)

        current_pattern = tileset_patterns[current_tile_index]
        current_colors = tileset_colors[current_tile_index]
        last_pattern_row = current_pattern.pop(-1)
        last_color_row = current_colors.pop(-1)
        current_pattern.insert(0, last_pattern_row)
        current_colors.insert(0, last_color_row)
        
        pattern_command.capture_new_state()
        color_command.capture_new_state()
        
        composite_command = CompositeCommand("Shift Tile Down", [pattern_command, color_command])
        self.undo_manager.execute(composite_command)
        
    def shift_tile_left(self):
        global tileset_patterns, current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            messagebox.showwarning("Shift Tile", "No valid tile selected to shift.", parent=self.root)
            return
        current_pattern = tileset_patterns[current_tile_index]
        if not (isinstance(current_pattern, list) and 
                len(current_pattern) == TILE_HEIGHT and
                all(isinstance(row, list) and len(row) == TILE_WIDTH for row in current_pattern)):
            _error(f"Tile {current_tile_index} pattern data is malformed. Cannot shift left.")
            messagebox.showerror("Shift Error", f"Tile {current_tile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return
        
        command = TransformCommand("Shift Tile Left", self, tileset_patterns, current_tile_index, self.invalidate_tile_cache)

        for r_idx_shift in range(TILE_HEIGHT):
            row_data = current_pattern[r_idx_shift]
            first_pixel_val = row_data.pop(0)
            row_data.append(first_pixel_val)
        
        command.capture_new_state()
        self.undo_manager.execute(command)
        
    def shift_tile_right(self):
        global tileset_patterns, current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            messagebox.showwarning("Shift Tile", "No valid tile selected to shift.", parent=self.root)
            return
        current_pattern = tileset_patterns[current_tile_index]
        if not (isinstance(current_pattern, list) and 
                len(current_pattern) == TILE_HEIGHT and
                all(isinstance(row, list) and len(row) == TILE_WIDTH for row in current_pattern)):
            _error(f"Tile {current_tile_index} pattern data is malformed. Cannot shift right.")
            messagebox.showerror("Shift Error", f"Tile {current_tile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return
        
        command = TransformCommand("Shift Tile Right", self, tileset_patterns, current_tile_index, self.invalidate_tile_cache)

        for r_idx_shift_r in range(TILE_HEIGHT):
            row_data = current_pattern[r_idx_shift_r]
            last_pixel_val = row_data.pop(-1)
            row_data.insert(0, last_pixel_val)
        
        command.capture_new_state()
        self.undo_manager.execute(command)
        
    # --- Supertile Editor Handlers ---
    def handle_st_tileset_click(self, event):
        # Cancel any pending single-click action from a previous click
        if self.single_click_timer is not None:
            self.root.after_cancel(self.single_click_timer)
            self.single_click_timer = None

        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "tile"
        )

        # Reset drag state immediately, as this handler is for clicks.
        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        # This part sets up the drag-and-drop state, which is fine to do instantly.
        # The actual selection action will be delayed.
        if 0 <= clicked_index < len(tileset_patterns):
            self.drag_item_type = "tile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas

            # Define the action to be performed on a single-click
            def select_tile_for_supertile(index_to_select):
                global selected_tile_for_supertile
                if selected_tile_for_supertile != index_to_select:
                    selected_tile_for_supertile = index_to_select
                    self.draw_tileset_viewer(canvas, selected_tile_for_supertile)
                    self._update_st_tab_selected_tile_info_panel()
                    self.scroll_viewers_to_tile(selected_tile_for_supertile)

            # Schedule the selection to happen after a delay
            self.single_click_timer = self.root.after(250, lambda: select_tile_for_supertile(clicked_index))

    def handle_supertile_def_click(self, event):
        if not (0 <= selected_tile_for_supertile < len(tileset_patterns)):
            messagebox.showwarning("Place Tile", "Please select a valid tile first.")
            return
            
        canvas = self.supertile_def_canvas
        mini_tile_display_size = SUPERTILE_DEF_TILE_SIZE
        if mini_tile_display_size <= 0: return
        col = event.x // mini_tile_display_size
        row = event.y // mini_tile_display_size
        
        self.pending_command_list.clear()
        
        if self._place_tile_in_supertile(row, col): # This now returns True if a change was made
            self.last_placed_supertile_cell = (row, col)

    def handle_supertile_selector_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "supertile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < len(supertiles_data):
            self.drag_item_type = "supertile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    # --- Map Editor Handlers ---
    def handle_map_supertile_selector_click(self, event):
        canvas = event.widget
        clicked_index = self._get_index_from_canvas_coords(
            canvas, event.x, event.y, "supertile"
        )

        self.drag_active = False
        self.drag_item_type = None
        self.drag_start_index = -1
        self.drag_press_x = 0
        self.drag_press_y = 0
        self.drag_canvas = None
        if self.drag_indicator_id:
            try:
                event.widget.delete(self.drag_indicator_id)
            except tk.TclError:
                pass
            self.drag_indicator_id = None
        try:
            if canvas.winfo_exists(): canvas.config(cursor="")
        except tk.TclError: pass

        if 0 <= clicked_index < len(supertiles_data):
            self.drag_item_type = "supertile"
            self.drag_start_index = clicked_index
            self.drag_press_x = event.x
            self.drag_press_y = event.y
            self.drag_canvas = canvas
            # self.drag_active is NOT set to True here

    def _paint_map_cell(self, canvas_x, canvas_y):
        global map_data, last_painted_map_cell, selected_supertile_for_map

        zoomed_st_w, zoomed_st_h = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_w <= 0 or zoomed_st_h <= 0:
            return

        c_map = int(canvas_x // zoomed_st_w)
        r_map = int(canvas_y // zoomed_st_h)

        if not (0 <= r_map < map_height and 0 <= c_map < map_width):
            return

        current_cell_id = (r_map, c_map)
        try:
            current_data_val = map_data[r_map][c_map]
        except IndexError:
            _error(f"IndexError accessing map_data[{r_map}][{c_map}]. Map size: {map_width}x{map_height}")
            return

        if current_cell_id != last_painted_map_cell: 
            if current_data_val != selected_supertile_for_map:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass 

                command = PaintMapCellCommand(self, r_map, c_map, selected_supertile_for_map)
                command.execute() # Apply change immediately
                self.pending_command_list.append(command)
                
                self._mark_project_modified()
                self.draw_map_canvas() 
                self.draw_minimap()    
                self._request_supertile_usage_refresh()

            last_painted_map_cell = current_cell_id

    def _do_window_move_drag(self, current_canvas_x, current_canvas_y):
        """Helper: Calculates and applies window movement during drag."""
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        delta_x_pixels = current_canvas_x - self.drag_start_x
        delta_y_pixels = current_canvas_y - self.drag_start_y

        delta_tile_x = math.floor(delta_x_pixels / zoomed_tile_size)
        delta_tile_y = math.floor(delta_y_pixels / zoomed_tile_size)

        new_tx = self.drag_start_win_tx + delta_tile_x
        new_ty = self.drag_start_win_ty + delta_tile_y

        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()
        max_tile_x = max(0, (map_width * self.supertile_grid_width) - current_w)
        max_tile_y = max(0, (map_height * self.supertile_grid_height) - current_h)
        clamped_tx = max(0, min(new_tx, max_tile_x))
        clamped_ty = max(0, min(new_ty, max_tile_y))

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()
            self.draw_minimap()

    def _do_window_resize_drag(self, current_canvas_x, current_canvas_y):
        """Helper: Calculates and applies window resize during drag."""
        zoomed_tile_size = self.get_zoomed_tile_size()
        if zoomed_tile_size <= 0:
            return

        start_tx = self.drag_start_win_tx
        start_ty = self.drag_start_win_ty
        start_tw = self.drag_start_win_tw
        start_th = self.drag_start_win_th
        start_br_tx = start_tx + start_tw
        start_br_ty = start_ty + start_th

        current_tile_x = math.floor(current_canvas_x / zoomed_tile_size)
        current_tile_y = math.floor(current_canvas_y / zoomed_tile_size)

        new_tx = start_tx
        new_ty = start_ty
        new_br_tx = start_br_tx
        new_br_ty = start_br_ty
        handle = self.window_view_resize_handle

        if "n" in handle:
            new_ty = current_tile_y
        if "s" in handle:
            new_br_ty = current_tile_y + 1
        if "w" in handle:
            new_tx = current_tile_x
        if "e" in handle:
            new_br_tx = current_tile_x + 1

        new_tx = min(new_tx, new_br_tx - 1)
        new_ty = min(new_ty, new_br_ty - 1)
        new_br_tx = max(new_br_tx, new_tx + 1)
        new_br_ty = max(new_br_ty, new_ty + 1)

        new_tw = new_br_tx - new_tx
        new_th = new_br_ty - new_ty

        min_w, max_w = 1, 32
        min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
        clamped_tw = max(min_w, min(new_tw, max_w))
        clamped_th = max(min_h, min(new_th, max_h))

        if "n" in handle and clamped_th != new_th:
            new_ty = new_br_ty - clamped_th
        if "w" in handle and clamped_tw != new_tw:
            new_tx = new_br_tx - clamped_tw

        max_map_tile_x = map_width * self.supertile_grid_width
        max_map_tile_y = map_height * self.supertile_grid_height

        clamped_tx = max(0, min(new_tx, max_map_tile_x - clamped_tw))
        clamped_ty = max(0, min(new_ty, max_map_tile_y - clamped_th))

        final_tw = min(clamped_tw, max_map_tile_x - clamped_tx)
        final_th = min(clamped_th, max_map_tile_y - clamped_ty)

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
            or self.window_view_tile_w.get() != final_tw
            or self.window_view_tile_h.get() != final_th
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.window_view_tile_w.set(final_tw)
            self.window_view_tile_h.set(final_th)
            self.draw_map_canvas()
            self.draw_minimap()

    def move_window_view_keyboard(self, dx_tile, dy_tile):
        """Moves the window view by dx, dy TILE steps."""
        if not self.show_window_view.get():
            return

        new_tx = self.window_view_tile_x + dx_tile
        new_ty = self.window_view_tile_y + dy_tile

        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()

        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height
        
        max_tile_x = max(0, total_map_tiles_w - current_w)
        max_tile_y = max(0, total_map_tiles_h - current_h)

        clamped_tx = max(0, min(new_tx, max_tile_x))
        clamped_ty = max(0, min(new_ty, max_tile_y))

        if (
            self.window_view_tile_x != clamped_tx
            or self.window_view_tile_y != clamped_ty
        ):
            self.window_view_tile_x = clamped_tx
            self.window_view_tile_y = clamped_ty
            self.draw_map_canvas()
            self.draw_minimap()

    def handle_map_keypress(self, event):
        """Handles key presses when the map canvas has focus (WASD, G)."""

        # If Ctrl or Alt is pressed, ignore this local binding and let it
        # propagate to the global root-level bindings (like Ctrl+S).
        if self.is_ctrl_pressed or self.is_alt_pressed:
            return

        key = event.keysym.lower()  # Get lowercase keysym

        if self.show_window_view.get():
            moved = False
            if key == "w":
                self.move_window_view_keyboard(0, -1)
                moved = True
            elif key == "a":
                self.move_window_view_keyboard(-1, 0)
                moved = True
            elif key == "s":
                self.move_window_view_keyboard(0, 1)
                moved = True
            elif key == "d":
                self.move_window_view_keyboard(1, 0)
                moved = True

            if moved:
                return "break"

    # --- Map Zoom Handlers ---
    def handle_map_zoom_scroll(self, event):
        # Handles Ctrl+MouseWheel zooming, centered on cursor, with dynamic factor.
        canvas = self.map_canvas
        current_zoom = self.map_zoom_level # Get current zoom level

        # Determine dynamic zoom factor based on current_zoom
        factor = 0.0
        zoom_direction_in = (event.num == 4 or event.delta > 0) # True if zooming in

        if current_zoom < 0.25: # Zoomed out
            factor = 1.75 if zoom_direction_in else 1 / 1.75
        elif current_zoom < 0.75: # Zoomed out
            factor = 1.5 if zoom_direction_in else 1 / 1.5
        elif current_zoom < 1.5:  # Near 100%
            factor = 1.25 if zoom_direction_in else 1 / 1.25
        elif current_zoom < 3.0:  # Zoomed in
            factor = 1.15 if zoom_direction_in else 1 / 1.15
        else: # Very zoomed in
            factor = 1.1 if zoom_direction_in else 1 / 1.1
        
        if factor == 0.0: # Should not happen with the logic above, but as a safe guard
             _debug(" handle_map_zoom_scroll: Factor is 0, aborting zoom.")
             return

        _debug(f" handle_map_zoom_scroll: Current zoom={current_zoom:.3f}, DirectionIn={zoom_direction_in}, Calculated factor={factor:.3f}")

        # Get mouse position relative to canvas content (scrolled coords)
        # These are the content coordinates of the point to keep fixed.
        zoom_x_canvas_content = canvas.canvasx(event.x)
        zoom_y_canvas_content = canvas.canvasy(event.y)

        # Perform zoom centered on the cursor using the determined factor
        # The zoom_map_at_point function already contains the logic to check
        # if the new zoom level will result in a visual change.
        self.zoom_map_at_point(factor, zoom_x_canvas_content, zoom_y_canvas_content)

    def set_map_zoom(self, new_zoom_level):
        # Sets absolute zoom level, centered on current canvas center.
        min_zoom, max_zoom = 0.2, 6.0  # Definitive min_zoom
        
        try:
            requested_zoom_float = float(new_zoom_level)
        except ValueError:
            _debug(f" set_map_zoom: Invalid new_zoom_level '{new_zoom_level}'. Cannot convert to float.")
            return

        # Clamp the requested zoom to min/max bounds immediately
        safe_target_zoom = max(min_zoom, min(max_zoom, requested_zoom_float))
        
        current_actual_zoom = self.map_zoom_level

        _debug(f" set_map_zoom: Requested={requested_zoom_float:.4f}, SafeClampedTarget={safe_target_zoom:.4f}, CurrentActual={current_actual_zoom:.4f}")

        # Check if a significant change is even requested after clamping
        if abs(current_actual_zoom - safe_target_zoom) > 1e-9: 
            # Calculate the factor needed to get from current_actual_zoom to safe_target_zoom
            factor = 1.0
            if abs(current_actual_zoom) > 1e-9: # Avoid division by zero
                factor = safe_target_zoom / current_actual_zoom
            elif abs(safe_target_zoom) > 1e-9: # If current is ~0, but target isn't, it's a large change
                 # Factor doesn't make sense here, zoom_map_at_point will handle it by directly setting to potential_new_zoom_float
                 # We can pass a factor that will result in safe_target_zoom,
                 # or let zoom_map_at_point handle it if current_actual_zoom is too small for factor.
                 # The call to zoom_map_at_point will use its internal current_zoom_float.
                 # The factor is relative to *that*.
                 pass # zoom_map_at_point will effectively set it to safe_target_zoom via its own logic

            _debug(f" set_map_zoom: Factor to apply (approx): {factor:.4f}")
            
            canvas = self.map_canvas
            if not canvas or not canvas.winfo_exists(): return

            center_x_content = canvas.canvasx(canvas.winfo_width() / 2)
            center_y_content = canvas.canvasy(canvas.winfo_height() / 2)
            _debug(f" set_map_zoom: Centering on content coords: ({center_x_content:.2f}, {center_y_content:.2f})")
            
            # Call zoom_map_at_point. It will calculate its own potential_new_zoom_float
            # based on its current_zoom_float and the passed factor.
            # This potential_new_zoom_float should end up being very close to our safe_target_zoom.
            self.zoom_map_at_point(factor, center_x_content, center_y_content)
        else:
            # Zoom level is already very close to target, ensure UI label is accurate based on the actual state
            _debug(f" set_map_zoom: No significant change needed or already at target. Current zoom: {self.map_zoom_level*100:.1f}%")
            if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
                try:
                    self.map_zoom_label.config(text=f"{int(self.map_zoom_level * 100)}%")
                except tk.TclError: pass

    def zoom_map_at_point(self, factor, zoom_x_canvas, zoom_y_canvas):
        # Zooms the map by 'factor', keeping the content point (zoom_x_canvas, zoom_y_canvas)
        # stationary relative to the viewport's top-left edge.
        # zoom_x_canvas and zoom_y_canvas are expected to be canvas *content* coordinates.

        canvas = self.map_canvas
        if not canvas or not canvas.winfo_exists(): # Check canvas existence early
            _debug(" zoom_map_at_point: Canvas does not exist. Aborting.")
            return

        current_zoom_float = self.map_zoom_level 
        
        min_zoom, max_zoom = 0.2, 6.0 # Definitive min_zoom
        
        # Calculate potential new zoom after applying factor
        calculated_val_after_factor = current_zoom_float * factor
        # Apply clamping
        potential_new_zoom_float = max(min_zoom, min(max_zoom, calculated_val_after_factor))
        
        _debug(f" zoom_map_at_point: --- Zoom Calculation Start ---")
        _debug(f" zoom_map_at_point: current_zoom_float={current_zoom_float:.4f}, factor={factor:.4f}")
        _debug(f" zoom_map_at_point: val_after_factor={calculated_val_after_factor:.4f}")
        _debug(f" zoom_map_at_point: potential_new_zoom_float (after all clamps min={min_zoom}, max={max_zoom})={potential_new_zoom_float:.4f}")

        base_display_size = TILE_WIDTH # Assuming TILE_WIDTH is the unscaled pixel size (e.g., 8)
        current_int_display_tile_size = max(1, int(base_display_size * current_zoom_float))
        potential_new_int_display_tile_size = max(1, int(base_display_size * potential_new_zoom_float))

        # Update the UI label with the (potentially clamped) new zoom level immediately
        if hasattr(self, 'map_zoom_label') and self.map_zoom_label.winfo_exists():
            try:
                self.map_zoom_label.config(text=f"{int(potential_new_zoom_float * 100)}%")
            except tk.TclError: pass # Ignore if label is being destroyed

        # Determine if a full redraw is warranted
        force_redraw_due_to_int_size_change = (current_int_display_tile_size != potential_new_int_display_tile_size)
        
        relative_zoom_change_threshold = 0.03 # e.g., 3% change
        significant_relative_float_change = False
        if current_zoom_float > 1e-9: # Avoid division by zero for relative change
            if abs(potential_new_zoom_float - current_zoom_float) / current_zoom_float > relative_zoom_change_threshold:
                significant_relative_float_change = True
        elif abs(potential_new_zoom_float - current_zoom_float) > (relative_zoom_change_threshold * min_zoom): # Use absolute for very small current_zoom
             significant_relative_float_change = True


        # Check if the change is just floating point noise / too small to matter visually if int size doesn't change
        is_just_noise_or_too_small_without_int_change = abs(potential_new_zoom_float - current_zoom_float) < 1e-7

        if not force_redraw_due_to_int_size_change and \
           not significant_relative_float_change and \
           is_just_noise_or_too_small_without_int_change:
            # Only update internal float zoom if it's not just noise, to keep label consistent
            if not is_just_noise_or_too_small_without_int_change and abs(potential_new_zoom_float - current_zoom_float) > 1e-9 :
                 self.map_zoom_level = potential_new_zoom_float
            _debug(f" zoom_map_at_point: No significant visual change expected. Zoom for label: {potential_new_zoom_float*100:.1f}%. Actual self.map_zoom_level: {self.map_zoom_level*100:.1f}%. Skipping full redraw.")
            _debug(f" zoom_map_at_point: --- Zoom Calculation End (Skipped Redraw) ---")
            return
        
        _debug(f" zoom_map_at_point: Proceeding with redraw. Old actual zoom: {current_zoom_float*100:.1f}%, New target zoom: {potential_new_zoom_float*100:.1f}%")
        _debug(f" zoom_map_at_point: Old int size: {current_int_display_tile_size}, New int size: {potential_new_int_display_tile_size}")
        _debug(f" zoom_map_at_point: SignificantRelFloatChange: {significant_relative_float_change}, ForceIntSizeChange: {force_redraw_due_to_int_size_change}")

        # Update the actual application zoom level state
        old_zoom_for_scale_calc = current_zoom_float # Use the float value before it's updated by self.map_zoom_level
        self.map_zoom_level = potential_new_zoom_float # This is the new definitive zoom level
        
        scale_change = 1.0 # Default if old zoom was zero or too small
        if abs(old_zoom_for_scale_calc) > 1e-9 : # Avoid division by zero or huge scale_change from tiny old_zoom
            scale_change = self.map_zoom_level / old_zoom_for_scale_calc
        elif abs(self.map_zoom_level) > 1e-9 : # If old zoom was ~0 but new one isn't, it's essentially a fresh scale
            pass # scale_change remains 1.0 which means no relative scaling for scroll adjustment, absolute positioning will take over

        _debug(f" zoom_map_at_point: self.map_zoom_level NOW = {self.map_zoom_level:.4f}, scale_change = {scale_change:.4f}")

        # --- Scroll adjustment logic to keep zoom_x_canvas, zoom_y_canvas fixed ---
        # (zoom_x_canvas, zoom_y_canvas) are the content coordinates of the point under the cursor (or center)
        
        current_view_x1 = canvas.canvasx(0) # Content X at left edge of viewport BEFORE scroll
        current_view_y1 = canvas.canvasy(0) # Content Y at top edge of viewport BEFORE scroll

        # The point (zoom_x_canvas, zoom_y_canvas) is currently at screen offset:
        # screen_offset_x = zoom_x_canvas - current_view_x1
        # screen_offset_y = zoom_y_canvas - current_view_y1
        # After zoom, we want this same screen_offset to correspond to the new scaled content point.
        # new_content_point_x = zoom_x_canvas * scale_change (This is conceptual, coordinates don't just multiply)
        # The new scroll position (target_new_view_x1) should be such that:
        # target_new_view_x1 + screen_offset_x = (new position of zoom_x_canvas after scaling effect)
        # A common formula: target_scroll = fixed_point_content_coord - (screen_offset_of_fixed_point / new_zoom_level_relative_to_screen_pixels)
        # Simplified: keep the relative position of zoom_x_canvas within the viewport the same.
        # screen_offset_x / viewport_width_old_zoom = (zoom_x_canvas * scale_change - target_new_view_x1) / viewport_width_new_zoom
        # This is still more complex than needed if we use the formula:
        target_new_view_x1 = zoom_x_canvas - ((zoom_x_canvas - current_view_x1) / scale_change) if abs(scale_change) > 1e-9 else current_view_x1
        target_new_view_y1 = zoom_y_canvas - ((zoom_y_canvas - current_view_y1) / scale_change) if abs(scale_change) > 1e-9 else current_view_y1
        
        # --- Recalculate total map dimensions AT THE NEW self.map_zoom_level ---
        new_zoomed_st_w, new_zoomed_st_h = self._get_zoomed_supertile_pixel_dims() # Uses current self.map_zoom_level
        map_total_pixel_width_new_zoom = map_width * new_zoomed_st_w
        map_total_pixel_height_new_zoom = map_height * new_zoomed_st_h
        
        safe_map_total_w = max(1.0, float(map_total_pixel_width_new_zoom))
        safe_map_total_h = max(1.0, float(map_total_pixel_height_new_zoom))

        target_frac_x = target_new_view_x1 / safe_map_total_w if safe_map_total_w > 0 else 0.0
        target_frac_y = target_new_view_y1 / safe_map_total_h if safe_map_total_h > 0 else 0.0

        canvas_widget_width = canvas.winfo_width()
        canvas_widget_height = canvas.winfo_height()

        # Calculate max fraction to prevent scrolling beyond content edges
        max_frac_x = 0.0
        if safe_map_total_w > canvas_widget_width:
            max_frac_x = (safe_map_total_w - canvas_widget_width) / safe_map_total_w
        
        max_frac_y = 0.0
        if safe_map_total_h > canvas_widget_height:
            max_frac_y = (safe_map_total_h - canvas_widget_height) / safe_map_total_h
        
        final_frac_x = max(0.0, min(target_frac_x, max_frac_x))
        final_frac_y = max(0.0, min(target_frac_y, max_frac_y))
        
        _debug(f" zoom_map_at_point: Scroll Adjust: target_new_view=({target_new_view_x1:.2f},{target_new_view_y1:.2f}), "
                   f"target_frac=({target_frac_x:.4f},{target_frac_y:.4f}), max_frac=({max_frac_x:.4f},{max_frac_y:.4f}), final_frac=({final_frac_x:.4f},{final_frac_y:.4f})")

        # Apply the scroll before drawing
        # Only call xview_moveto/yview_moveto if the canvas scrollable area is larger than the viewport
        if safe_map_total_w > 0: # and safe_map_total_w > canvas_widget_width: # Optional: only if scrollable
            canvas.xview_moveto(final_frac_x)
        if safe_map_total_h > 0: # and safe_map_total_h > canvas_widget_height: # Optional
            canvas.yview_moveto(final_frac_y)
        
        self.draw_map_canvas() 
        self.draw_minimap()
        _debug(f" zoom_map_at_point: --- Zoom Calculation End (Redraw Performed) ---")

    # --- File Menu Commands ---
    def new_project(self, interactive=True):
        # Resets all project data structures to a default new state.
        global tileset_patterns, tileset_colors, current_tile_index
        global supertiles_data, current_supertile_index, selected_tile_for_supertile
        global map_data, map_width, map_height, selected_supertile_for_map, last_painted_map_cell
        global selected_color_index

        new_dim_w = DEFAULT_SUPERTILE_GRID_WIDTH
        new_dim_h = DEFAULT_SUPERTILE_GRID_HEIGHT

        if interactive:
            new_dim_w_str = simpledialog.askstring(
                "New Supertile Width",
                "Enter supertile grid width (number of tiles, 1-32):",
                parent=self.root, initialvalue=str(self.supertile_grid_width)
            )
            if new_dim_w_str is None: return 
            try:
                new_dim_w = int(new_dim_w_str)
                if not (1 <= new_dim_w <= 32):
                    messagebox.showerror("Invalid Width", "Width must be between 1 and 32.", parent=self.root)
                    return
            except ValueError:
                messagebox.showerror("Invalid Input", "Width must be a whole number.", parent=self.root)
                return

            new_dim_h_str = simpledialog.askstring(
                "New Supertile Height",
                "Enter supertile grid height (number of tiles, 1-32):",
                parent=self.root, initialvalue=str(self.supertile_grid_height)
            )
            if new_dim_h_str is None: return 
            try:
                new_dim_h = int(new_dim_h_str)
                if not (1 <= new_dim_h <= 32):
                    messagebox.showerror("Invalid Height", "Height must be between 1 and 32.", parent=self.root)
                    return
            except ValueError:
                messagebox.showerror("Invalid Input", "Height must be a whole number.", parent=self.root)
                return

        self.supertile_grid_width = new_dim_w
        self.supertile_grid_height = new_dim_h
        _debug(f" New project data model: Supertile dimensions set to {self.supertile_grid_width}W x {self.supertile_grid_height}H.")

        # Reset the project limit to default and update the UI variable
        self.project_tile_limit = MAX_TILES
        self.tile_limit_var.set(self.project_tile_limit)
        self.project_supertile_limit = MAX_SUPERTILES
        self.supertile_limit_var.set(self.project_supertile_limit)

        self._clear_marked_unused(trigger_redraw=False)

        tileset_patterns = [
            [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        ]
        tileset_colors = [
            [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]
        ]
        current_tile_index = 0
        selected_tile_for_supertile = 0

        supertiles_data = [
            [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
        ]
        current_supertile_index = 0
        selected_supertile_for_map = 0

        map_width = DEFAULT_MAP_WIDTH
        map_height = DEFAULT_MAP_HEIGHT
        map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
        last_painted_map_cell = None

        self.map_clipboard_data = None

        self.active_msx_palette = []
        for r_pal, g_pal, b_pal in MSX2_RGB7_VALUES:
                self.active_msx_palette.append(self._rgb7_to_hex(r_pal, g_pal, b_pal))
        self.selected_palette_slot = 0
        selected_color_index = WHITE_IDX

        self.map_zoom_level = 1.0
        self.show_supertile_grid.set(False)
        self.show_window_view.set(False)
        self.grid_color_index = 1 
        self.window_view_tile_x = 0
        self.window_view_tile_y = 0
        self.window_view_tile_w.set(DEFAULT_WIN_VIEW_WIDTH_TILES)
        self.window_view_tile_h.set(DEFAULT_WIN_VIEW_HEIGHT_TILES)
        self.current_mouse_action = None
        self.window_view_resize_handle = None

        self._clear_map_selection()
        self._clear_paste_preview_rect()
        self.is_shift_pressed = False
        self.is_ctrl_pressed = False

    def save_palette(self, filepath=None, is_standalone_operation=True):
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Pal", # UPDATED Extension
                filetypes=[("SC4 Palette File", "*.SC4Pal"), ("All Files", "*.*")], # UPDATED Description and Extension
                title="Save SC4 Palette As...", # UPDATED Title
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                if len(self.active_msx_palette) != 16:
                    _error("Active palette length is not 16 during save!")
                    if filepath is None:
                        messagebox.showerror(
                            "Palette Error",
                            "Internal Error: Active palette does not contain 16 colors.",
                        )
                    return False

                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)

                for i in range(16):
                    hex_color = self.active_msx_palette[i]
                    r, g, b = self._hex_to_rgb7(hex_color)
                    packed_bytes = struct.pack("BBB", r, g, b)
                    f.write(packed_bytes)

            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Palette saved successfully to {os.path.basename(save_path)}",
                )

            if is_standalone_operation:
                self._add_to_recent_list("modules", save_path)

            return True

        except Exception as e:
            messagebox.showerror(
                "Save Palette Error",
                f"Failed to save palette file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_palette(self, filepath=None, is_standalone_operation=True, preserved_palette=None):
        # Loads a palette file, returning True on success, False on failure.
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("SC4 Palette File", "*.SC4Pal"), ("Old MSX Palette File", "*.msxpal"), ("All Files", "*.*")], 
                title="Open SC4 Palette",
                parent=self.root
            )
            if not load_path:
                return False

        try:
            expected_color_data_size = 16 * 3  
            new_palette_hex_from_file = [] 
            
            try:
                file_size = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            is_new_format_with_reserved_bytes = False
            expected_size_new = RESERVED_BYTES_COUNT + expected_color_data_size 
            expected_size_old = expected_color_data_size 

            if file_size == expected_size_new:
                is_new_format_with_reserved_bytes = True
            elif file_size == expected_size_old:
                is_new_format_with_reserved_bytes = False 
            else:
                raise ValueError(
                    f"Invalid file size for palette. Expected {expected_size_old} (old) or {expected_size_new} (new) bytes, got {file_size}."
                )

            with open(load_path, "rb") as f:
                if is_new_format_with_reserved_bytes:
                    reserved_bytes_read = f.read(RESERVED_BYTES_COUNT)
                    if len(reserved_bytes_read) < RESERVED_BYTES_COUNT:
                        raise EOFError("EOF while reading reserved bytes from new format palette file.")
                
                palette_data_bytes = f.read(expected_color_data_size)
                if len(palette_data_bytes) < expected_color_data_size:
                    raise EOFError(
                        f"Not enough data for palette colors. Expected {expected_color_data_size}, got {len(palette_data_bytes)}."
                    )

                for i in range(16):
                    offset = i * 3
                    if offset + 3 > len(palette_data_bytes): 
                        raise struct.error("Not enough bytes in color data block for unpacking.")
                    r_val, g_val, b_val = struct.unpack_from("BBB", palette_data_bytes, offset)

                    if preserved_palette and (r_val, g_val, b_val) == (128, 0, 0):
                        new_palette_hex_from_file.append(preserved_palette[i])
                        continue

                    if not (0 <= r_val <= 7 and 0 <= g_val <= 7 and 0 <= b_val <= 7):
                        _warning(f"Invalid RGB ({r_val},{g_val},{b_val}) at slot {i} in '{os.path.basename(load_path)}'. Clamping.")
                        r_val = max(0, min(7, r_val))
                        g_val = max(0, min(7, g_val))
                        b_val = max(0, min(7, b_val))
                    hex_color = self._rgb7_to_hex(r_val, g_val, b_val)
                    new_palette_hex_from_file.append(hex_color)
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    _warning(f"Palette file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")

            confirm_load = True
            if is_standalone_operation:
                self.root.bell() 
                confirm_load = messagebox.askokcancel(
                    "Confirm Palette Load",
                    "This will replace the current active palette.\n\n"
                    "This action cannot be undone and will clear the undo history. Proceed?",
                    icon='warning',
                    parent=self.root
                )

            if confirm_load:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass
                
                self.active_msx_palette = list(new_palette_hex_from_file)
                self.selected_palette_slot = 0
                global selected_color_index 
                selected_color_index = WHITE_IDX
                
                if is_standalone_operation:
                    self.undo_manager.clear()

                    self.clear_all_caches()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all")
                    self._request_color_usage_refresh()
                    self._request_tile_usage_refresh()
                    self._request_supertile_usage_refresh()
                    
                    try: 
                        if self.notebook and self.notebook.winfo_exists() and self.tab_palette_editor.winfo_exists():
                             self.notebook.select(self.tab_palette_editor)
                    except tk.TclError: pass
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded palette from {os.path.basename(load_path)}",
                        parent=self.root
                    )
                    self._mark_project_modified()
                    self._add_to_recent_list("modules", load_path)
                return True
            else:
                return False

        except FileNotFoundError:
            if is_standalone_operation:
                self._handle_missing_recent_file("modules", load_path)
            else:
                messagebox.showerror("Open Error", f"File not found:\n{load_path}", parent=self.root)
            return False
        except (struct.error, ValueError, EOFError) as e:
            if is_standalone_operation:
                messagebox.showerror(
                    "Open Palette Error",
                    f"Invalid data, size, or format in palette file '{os.path.basename(load_path)}':\n{e}",
                    parent=self.root
                )
            return False
        except Exception as e:
            if is_standalone_operation:
                messagebox.showerror(
                    "Open Palette Error",
                    f"Failed to open or parse palette file '{os.path.basename(load_path)}':\n{e}",
                    parent=self.root
                )
            return False

    def save_tileset(self, filepath=None, is_standalone_operation=True):
        global tileset_patterns, tileset_colors # Using globals
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Tiles",
                filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
                title="Save Tileset As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                tiles_to_write_count = len(tileset_patterns)

                header_byte_value = 0 if tiles_to_write_count == 256 else tiles_to_write_count
                if not (0 <= header_byte_value <= 255):
                    _debug(f" save_tileset: Invalid header_byte_value {header_byte_value} for len(tileset_patterns) {tiles_to_write_count}")
                    raise ValueError(f"Calculated header byte value {header_byte_value} is out of 0-255 range.")
                
                num_byte_header = struct.pack("B", header_byte_value)
                f.write(num_byte_header)

                # Use the first reserved byte to store the project's tile limit.
                limit_to_save = self.project_tile_limit if self.project_tile_limit < MAX_TILES else 0
                f.write(struct.pack("B", limit_to_save))

                # Write the remaining reserved bytes.
                f.write(bytes([0] * (RESERVED_BYTES_COUNT - 1)))

                # --- Write ALL pattern data first ---
                for i in range(tiles_to_write_count):
                    if i >= len(tileset_patterns): 
                        _warning(f" save_tileset: len(tileset_patterns) ({tiles_to_write_count}) > len(tileset_patterns). Stopping pattern write at tile {i}.")
                        # Pad remaining patterns for this block if this happens, to keep file structure valid
                        # This assumes we must write pattern data for all 'tiles_to_write_count'
                        for _ in range(tiles_to_write_count - i):
                            for _ in range(TILE_HEIGHT):
                                f.write(struct.pack("B", 0)) # Write blank pattern row
                        break 
                    pattern = tileset_patterns[i]
                    for r in range(TILE_HEIGHT):
                        byte_val = 0
                        if r < len(pattern):
                            row_pattern = pattern[r]
                            for c in range(TILE_WIDTH):
                                if c < len(row_pattern) and row_pattern[c] == 1:
                                    byte_val = byte_val | (1 << (7 - c))
                        pattern_byte = struct.pack("B", byte_val)
                        f.write(pattern_byte)
                
                # --- Then, write ALL color data ---
                for i in range(tiles_to_write_count):
                    if i >= len(tileset_colors):
                        _warning(f" save_tileset: len(tileset_patterns) ({tiles_to_write_count}) > len(tileset_colors). Stopping color write at tile {i}.")
                        # Pad remaining colors for this block
                        for _ in range(tiles_to_write_count - i):
                            for _ in range(TILE_HEIGHT):
                                default_color_byte = ((WHITE_IDX & 0x0F) << 4) | (BLACK_IDX & 0x0F)
                                f.write(struct.pack("B", default_color_byte))
                        break
                    colors = tileset_colors[i]
                    for r in range(TILE_HEIGHT):
                        fg_idx, bg_idx = (WHITE_IDX, BLACK_IDX) 
                        if r < len(colors):
                           fg_idx, bg_idx = colors[r]
                        
                        safe_fg_idx = max(0, min(15, fg_idx))
                        safe_bg_idx = max(0, min(15, bg_idx))

                        color_byte_val = ((safe_fg_idx & 0x0F) << 4) | (safe_bg_idx & 0x0F)
                        color_byte = struct.pack("B", color_byte_val)
                        f.write(color_byte)

            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Tileset saved successfully to {os.path.basename(save_path)}",
                )

            if is_standalone_operation:
                self._add_to_recent_list("modules", save_path)

            return True

        except Exception as e:
            messagebox.showerror(
                "Save Tileset Error",
                f"Failed to save tileset file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_tileset(self, filepath=None, is_standalone_operation=True):
        # Loads a tileset file, returning True on success, False on failure.
        global tileset_patterns, tileset_colors, current_tile_index, selected_tile_for_supertile
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
                title="Open Tileset",
            )
        if not load_path:
            return False

        try:
            try:
                file_size_check = os.path.getsize(load_path)
            except OSError as e:
                raise ValueError(f"Could not get size of file '{os.path.basename(load_path)}': {e}")

            with open(load_path, "rb") as f:
                num_tiles_header_byte_val = f.read(1)
                if not num_tiles_header_byte_val:
                    raise ValueError("File empty or missing tile count header byte.")
                
                header_value = struct.unpack("B", num_tiles_header_byte_val)[0]
                loaded_num_tiles = 256 if header_value == 0 else header_value

                if not (1 <= loaded_num_tiles <= MAX_TILES):
                    raise ValueError(
                        f"Invalid tile count derived from file: {loaded_num_tiles} (must be 1-{MAX_TILES})"
                    )

                expected_data_block_size = (loaded_num_tiles * TILE_HEIGHT) * 2
                expected_total_size_new_format = 1 + RESERVED_BYTES_COUNT + expected_data_block_size
                expected_total_size_old_format = 1 + expected_data_block_size

                has_reserved_bytes_to_read = False
                if file_size_check == expected_total_size_new_format:
                    has_reserved_bytes_to_read = True
                elif file_size_check == expected_total_size_old_format:
                    has_reserved_bytes_to_read = False
                else:
                    raise ValueError(
                        f"Tileset file '{os.path.basename(load_path)}' has an unexpected size ({file_size_check} bytes) "
                        f"for {loaded_num_tiles} tiles. Expected {expected_total_size_old_format} (old format) "
                        f"or {expected_total_size_new_format} (new format)."
                    )

                if has_reserved_bytes_to_read:
                    # Read the first byte for the limit, the rest are still reserved.
                    limit_byte_data = f.read(1)
                    f.read(RESERVED_BYTES_COUNT - 1) # Consume the rest of the reserved block
                    if not limit_byte_data:
                        raise EOFError("Unexpected EOF while reading tileset limit byte.")
                
                    limit_from_file = struct.unpack("B", limit_byte_data)[0]
                    self.project_tile_limit = MAX_TILES if limit_from_file == 0 else limit_from_file
                else:
                    # For legacy files without the reserved block, default to max.
                    self.project_tile_limit = MAX_TILES

                new_patterns = [
                    [[0] * TILE_WIDTH for _r in range(TILE_HEIGHT)]
                    for _i in range(loaded_num_tiles)
                ]
                new_colors = [
                    [(WHITE_IDX, BLACK_IDX) for _r in range(TILE_HEIGHT)]
                    for _i in range(loaded_num_tiles)
                ]

                bytes_per_tile_pattern = TILE_HEIGHT
                total_pattern_bytes_to_read = loaded_num_tiles * bytes_per_tile_pattern
                all_pattern_data_bytes = f.read(total_pattern_bytes_to_read)
                if len(all_pattern_data_bytes) < total_pattern_bytes_to_read:
                    raise EOFError(f"EOF while reading pattern data block. Expected {total_pattern_bytes_to_read}, got {len(all_pattern_data_bytes)}.")

                current_byte_offset_pattern = 0
                for i in range(loaded_num_tiles):
                    tile_pattern_bytes = all_pattern_data_bytes[current_byte_offset_pattern : current_byte_offset_pattern + bytes_per_tile_pattern]
                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_pattern_bytes[r_idx]
                        for c in range(TILE_WIDTH):
                            new_patterns[i][r_idx][c] = (byte_val >> (7 - c)) & 1
                    current_byte_offset_pattern += bytes_per_tile_pattern
                
                bytes_per_tile_colors = TILE_HEIGHT
                total_color_bytes_to_read = loaded_num_tiles * bytes_per_tile_colors
                all_color_data_bytes = f.read(total_color_bytes_to_read)
                if len(all_color_data_bytes) < total_color_bytes_to_read:
                    raise EOFError(f"EOF while reading color data block. Expected {total_color_bytes_to_read}, got {len(all_color_data_bytes)}.")

                current_byte_offset_colors = 0
                for i in range(loaded_num_tiles):
                    tile_color_bytes = all_color_data_bytes[current_byte_offset_colors : current_byte_offset_colors + bytes_per_tile_colors]
                    for r_idx in range(TILE_HEIGHT):
                        byte_val = tile_color_bytes[r_idx]
                        fg_idx = (byte_val >> 4) & 0x0F
                        bg_idx = byte_val & 0x0F
                        new_colors[i][r_idx] = (fg_idx, bg_idx)
                    current_byte_offset_colors += bytes_per_tile_colors
                
                extra_data_check = f.read(1)
                if extra_data_check:
                    _warning(f" Tileset file '{os.path.basename(load_path)}' contains additional unexpected data at the end.")

            confirm = True
            if is_standalone_operation:
                self.root.bell()
                confirm = messagebox.askokcancel(
                    "Confirm Tileset Load",
                    f"This will replace the current tileset with {loaded_num_tiles} tile(s) from the file.\n\n"
                    "This action cannot be undone and will clear the undo history. Proceed?",
                    icon='warning',
                    parent=self.root
                )

            if confirm:
                if self._clear_marked_unused(trigger_redraw=False):
                    pass

                tileset_patterns = new_patterns
                tileset_colors = new_colors

                current_tile_index = max(0, min(current_tile_index, len(tileset_patterns) - 1))
                selected_tile_for_supertile = max(0, min(selected_tile_for_supertile, len(tileset_patterns) - 1))

                if is_standalone_operation:
                    self.undo_manager.clear()

                    self.clear_all_caches()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all")
                    self._update_editor_button_states()
                    self._update_edit_menu_state()
                    self._request_color_usage_refresh()
                    try:
                        if self.notebook and self.notebook.winfo_exists() and self.tab_tile_editor.winfo_exists():
                            self.notebook.select(self.tab_tile_editor)
                    except tk.TclError:
                        _debug(" open_tileset: TclError selecting tile editor tab.")
                    messagebox.showinfo(
                        "Load Successful",
                        f"Loaded {len(tileset_patterns)} tiles from {os.path.basename(load_path)}",
                    )
                    self._mark_project_modified()
                    self._add_to_recent_list("modules", load_path)
                
                self.tile_limit_var.set(self.project_tile_limit) # Sync UI with loaded limit
                return True
            else:
                return False

        except FileNotFoundError:
            if is_standalone_operation:
                self._handle_missing_recent_file("modules", load_path)
            else:
                messagebox.showerror("Open Error", f"File not found:\n{load_path}")
            return False
        except (EOFError, ValueError, struct.error) as e:
            if is_standalone_operation:
                messagebox.showerror(
                    "Open Tileset Error",
                    f"Invalid data, size, or format in tileset file '{os.path.basename(load_path)}':\n{e}",
                )
            return False
        except Exception as e:
            if is_standalone_operation:
                messagebox.showerror(
                    "Open Tileset Error",
                    f"Failed to open or parse tileset file '{os.path.basename(load_path)}':\n{e}",
                )
            return False

    def save_supertiles(self, filepath=None, is_standalone_operation=True):
        global supertiles_data
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Super",
                filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
                title="Save Supertiles As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # len(supertiles_data) is the actual count (1 to MAX_SUPERTILES)
                if 1 <= len(supertiles_data) <= 255:
                    f.write(struct.pack("B", len(supertiles_data)))
                elif 256 <= len(supertiles_data) <= MAX_SUPERTILES: # MAX_SUPERTILES is now 65535
                    f.write(struct.pack("B", 0)) # Indicator byte
                    f.write(struct.pack("<H", len(supertiles_data))) # 2-byte unsigned short for actual count
                else:
                    # This case should not be reached if len(supertiles_data) is always valid (e.g. 0 not allowed)
                    _debug(f" save_supertiles: Invalid len(supertiles_data) value ({len(supertiles_data)}) for saving.")
                    raise ValueError(f"len(supertiles_data) ({len(supertiles_data)}) out of expected range for saving.")
                
                # Write supertile grid dimensions (these remain 1 byte each)
                f.write(struct.pack("B", self.supertile_grid_width))
                f.write(struct.pack("B", self.supertile_grid_height))

                # Use first 2 reserved bytes to store the supertile limit.
                _debug(f"[save_supertiles] Saving self.project_supertile_limit value ({self.project_supertile_limit}).")
                limit_value_to_write = 0xFFFF if self.project_supertile_limit >= MAX_SUPERTILES else self.project_supertile_limit
                f.write(struct.pack("<H", limit_value_to_write))
                # Write the remaining reserved bytes as zero.
                f.write(bytes([0] * (RESERVED_BYTES_COUNT - 2)))
                
                tiles_per_definition = self.supertile_grid_width * self.supertile_grid_height
                if tiles_per_definition <= 0 and len(supertiles_data) > 0 : # Defensive check for invalid grid dims
                    _debug(f" save_supertiles: Invalid supertile dimensions ({self.supertile_grid_width}x{self.supertile_grid_height}), cannot save data.")
                    raise ValueError("Supertile dimensions are zero or negative, cannot save definition data.")

                # Write data for each supertile
                for i in range(len(supertiles_data)): # Iterate up to the actual number of supertiles
                    if i >= len(supertiles_data): # Safety break
                        _de_warningbug(f" save_supertiles: len(supertiles_data) ({len(supertiles_data)}) > len(supertiles_data). Stopping ST data write at ST {i}.")
                        # Pad remaining ST definitions if this happens
                        for _ in range(len(supertiles_data) - i):
                            for _ in range(tiles_per_definition):
                                f.write(struct.pack("B", 0)) # Write 0 for each tile index
                        break
                    
                    definition = supertiles_data[i]
                    
                    # Ensure definition matches project dimensions before writing
                    # Pad/truncate row or cells if necessary for robustness, though ideally data is consistent
                    for r_st in range(self.supertile_grid_height):
                        if r_st < len(definition): # Row exists
                            row_data = definition[r_st]
                            for c_st in range(self.supertile_grid_width):
                                tile_index_val = 0 # Default if cell missing
                                if c_st < len(row_data): # Cell exists
                                    tile_index_val = row_data[c_st]
                                # Ensure tile_index_val is within byte range (0-255) as it's packed as "B"
                                safe_tile_index_val = max(0, min(255, tile_index_val))
                                if tile_index_val != safe_tile_index_val:
                                    _debug(f" save_supertiles: Clamping tile index {tile_index_val} to {safe_tile_index_val} in ST {i} at ({r_st},{c_st}).")
                                f.write(struct.pack("B", safe_tile_index_val))
                        else: # Row missing, pad entire row with 0s
                            for _ in range(self.supertile_grid_width):
                                f.write(struct.pack("B", 0))
            
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Supertiles saved successfully to {os.path.basename(save_path)}",
                )

            if is_standalone_operation:
                self._add_to_recent_list("modules", save_path)

            return True
        except Exception as e:
            messagebox.showerror(
                "Save Supertile Error",
                f"Failed to save supertiles file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_supertiles(self, filepath=None, is_standalone_operation=True):
        # Loads a supertile file, returning True on success, False on failure.
        global supertiles_data, current_supertile_index, selected_supertile_for_map
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
                title="Open Supertiles",
            )
        if not load_path:
            return False

        try:
            with open(load_path, "rb") as f:
                first_count_byte_val = f.read(1)
                if not first_count_byte_val: raise ValueError("File empty.")
                
                indicator_byte = struct.unpack("B", first_count_byte_val)[0]
                if indicator_byte == 0:
                    count_bytes_short = f.read(2)
                    if len(count_bytes_short) < 2: raise EOFError("EOF for 2-byte ST count.")
                    loaded_num_st_from_file = struct.unpack("<H", count_bytes_short)[0]
                else: 
                    loaded_num_st_from_file = indicator_byte
                
                if not (0 <= loaded_num_st_from_file <= MAX_SUPERTILES):
                    raise ValueError(f"Invalid supertile count in file: {loaded_num_st_from_file}")
                
                dim_w_byte, dim_h_byte = f.read(1), f.read(1)
                if not dim_w_byte or not dim_h_byte: raise EOFError("EOF for ST dimensions.")
                
                loaded_grid_width_from_file = struct.unpack("B", dim_w_byte)[0]
                loaded_grid_height_from_file = struct.unpack("B", dim_h_byte)[0]
                
                if not (1 <= loaded_grid_width_from_file <= 32 and 1 <= loaded_grid_height_from_file <= 32):
                    if loaded_num_st_from_file == 0 and loaded_grid_width_from_file == 0 and loaded_grid_height_from_file == 0:
                        pass 
                    else:
                        raise ValueError(f"Invalid supertile dimensions in file: {loaded_grid_width_from_file}x{loaded_grid_height_from_file}")

                file_size_check = os.path.getsize(load_path)
                header_size = 3 if indicator_byte == 0 else 1
                header_size += 2 # For dimensions
                data_payload_size = loaded_num_st_from_file * loaded_grid_width_from_file * loaded_grid_height_from_file
                expected_size_new = header_size + RESERVED_BYTES_COUNT + data_payload_size
                expected_size_old = header_size + data_payload_size

                limit_bytes = f.read(2)
                if len(limit_bytes) < 2: raise EOFError("EOF reading supertile limit bytes.")
                limit_from_file = struct.unpack("<H", limit_bytes)[0]
                _debug(f"[open_supertiles] Read supertileset size limit from file: {limit_from_file}.")
                # Read and discard remaining reserved bytes
                f.read(RESERVED_BYTES_COUNT - 2)
                    
                # Per spec, 0x0000 and 0xFFFF map to the max limit
                if limit_from_file == 0x0000 or limit_from_file == 0xFFFF:
                    self.project_supertile_limit = MAX_SUPERTILES
                else:
                    self.project_supertile_limit = limit_from_file
                _debug(f"[open_supertiles] project_supertile_limit set to {self.project_supertile_limit}.")

                temp_supertiles_data = []
                if loaded_num_st_from_file > 0:
                    bytes_per_def = loaded_grid_width_from_file * loaded_grid_height_from_file
                    for i in range(loaded_num_st_from_file):
                        st_bytes = f.read(bytes_per_def)
                        if len(st_bytes) < bytes_per_def: raise EOFError(f"EOF reading data for supertile {i}.")
                        
                        st_def = [[0] * loaded_grid_width_from_file for _ in range(loaded_grid_height_from_file)]
                        byte_idx = 0
                        for r in range(loaded_grid_height_from_file):
                            for c in range(loaded_grid_width_from_file):
                                st_def[r][c] = st_bytes[byte_idx]
                                byte_idx += 1
                        temp_supertiles_data.append(st_def)
            
            confirm_load = True
            if is_standalone_operation:
                self.root.bell()
                confirm_load = messagebox.askokcancel(
                    "Confirm Supertile Load",
                    f"This will replace current supertiles with {loaded_num_st_from_file} definition(s) from the file.\n\n"
                    "This action cannot be undone and will clear the undo history. Proceed?",
                    icon='warning',
                    parent=self.root
                )

            if confirm_load:
                if self._clear_marked_unused(trigger_redraw=False): pass

                if is_standalone_operation and \
                   (self.supertile_grid_width != loaded_grid_width_from_file or \
                    self.supertile_grid_height != loaded_grid_height_from_file):
                    if not messagebox.askokcancel("Dimension Mismatch", "Supertile dimensions in file differ from current project. Loading will change project dimensions. Continue?", icon="warning"):
                        return False 
    
                supertiles_data = temp_supertiles_data
                # Ensure at least one supertile exists if the file was empty.
                if not supertiles_data:
                    supertiles_data.append([[0] * self.supertile_grid_width for _ in range(self.supertile_grid_height)])
    
                if self.supertile_grid_width != loaded_grid_width_from_file or \
                    self.supertile_grid_height != loaded_grid_height_from_file:
                    self.supertile_grid_width = loaded_grid_width_from_file
                    self.supertile_grid_height = loaded_grid_height_from_file
                    self._reconfigure_supertile_definition_canvas()
                
                current_supertile_index = max(0, min(current_supertile_index, len(supertiles_data) - 1))
                selected_supertile_for_map = max(0, min(selected_supertile_for_map, len(supertiles_data) - 1))
                
                max_valid_tile_idx = len(tileset_patterns) - 1
                for st_idx in range(len(supertiles_data)):
                    for r in range(self.supertile_grid_height):
                        for c in range(self.supertile_grid_width):
                            if supertiles_data[st_idx][r][c] > max_valid_tile_idx:
                                supertiles_data[st_idx][r][c] = 0

                if is_standalone_operation:
                    self.undo_manager.clear()

                    self.supertile_image_cache.clear()
                    self.map_render_cache.clear()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all")
                    self._update_editor_button_states()
                    self._update_edit_menu_state()
                    self._update_supertile_rotate_button_state()
                    self._request_tile_usage_refresh()
                    self._request_supertile_usage_refresh()
                    try:
                        if self.notebook and self.notebook.winfo_exists(): self.notebook.select(self.tab_supertile_editor)
                    except tk.TclError: pass
                    messagebox.showinfo("Load Successful", f"Loaded {len(supertiles_data)} supertiles.")
                    self._mark_project_modified()
                    self._add_to_recent_list("modules", load_path)

                self.supertile_limit_var.set(self.project_supertile_limit)

                return True
            else: 
                return False

        except FileNotFoundError:
            if is_standalone_operation: self._handle_missing_recent_file("modules", load_path)
            return False
        except (EOFError, ValueError, struct.error) as e:
            if is_standalone_operation: messagebox.showerror("Open Supertile Error", f"Invalid data or format in file '{os.path.basename(load_path)}':\n{e}")
            return False
        except Exception as e:
            if is_standalone_operation: messagebox.showerror("Open Supertile Error", f"Failed to open file '{os.path.basename(load_path)}':\n{e}")
            return False

    def save_map(self, filepath=None, is_standalone_operation=True):
        global map_width, map_height, map_data
        save_path = filepath
        if not save_path:
            save_path = filedialog.asksaveasfilename(
                defaultextension=".SC4Map",
                filetypes=[("MSX Map", "*.SC4Map"), ("All Files", "*.*")],
                title="Save Map As...",
            )
        if not save_path:
            return False

        try:
            with open(save_path, "wb") as f:
                # Write dimensions (Big-endian, 2 bytes each)
                dim_bytes = struct.pack("<HH", map_width, map_height)
                f.write(dim_bytes)

                reserved_data = bytes([0] * RESERVED_BYTES_COUNT)
                f.write(reserved_data)

                use_2_byte_indices_for_map = (len(supertiles_data) > 255)
                if use_2_byte_indices_for_map:
                    _debug(f" save_map: Using 2-byte ST indices (len(supertiles_data)={len(supertiles_data)}).")
                else:
                    _debug(f" save_map: Using 1-byte ST indices (len(supertiles_data)={len(supertiles_data)}).")

                for r in range(map_height):
                    if r >= len(map_data): # Should not happen if map_data is consistent
                        _debug(f" save_map: map_height > len(map_data) at row {r}. Padding rest of map.")
                        # Pad remaining rows if data is inconsistent
                        for _pad_r in range(map_height - r):
                            for _pad_c in range(map_width):
                                if use_2_byte_indices_for_map:
                                    f.write(struct.pack(">H", 0))
                                else:
                                    f.write(struct.pack("B", 0))
                        break # Stop processing rows

                    row_data = map_data[r]
                    for c in range(map_width):
                        supertile_index_val = 0 # Default if cell data missing
                        if c < len(row_data):
                            supertile_index_val = row_data[c]
                        
                        if use_2_byte_indices_for_map:
                            # Ensure index is within 2-byte range (0-65535)
                            safe_supertile_index_val = max(0, min(65535, supertile_index_val))
                            if supertile_index_val != safe_supertile_index_val:
                                _debug(f" save_map: Clamping ST index {supertile_index_val} to {safe_supertile_index_val} for 2-byte save.")
                            index_bytes = struct.pack("<H", safe_supertile_index_val)
                            f.write(index_bytes)
                        else:
                            # Ensure index is within 1-byte range (0-255)
                            safe_supertile_index_val = max(0, min(255, supertile_index_val))
                            if supertile_index_val != safe_supertile_index_val:
                                _debug(f" save_map: Clamping ST index {supertile_index_val} to {safe_supertile_index_val} for 1-byte save (project ST count <= 255).")
                            index_byte = struct.pack("B", safe_supertile_index_val)
                            f.write(index_byte)
            
            if filepath is None:
                messagebox.showinfo(
                    "Save Successful",
                    f"Map saved successfully to {os.path.basename(save_path)}",
                )

            if is_standalone_operation:
                self._add_to_recent_list("modules", save_path)

            return True
        except Exception as e:
            messagebox.showerror(
                "Save Map Error",
                f"Failed to save map file '{os.path.basename(save_path)}':\n{e}",
            )
            return False

    def open_map(self, filepath=None, is_standalone_operation=True):
        # Loads a map file, returning True on success, False on failure.
        global map_data, map_width, map_height
        load_path = filepath
        if not load_path:
            load_path = filedialog.askopenfilename(
                filetypes=[("MSX Map", "*.SC4Map"), ("All Files", "*.*")],
                title="Open Map",
                parent=self.root
            )
        if not load_path:
            _info("open_map cancelled.")
            return False

        try:
            with open(load_path, "rb") as f:
                dim_bytes = f.read(4)
                if len(dim_bytes) < 4: raise ValueError("Invalid map header.")
                loaded_w_map, loaded_h_map = struct.unpack("<HH", dim_bytes)
                
                if not (MIN_DIM <= loaded_w_map <= MAX_DIM and MIN_DIM <= loaded_h_map <= MAX_DIM):
                    raise ValueError(f"Invalid map dimensions in file: {loaded_w_map}x{loaded_h_map}")

                file_size = os.path.getsize(load_path)
                num_cells = loaded_w_map * loaded_h_map
                header_size = 4
                
                expected_size_old_1b = header_size + (num_cells * 1)
                expected_size_new_1b = header_size + RESERVED_BYTES_COUNT + (num_cells * 1)
                expected_size_new_2b = header_size + RESERVED_BYTES_COUNT + (num_cells * 2)

                has_reserved_bytes, use_2byte_indices = False, False
                if file_size == expected_size_new_1b: has_reserved_bytes, use_2byte_indices = True, False
                elif file_size == expected_size_new_2b: has_reserved_bytes, use_2byte_indices = True, True
                elif file_size == expected_size_old_1b: has_reserved_bytes, use_2byte_indices = False, False
                else: raise ValueError(f"Map file size mismatch for {loaded_w_map}x{loaded_h_map} dimensions.")

                if has_reserved_bytes: f.read(RESERVED_BYTES_COUNT)

                new_map_data = [[0] * loaded_w_map for _ in range(loaded_h_map)]
                for r in range(loaded_h_map):
                    for c in range(loaded_w_map):
                        if use_2byte_indices:
                            idx_bytes = f.read(2)
                            if len(idx_bytes) < 2: raise EOFError("EOF reading 2-byte map index.")
                            new_map_data[r][c] = struct.unpack("<H", idx_bytes)[0]
                        else:
                            idx_byte = f.read(1)
                            if not idx_byte: raise EOFError("EOF reading 1-byte map index.")
                            new_map_data[r][c] = struct.unpack("B", idx_byte)[0]
            
            confirm_load = True
            if is_standalone_operation:
                self.root.bell()
                confirm_load = messagebox.askokcancel(
                    "Confirm Map Load",
                    "This will replace the current map with data from the file.\n\n"
                    "This action cannot be undone and will clear the undo history. Proceed?",
                    icon='warning',
                    parent=self.root
                )

            if confirm_load:
                if self._clear_marked_unused(trigger_redraw=False): pass

                missing_st_indices = set()
                for r in range(loaded_h_map):
                    for c in range(loaded_w_map):
                        st_idx = new_map_data[r][c]
                        if not (0 <= st_idx < len(supertiles_data)):
                            missing_st_indices.add(st_idx)
                            new_map_data[r][c] = 0
                
                map_width = loaded_w_map
                map_height = loaded_h_map
                map_data = new_map_data

                if missing_st_indices and is_standalone_operation:
                    sorted_missing = sorted(list(missing_st_indices))
                    msg = f"Warning: Map references missing Supertile indices: {', '.join(map(str, sorted_missing[:20]))}"
                    if len(sorted_missing) > 20: msg += "..."
                    messagebox.showwarning("Map Load Warning", msg, parent=self.root)

                if is_standalone_operation:
                    self.undo_manager.clear()

                    self.map_render_cache.clear()
                    self.invalidate_minimap_background_cache()
                    self.update_all_displays(changed_level="all")
                    self._trigger_minimap_reconfigure()
                    self._request_supertile_usage_refresh()
                    try:
                        if self.notebook and self.notebook.winfo_exists(): self.notebook.select(self.tab_map_editor)
                    except tk.TclError: pass
                    messagebox.showinfo("Load Successful", f"Loaded {map_width}x{map_height} map.")
                    self._mark_project_modified()
                    self._add_to_recent_list("modules", load_path)
                return True
            else:
                _info("open_map replacing current data not confirmed.")
                return False

        except FileNotFoundError:
            _error("open_map: File not found.")
            if is_standalone_operation:
                self._handle_missing_recent_file("modules", load_path)
            return False
        except (EOFError, ValueError, struct.error) as e:
            _error(f"open_map: map structure error: {e}")
            if is_standalone_operation:
                messagebox.showerror("Open Map Error", f"Invalid data or format in file '{os.path.basename(load_path)}':\n{e}")
            return False
        except Exception as e:
            _error(f"open_map: general error: {e}")
            if is_standalone_operation: messagebox.showerror("Open Map Error", f"Failed to open file '{os.path.basename(load_path)}':\n{e}")
            return False

    # --- Project Save/Load Methods ---

    def save_project(self):
        # Saves all project components to the current project path.
        if self.current_project_base_path:
            base_path = self.current_project_base_path
            pal_path = base_path + ".SC4Pal"
            til_path = base_path + ".SC4Tiles"
            sup_path = base_path + ".SC4Super"
            map_path = base_path + ".SC4Map"

            _debug(f" save_project: Saving to existing base path {base_path}")

            success = True
            if success: success = self.save_palette(pal_path, is_standalone_operation=False)
            if success: success = self.save_tileset(til_path, is_standalone_operation=False)
            if success: success = self.save_supertiles(sup_path, is_standalone_operation=False)
            if success: success = self.save_map(map_path, is_standalone_operation=False)

            if success:
                _debug(" save_project: All components saved successfully.")
                self.project_modified = False
                # self.undo_manager.clear() # Clear undo/redo history on successful save
                self._update_window_title()
                self._add_to_recent_list("projects", base_path)
                self._save_app_settings()
                return True
            else:
                _debug(" save_project: One or more components failed to save.")
                return False
        else:
            _debug(" save_project: No current_project_base_path, calling save_project_as.")
            return self.save_project_as()

    def save_project_as(self):
        # Prompts for a new path and saves all project components.
        base_path_from_dialog = filedialog.asksaveasfilename(
            title="Save Project As (Enter Base Name for Components)",
            filetypes=[("MSX Tile Forge Project", "*")],
            parent=self.root,
        )

        if not base_path_from_dialog:
            _debug(" save_project_as: User cancelled 'Save As' dialog.")
            return False 

        true_base_path, _ = os.path.splitext(base_path_from_dialog)
        if not true_base_path:
            _debug(f" save_project_as: Invalid base name from dialog: '{base_path_from_dialog}'")
            messagebox.showerror("Save Error", "Invalid base name for project.", parent=self.root)
            return False
        
        pal_path = true_base_path + ".SC4Pal"
        til_path = true_base_path + ".SC4Tiles"
        sup_path = true_base_path + ".SC4Super"
        map_path = true_base_path + ".SC4Map"

        existing_files_to_overwrite = []
        if os.path.exists(pal_path): existing_files_to_overwrite.append(os.path.basename(pal_path))
        if os.path.exists(til_path): existing_files_to_overwrite.append(os.path.basename(til_path))
        if os.path.exists(sup_path): existing_files_to_overwrite.append(os.path.basename(sup_path))
        if os.path.exists(map_path): existing_files_to_overwrite.append(os.path.basename(map_path))

        if existing_files_to_overwrite:
            if not messagebox.askokcancel("Confirm Overwrite", "One or more project component files already exist. Overwrite?", icon="warning", parent=self.root):
                _debug(" save_project_as: User cancelled overwrite of existing project files.")
                return False

        success = True
        if success: success = self.save_palette(pal_path, is_standalone_operation=False)
        if success: success = self.save_tileset(til_path, is_standalone_operation=False)
        if success: success = self.save_supertiles(sup_path, is_standalone_operation=False)
        if success: success = self.save_map(map_path, is_standalone_operation=False)

        if success:
            _debug(" save_project_as: All components saved successfully.")
            self.current_project_base_path = true_base_path 
            self.project_modified = False
            # self.undo_manager.clear() # Clear undo/redo history on successful save
            self._update_window_title()
            self._add_to_recent_list("projects", self.current_project_base_path)
            self._save_app_settings()
            return True
        else:
            _error("save_project_as: One or more components failed to save.")
            messagebox.showerror("Project Save Error", "One or more project components failed to save.", parent=self.root)
            return False

    def open_project(self, filepath=None, is_auto_load=False, preserved_palette=None):
        # Loads project data from files, returning True on success, False on failure.
        _debug(" open_project: Method entered.")
        _debug(f" open_project: filepath='{filepath}', is_auto_load={is_auto_load}")

        if not filepath:
            _error("open_project: Called with no filepath. Returning False.")
            return False

        directory = os.path.dirname(filepath)
        base_name, _ = os.path.splitext(os.path.basename(filepath))
        base_path = os.path.join(directory, base_name)
        _debug(f" open_project: Determined base_path: '{base_path}'")

        _debug(f" open_project: Validating project files for base_path: '{base_path}'")
        is_valid, missing_files = self._validate_project_files(base_path)
        _debug(f" open_project: Validation result: is_valid={is_valid}, missing_files={missing_files}")

        if not is_valid:
            _debug(" open_project: Validation FAILED. Path is not a valid project.")
            if not is_auto_load:
                messagebox.showerror("Open Project Error", 
                                     f"Cannot open project '{base_name}'.\nMissing component file(s):\n" + "\n".join(missing_files),
                                     parent=self.root)
            _debug(" open_project: Returning False due to validation failure.")
            return False
        
        pal_path_new = base_path + ".SC4Pal"
        pal_path_old = base_path + ".msxpal"
        actual_pal_path_to_load = pal_path_new if os.path.exists(pal_path_new) else pal_path_old
        
        til_path = base_path + ".SC4Tiles"
        sup_path = base_path + ".SC4Super"
        map_path = base_path + ".SC4Map"

        _debug(" open_project: Preparing state for new project load (clearing clipboards, etc.).")
        self.is_ctrl_pressed = False
        self.is_shift_pressed = False
        self.current_mouse_action = None
        self.map_clipboard_data = None
        self._clear_map_selection()
        self._clear_paste_preview_rect()
        self._clear_marked_unused(trigger_redraw=False) 
        
        _debug(" open_project: Starting component load sequence...")
        success = True

        _debug(f" open_project: --> Calling self.open_palette('{actual_pal_path_to_load}')")
        success = self.open_palette(filepath=actual_pal_path_to_load, is_standalone_operation=False, preserved_palette=preserved_palette)
        _debug(f" open_project: <-- self.open_palette returned: {success}")

        if success:
            _debug(f" open_project: --> Calling self.open_tileset('{til_path}')")
            success = self.open_tileset(til_path, is_standalone_operation=False)
            _debug(f" open_project: <-- self.open_tileset returned: {success}")
        else:
            _debug(" open_project: Palette load failed. Aborting project open.")

        if success:
            _debug(f" open_project: --> Calling self.open_supertiles('{sup_path}')")
            success = self.open_supertiles(sup_path, is_standalone_operation=False) 
            _debug(f" open_project: <-- self.open_supertiles returned: {success}")
        else:
            _debug(" open_project: Tileset load failed. Aborting project open.")
            
        if success:
            _debug(f" open_project: --> Calling self.open_map('{map_path}')")
            success = self.open_map(map_path, is_standalone_operation=False)
            _debug(f" open_project: <-- self.open_map returned: {success}")
        else:
            _debug(" open_project: Supertile load failed. Aborting project open.")

        _debug(f" open_project: All components processed. Overall success status: {success}")
        
        if success:
            _debug(" open_project: Finalizing SUCCESS. Setting project path and modified status.")
            self.current_project_base_path = base_path
            self.project_modified = False

            # After a successful load, sync the UI entry with the loaded limit
            self.tile_limit_var.set(self.project_tile_limit)

            _debug(f" open_project: Project '{base_name}' data loaded successfully.")
            _debug(" open_project: Returning True.")
            return True
        else: 
            _error("open_project: Finalizing FAILURE. One or more components failed to load.")
            if not is_auto_load:
                messagebox.showerror("Project Open Error", 
                                     f"Failed to load one or more components for project '{base_name}'. The application state might be inconsistent.",
                                     parent=self.root)
            _debug(" open_project: Returning False.")
            return False

    def _execute_project_open(self, path_to_open, open_mode, preserved_palette=None):
        """The single, authoritative function to open a project based on the open_mode."""
        _debug(f" _execute_project_open: Opening '{path_to_open}', mode='{open_mode}'")

        # 1. Prepare for the change (gather states, close windows)
        self._prepare_for_project_change()

        # 2. Attempt to load the project data
        suppress_dialogs_on_fail = (open_mode == OPEN_MODE_STARTUP)
        success = self.open_project(filepath=path_to_open, is_auto_load=suppress_dialogs_on_fail, preserved_palette=preserved_palette)
        
        if success:
            # 3a. If successful, update recent list and finalize the UI
            base_path, _ = os.path.splitext(path_to_open)
            self._add_to_recent_list("projects", base_path)
            
            # Save the updated recent list to disk on an interactive open
            if open_mode in [OPEN_MODE_INTERACTIVE, OPEN_MODE_RECENT]:
                self._save_app_settings()

            self._finalize_project_change()
            # After loading a project, ensure the Map Editor is active.
            if hasattr(self, 'notebook') and self.notebook.winfo_exists():
                self.notebook.select(self.tab_map_editor)
        else:
            # 3b. If loading failed, reset to a clean slate
            _debug(" Failed to open project, resetting to a new untitled project.")
            self.new_project(interactive=False)
            self.current_project_base_path = None
            if open_mode in [OPEN_MODE_INTERACTIVE, OPEN_MODE_RECENT]:
                self._save_app_settings()
            self._finalize_project_change()
            # If opening fails, default to the Palette Editor for the new blank project.
            if hasattr(self, 'notebook') and self.notebook.winfo_exists():
                self.notebook.select(self.tab_palette_editor)
    
    def _perform_project_load_ui_updates(self):
        """Helper method to perform UI updates after a project load and Tkinter idle cycle."""
        _debug(" _perform_project_load_ui_updates: Starting deferred UI updates.")
        
        # Ensure the correct tab is selected (e.g., map editor - or a default)
        # If loading a project, perhaps default to the map editor or the palette editor.
        # For now, let's assume it might try to select the map editor.
        target_tab_after_load = self.tab_map_editor # Or self.tab_palette_editor
        try:
            if self.notebook and self.notebook.winfo_exists() and target_tab_after_load.winfo_exists():
                 self.notebook.select(target_tab_after_load)
                 _debug(f"   Switched to {target_tab_after_load.winfo_class()} tab after project load.")
            self.root.update_idletasks() # Allow tab switch to process
        except tk.TclError:
            _debug(" _perform_project_load_ui_updates: TclError selecting default tab after load.")

        # Now update all displays; widgets should have their correct sizes.
        self.update_all_displays(changed_level="all")
        
        self._update_edit_menu_state()
        self._update_editor_button_states()
        self._update_supertile_rotate_button_state()
        
        # Specific updates for map if it's the active tab now
        is_map_tab_active = False
        try:
            if self.notebook and self.notebook.winfo_exists():
                selected_tab_path = self.notebook.select()
                if selected_tab_path:
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
                    if selected_tab_widget == self.tab_map_editor:
                        is_map_tab_active = True
        except tk.TclError: pass

        if is_map_tab_active:
            if hasattr(self, 'map_canvas') and self.map_canvas.winfo_exists():
                self.map_canvas.focus_set()
            self.draw_minimap() 
            if hasattr(self, 'map_paned_window') and self.map_paned_window.winfo_exists() and self.map_paned_window.winfo_ismapped():
                self._do_check_and_enforce_palette_min_width()
        
        self._update_map_cursor() 
        
        # --- Re-apply usage window states AFTER project data is loaded and UI is stable ---
        _debug(" Project Load/New: Re-applying initial usage window states.")
        self._restore_window_states() # This will open windows as per config
        
        # Request refresh for any windows that were just re-opened by the call above
        self._request_color_usage_refresh()
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()
        
        _debug(" _perform_project_load_ui_updates: Deferred UI updates complete.")

    def set_tileset_limit(self, new_limit):
        """Handles user request to set a new tileset limit. Creates and executes an undoable command."""
        
        # 1. Validate the new limit
        if not (1 <= new_limit <= MAX_TILES):
            messagebox.showerror("Invalid Limit", f"Tileset limit must be between 1 and {MAX_TILES}.", parent=self.root)
            self.tile_limit_var.set(self.project_tile_limit) # Reset UI to the last valid limit
            return

        # Do nothing if the limit hasn't actually changed
        if new_limit == self.project_tile_limit:
            return

        current_size = len(tileset_patterns)

        # 2. Handle confirmation only if tiles will be deleted (truncation)
        if new_limit < current_size:
            affected_supertiles = set()
            for i in range(new_limit, current_size):
                usage = self._check_tile_usage(i)
                if usage:
                    affected_supertiles.update(usage)
            
            warning_msg = (
                f"Setting the limit to {new_limit} will delete tiles from index {new_limit} to {current_size - 1}.\n\n"
                "This action is fully undoable."
            )
            if affected_supertiles:
                warning_msg += "\n\nTiles being deleted are in use by one or more supertiles."

            if not messagebox.askokcancel("Confirm Truncate Tileset", warning_msg, icon="warning", parent=self.root):
                self.tile_limit_var.set(self.project_tile_limit) # Reset UI on cancel
                return
        
        # 3. If confirmed (or if changing limit without truncation), create and execute the command.
        command = SetTilesetLimitCommand(self, new_limit)
        self.undo_manager.execute(command)
        messagebox.showinfo("Tileset Limit", f"Tileset limit has been set to {self.project_tile_limit}.", parent=self.root)

    def set_supertile_limit(self, new_limit):
        """Handles user request to set a new supertile limit via an undoable command."""
        if not (1 <= new_limit <= MAX_SUPERTILES):
            messagebox.showerror("Invalid Limit", f"Supertile limit must be between 1 and {MAX_SUPERTILES}.", parent=self.root)
            self.supertile_limit_var.set(self.project_supertile_limit)
            return

        if new_limit == self.project_supertile_limit:
            return

        current_size = len(supertiles_data)

        if new_limit < current_size:
            affected_map_cells = []
            for i in range(new_limit, current_size):
                usage = self._check_supertile_usage(i)
                if usage:
                    affected_map_cells.extend(usage)
            
            warning_msg = (
                f"Setting the limit to {new_limit} will delete supertiles from index {new_limit} to {current_size - 1}.\n\n"
                "This action is fully undoable."
            )
            if affected_map_cells:
                warning_msg += "\n\nSupertiles being deleted are in use on the map. These map cells will be reset to Supertile 0."

            if not messagebox.askokcancel("Confirm Truncate Supertiles", warning_msg, icon="warning", parent=self.root):
                self.supertile_limit_var.set(self.project_supertile_limit)
                return
        
        command = SetSupertileLimitCommand(self, new_limit)
        self.undo_manager.execute(command)
        messagebox.showinfo("Supertile Limit", f"Supertile limit has been set to {self.project_supertile_limit}.", parent=self.root)

    def set_map_dimensions(self):
        global map_width, map_height, map_data

        prompt = "Enter new dimensions (Width x Height):"
        dims_str = simpledialog.askstring(
            "Set Map Dimensions", prompt, initialvalue=f"{map_width}x{map_height}", parent=self.root
        )

        if dims_str:
            try:
                parts = dims_str.lower().split("x")
                if len(parts) != 2:
                    raise ValueError("Format must be WidthxHeight")

                new_w_str = parts[0].strip()
                new_h_str = parts[1].strip()
                new_w = int(new_w_str)
                new_h = int(new_h_str)

                if not (MIN_DIM <= new_w <= MAX_DIM):
                    raise ValueError(f"Width must be between {MIN_DIM} and {MAX_DIM}")
                if not (MIN_DIM <= new_h <= MAX_DIM):
                    raise ValueError(f"Height must be between {MIN_DIM} and {MAX_DIM}")

                if new_w == map_width and new_h == map_height:
                    return

                reducing = new_w < map_width or new_h < map_height
                confirmed = True  
                if reducing:
                    confirm_prompt = "Reducing map size will discard data outside boundaries. Proceed?"
                    confirmed = messagebox.askokcancel("Resize Map", confirm_prompt, parent=self.root)

                if confirmed:
                    if self._clear_marked_unused(trigger_redraw=False):
                        pass

                    old_map_tuple = (map_width, map_height, copy.deepcopy(map_data))
                    
                    new_map_data_temp = [[0 for _ in range(new_w)] for _ in range(new_h)]
                    rows_to_copy = min(map_height, new_h)
                    cols_to_copy = min(map_width, new_w)
                    for r_idx in range(rows_to_copy): 
                        for c_idx in range(cols_to_copy): 
                            new_map_data_temp[r_idx][c_idx] = map_data[r_idx][c_idx]
                    
                    new_map_tuple = (new_w, new_h, new_map_data_temp)

                    def map_setter(data_tuple):
                        global map_width, map_height, map_data
                        map_width, map_height, map_data = data_tuple
                        
                        self._clamp_window_view_position()
                        self._trigger_minimap_reconfigure()
                        self._request_supertile_usage_refresh()

                    command = SetDataCommand("Set Map Dimensions", self, map_setter, new_map_tuple, old_map_tuple)
                    self.undo_manager.execute(command)

            except ValueError as e:
                messagebox.showerror("Invalid Input", f"Error setting dimensions: {e}", parent=self.root)
            except Exception as e:
                messagebox.showerror(
                    "Error", f"An unexpected error occurred during map resize: {e}", parent=self.root
                )

    def clear_current_tile(self):
        global current_tile_index
        if not (0 <= current_tile_index < len(tileset_patterns)):
            messagebox.showwarning("Clear Tile", "No valid tile selected to clear.", parent=self.root)
            return
            
        prompt = f"Clear pattern and reset colors for Tile {current_tile_index}?"
        if messagebox.askokcancel("Clear Tile", prompt, parent=self.root):
            command = ClearTileCommand(self, current_tile_index)
            self.undo_manager.execute(command)
            _debug(f"Cleared Tile {current_tile_index} via command.")

    def clear_current_supertile(self):
        global current_supertile_index
        if not (0 <= current_supertile_index < len(supertiles_data)):
            return
        prompt = f"Clear definition (set all to tile 0) for supertile {current_supertile_index}?"
        if messagebox.askokcancel("Clear Supertile", prompt):
            command = ClearSupertileCommand(self, current_supertile_index)
            self.undo_manager.execute(command)

    def clear_map(self):
        prompt = "Clear entire map (set all to supertile 0)?"
        if messagebox.askokcancel("Clear Map", prompt):
            if self._clear_marked_unused(trigger_redraw=False):
                pass

            command = ClearMapCommand(self)
            self.undo_manager.execute(command)

    def copy_current_tile(self):
        global current_tile_index, tileset_patterns, tileset_colors
        if not (0 <= current_tile_index < len(tileset_patterns)):
            messagebox.showwarning("Copy Tile", "No valid tile selected.")
            return

        # Assemble data, including the palette, for the clipboard.
        clipboard_data = {
            "app_id": "MSXTileForge",
            "data_type": "tile",
            "version": "1.1", # Version for format with palette
            "payload": {
                "pattern": tileset_patterns[current_tile_index],
                "colors": tileset_colors[current_tile_index],
                "source_palette_hex": self.active_msx_palette
            }
        }

        try:
            # Serialize to a JSON string and place on system clipboard.
            json_string = json.dumps(clipboard_data)
            self.root.clipboard_clear()
            self.root.clipboard_append(json_string)
            _info(f"Tile {current_tile_index} copied to the system clipboard (with palette).")
            self._update_edit_menu_state()
        except Exception as e:
            _error(f"Failed to copy tile to system clipboard: {e}")
            messagebox.showerror("Copy Error", "Could not copy tile data to the system clipboard.")

    def paste_tile(self):
        global current_tile_index, tileset_patterns, tileset_colors
        if not (0 <= current_tile_index < len(tileset_patterns)):
            messagebox.showwarning("Paste Tile", "No valid tile selected to paste onto.")
            return

        try:
            json_string = self.root.clipboard_get()
            clipboard_data = json.loads(json_string)

            if not isinstance(clipboard_data, dict) or \
               clipboard_data.get("app_id") != "MSXTileForge" or \
               clipboard_data.get("data_type") != "tile":
                messagebox.showinfo("Paste Tile", "The clipboard does not contain valid MSX Tile Forge tile data.")
                return

            payload = clipboard_data.get("payload", {})
            pasted_pattern = payload.get("pattern")
            pasted_colors = payload.get("colors")
            source_palette_hex = payload.get("source_palette_hex")

            if not all([pasted_pattern, pasted_colors, source_palette_hex]):
                raise ValueError("Clipboard data payload is missing pattern, colors, or palette information.")
            
            remap_table = self._create_color_remap_table(source_palette_hex, self.active_msx_palette)
            remapped_colors = []
            for src_fg, src_bg in pasted_colors:
                dest_fg = remap_table.get(src_fg, 0)
                dest_bg = remap_table.get(src_bg, 0)
                remapped_colors.append((dest_fg, dest_bg))

            # Capture the index at the time of command creation.
            target_tile_index = current_tile_index

            def pattern_setter(data):
                tileset_patterns[target_tile_index] = data
            def colors_setter(data):
                tileset_colors[target_tile_index] = data

            pattern_command = SetDataCommand("Paste Tile (Pattern)", self, pattern_setter, pasted_pattern, tileset_patterns[target_tile_index])
            colors_command = SetDataCommand("Paste Tile (Colors)", self, colors_setter, remapped_colors, tileset_colors[target_tile_index])
            
            post_paste_hooks = [
                lambda: self.invalidate_tile_cache(target_tile_index),
                self._request_color_usage_refresh,
                self._request_tile_usage_refresh,
                self._request_supertile_usage_refresh
            ]

            composite = CompositeCommand(
                "Paste Tile", 
                [pattern_command, colors_command],
                app_ref=self,
                post_hooks=post_paste_hooks
            )
            self.undo_manager.execute(composite)
            
            _info(f"Pasted from system clipboard onto Tile {target_tile_index} with color remapping.")

        except tk.TclError:
            messagebox.showinfo("Paste Tile", "Clipboard is empty or does not contain text data.")
        except (json.JSONDecodeError, ValueError, KeyError) as e:
            _error(f"Error pasting from clipboard: {e}")
            messagebox.showinfo("Paste Tile", "The clipboard does not contain valid MSX Tile Forge tile data.")

    def copy_current_supertile(self):
        global current_supertile_index, supertiles_data
        global tileset_patterns, tileset_colors

        if not (0 <= current_supertile_index < len(supertiles_data)):
            messagebox.showwarning("Copy Supertile", "No valid supertile selected.")
            return

        definition = supertiles_data[current_supertile_index]

        # Find all unique tile indices used in this supertile.
        unique_tile_indices = set()
        for row in definition:
            for tile_idx in row:
                unique_tile_indices.add(tile_idx)
        
        # For each unique tile, package its pattern and color data.
        # This creates a self-contained tileset on the clipboard.
        source_tiles_payload = {}
        for tile_idx in unique_tile_indices:
            if 0 <= tile_idx < len(tileset_patterns):
                source_tiles_payload[tile_idx] = {
                    "pattern": tileset_patterns[tile_idx],
                    "colors": tileset_colors[tile_idx]
                }

        # Assemble the final clipboard data structure.
        clipboard_data = {
            "app_id": "MSXTileForge",
            "data_type": "supertile",
            "version": "1.0",
            "payload": {
                "definition": definition,
                "source_tiles": source_tiles_payload,
                "source_palette_hex": self.active_msx_palette
            }
        }

        try:
            # Serialize and copy to the system clipboard.
            json_string = json.dumps(clipboard_data)
            self.root.clipboard_clear()
            self.root.clipboard_append(json_string)
            
            _info(f"Supertile {current_supertile_index} copied to the system clipboard.")
            self._update_edit_menu_state()

        except Exception as e:
            _error(f"Failed to copy supertile to system clipboard: {e}")
            messagebox.showerror("Copy Error", "Could not copy supertile data to the system clipboard.")

    def paste_supertile(self):
        global current_supertile_index, supertiles_data
        if not (0 <= current_supertile_index < len(supertiles_data)):
            messagebox.showwarning("Paste Supertile", "No valid supertile selected to paste onto.")
            return

        try:
            json_string = self.root.clipboard_get()
            clipboard_data = json.loads(json_string)

            if not isinstance(clipboard_data, dict) or \
               clipboard_data.get("app_id") != "MSXTileForge" or \
               clipboard_data.get("data_type") != "supertile":
                messagebox.showinfo("Paste Supertile", "The clipboard does not contain valid MSX Tile Forge supertile data.")
                return

            payload = clipboard_data.get("payload", {})
            pasted_definition = payload.get("definition")
            source_tiles = payload.get("source_tiles", {})
            source_palette_hex = payload.get("source_palette_hex")

            if not all([pasted_definition, source_tiles, source_palette_hex]):
                raise ValueError("Clipboard data payload is missing definition, tiles, or palette information.")
            
            dest_tileset_fingerprints = {}
            for i in range(len(tileset_patterns)):
                fingerprint = self._render_tile_to_lab_pixels(
                    tileset_patterns[i], tileset_colors[i], self.active_msx_palette
                )
                if fingerprint:
                    dest_tileset_fingerprints[i] = fingerprint
            
            tile_remap_table = {}
            for src_idx_str, src_tile_data in source_tiles.items():
                src_idx = int(src_idx_str)
                source_lab_pixels = self._render_tile_to_lab_pixels(
                    src_tile_data["pattern"], src_tile_data["colors"], source_palette_hex
                )
                if source_lab_pixels:
                    best_match_dest_idx = self._find_best_tile_match(source_lab_pixels, dest_tileset_fingerprints)
                    tile_remap_table[src_idx] = best_match_dest_idx

            new_definition = copy.deepcopy(pasted_definition)
            for r in range(len(new_definition)):
                for c in range(len(new_definition[r])):
                    original_tile_idx = new_definition[r][c]
                    new_definition[r][c] = tile_remap_table.get(original_tile_idx, 0)

            if len(new_definition) != self.supertile_grid_height or \
               len(new_definition[0]) != self.supertile_grid_width:
                messagebox.showerror("Paste Error", "Supertile clipboard dimensions do not match current project dimensions. Paste aborted.")
                return

            # Capture the index at the time of command creation.
            target_st_index = current_supertile_index

            def st_data_setter(data):
                supertiles_data[target_st_index] = data
                # Move side-effects that depend on the index into the setter
                self.invalidate_supertile_cache(target_st_index)
                self.invalidate_minimap_background_cache()
                self._request_tile_usage_refresh()
                self._request_supertile_usage_refresh()
            
            command = SetDataCommand("Paste Supertile", self, st_data_setter, new_definition, supertiles_data[target_st_index])
            # The CompositeCommand is not needed for a single command
            self.undo_manager.execute(command)

            _info(f"Pasted from system clipboard onto Supertile {target_st_index} with tile remapping.")

        except tk.TclError:
            messagebox.showinfo("Paste Supertile", "Clipboard is empty or does not contain text data.")
        except (json.JSONDecodeError, ValueError, KeyError) as e:
            _error(f"Error pasting supertile from clipboard: {e}")
            messagebox.showinfo("Paste Supertile", "The clipboard does not contain valid MSX Tile Forge supertile data.")

    def paste_map(self):
        """Pastes the map clipboard data to the current cursor location."""
        if not self.map_clipboard_data:
            messagebox.showinfo("Paste Map Region", "Map clipboard is empty.", parent=self.root)
            return

        canvas = self.map_canvas
        try:
            pointer_x = canvas.winfo_pointerx() - canvas.winfo_rootx()
            pointer_y = canvas.winfo_pointery() - canvas.winfo_rooty()
            canvas_x = canvas.canvasx(pointer_x)
            canvas_y = canvas.canvasy(pointer_y)
        except tk.TclError:
            messagebox.showerror("Paste Error", "Could not get mouse position for map paste.", parent=self.root)
            return

        paste_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)
        if paste_coords is None:
            messagebox.showinfo("Paste Map Region", "Cannot paste here: Current mouse position is outside the map boundaries.", parent=self.root)
            return

        old_map_data = copy.deepcopy(map_data)
        new_map_data = copy.deepcopy(map_data)
        paste_st_col, paste_st_row = paste_coords
        clip_w = self.map_clipboard_data["width"]
        clip_h = self.map_clipboard_data["height"]
        clip_data = self.map_clipboard_data["data"]
        
        for r_offset in range(clip_h):
            for c_offset in range(clip_w):
                target_map_row = paste_st_row + r_offset
                target_map_col = paste_st_col + c_offset
                if (0 <= target_map_row < map_height and 0 <= target_map_col < map_width):
                    if r_offset < len(clip_data) and c_offset < len(clip_data[r_offset]):
                        st_index_to_paste = clip_data[r_offset][c_offset]
                        if 0 <= st_index_to_paste < len(supertiles_data):
                            new_map_data[target_map_row][target_map_col] = st_index_to_paste
                        else:
                            new_map_data[target_map_row][target_map_col] = 0
        
        if new_map_data != old_map_data:
            def map_data_setter(data):
                global map_data
                map_data = data

            command = SetDataCommand("Paste Map Region", self, map_data_setter, new_map_data, old_map_data)
            self.undo_manager.execute(command)
        else:
            messagebox.showinfo("Paste Map Region", "No changes made to the map by paste operation (content might be identical or outside bounds).", parent=self.root)

    # --- Zoom Methods ---
    def change_map_zoom_mult(self, factor):  # Renamed from change_map_zoom
        """Applies multiplicative zoom, centered on the current canvas center."""
        canvas = self.map_canvas
        view_x1, view_y1, view_x2, view_y2 = (
            canvas.xview()[0],
            canvas.yview()[0],
            canvas.xview()[1],
            canvas.yview()[1],
        )
        center_x_canvas = canvas.canvasx(
            (canvas.winfo_width() / 2)
        )  # Approximation of center
        center_y_canvas = canvas.canvasy((canvas.winfo_height() / 2))
        self.zoom_map_at_point(factor, center_x_canvas, center_y_canvas)

    def get_zoomed_tile_size(self):
        """Calculates the current TILE size based on 8x8 base and zoom."""
        base_tile_size = 8  # 100% zoom = 8 pixels
        zoomed_size = base_tile_size * self.map_zoom_level
        return max(1, int(zoomed_size))  # Ensure at least 1 pixel

    # --- Scrolling Methods ---

    def scroll_viewers_to_tile(self, tile_index):
        """Scrolls the tileset viewers to make the specified tile index visible."""
        # Basic input validation
        if tile_index < 0:
            return

        # Define layout parameters
        padding = 1
        tile_size = VIEWER_TILE_SIZE
        items_per_row = NUM_TILES_ACROSS

        # Calculate target row and y-coordinate
        row, _ = divmod(tile_index, items_per_row)
        target_y = row * (tile_size + padding)

        # --- Scroll main viewer ---
        canvas_main = self.tileset_canvas
        try:
            # Get scroll region info (might be tuple or string)
            scroll_info_tuple = canvas_main.cget("scrollregion")
            # Convert to string and split for consistent parsing
            scroll_info = str(scroll_info_tuple).split()

            # Check if format is valid ("0 0 width height")
            if len(scroll_info) == 4:
                # Extract total height
                total_height = float(scroll_info[3])

                # Avoid division by zero
                if total_height > 0:
                    # Calculate scroll fraction
                    fraction = target_y / total_height
                    # Clamp fraction to valid range [0.0, 1.0]
                    clamped_fraction = min(1.0, max(0.0, fraction))
                    # Perform the scroll
                    canvas_main.yview_moveto(clamped_fraction)

        except Exception as e:
            # Catch any error during scrolling
            _error(f"Error scrolling main tileset viewer: {e}")

        # --- Scroll Supertile tab's viewer ---
        canvas_st = self.st_tileset_canvas
        try:
            scroll_info_st_tuple = canvas_st.cget("scrollregion")
            scroll_info_st = str(scroll_info_st_tuple).split()

            if len(scroll_info_st) == 4:
                total_height_st = float(scroll_info_st[3])

                if total_height_st > 0:
                    fraction_st = target_y / total_height_st
                    clamped_fraction_st = min(1.0, max(0.0, fraction_st))
                    canvas_st.yview_moveto(clamped_fraction_st)

        except Exception as e:
            _error(f"Error scrolling ST tileset viewer: {e}")

    def scroll_selectors_to_supertile(self, supertile_index):
        _debug(f"\n scroll_selectors_to_supertile: Attempting to ensure ST Index {supertile_index} is visible.")
        if supertile_index < 0:
            _debug(f"   Invalid supertile_index {supertile_index}. Aborting.")
            return

        canvases_to_scroll = []
        # Ensure we only try to scroll the selector that is currently visible (on the active tab)
        # This avoids unnecessary calculations and potential issues with non-mapped canvases.
        active_tab_widget = None
        if self.notebook and self.notebook.winfo_exists():
            try:
                selected_tab_path = self.notebook.select()
                if selected_tab_path:
                    active_tab_widget = self.notebook.nametowidget(selected_tab_path)
            except tk.TclError:
                _debug("   TclError getting active tab. Cannot determine which selector to scroll.")
                return
        
        if active_tab_widget == self.tab_supertile_editor:
            if hasattr(self, 'supertile_selector_canvas') and self.supertile_selector_canvas.winfo_exists():
                canvases_to_scroll.append({"widget": self.supertile_selector_canvas, "name": "SupertileTabSelector"})
        elif active_tab_widget == self.tab_map_editor:
            if hasattr(self, 'map_supertile_selector_canvas') and self.map_supertile_selector_canvas.winfo_exists():
                canvases_to_scroll.append({"widget": self.map_supertile_selector_canvas, "name": "MapTabSelector"})
        
        if not canvases_to_scroll:
            _debug("   No relevant selector canvas is active/found to scroll.")
            return

        item_pixel_h_content = self.supertile_grid_height * TILE_HEIGHT
        item_pixel_w_content = self.supertile_grid_width * TILE_WIDTH
        padding = 1

        if item_pixel_w_content <= 0 or item_pixel_h_content <= 0:
            _debug(f"   Invalid item content pixel dimensions (W:{item_pixel_w_content}, H:{item_pixel_h_content}). Aborting.")
            return

        for canvas_info in canvases_to_scroll:
            canvas_widget = canvas_info["widget"]
            canvas_name = canvas_info["name"]
            _debug(f"   Processing scroll for: {canvas_name} to ST Index {supertile_index}")

            try:
                if not canvas_widget.winfo_ismapped():
                    _debug(f"     Canvas {canvas_name} is not mapped. Skipping scroll.")
                    continue

                canvas_widget.update_idletasks()
                actual_canvas_width = canvas_widget.winfo_width()
                canvas_viewport_height = canvas_widget.winfo_height() # Height of the visible part of the canvas
                _debug(f"     {canvas_name} - Actual Canvas Width: {actual_canvas_width}, Viewport Height: {canvas_viewport_height}")

                if actual_canvas_width <= 1 or canvas_viewport_height <= 1:
                    _debug(f"     {canvas_name} - Canvas dimensions too small. Skipping scroll.")
                    continue
                
                items_across_for_this_canvas = 0
                denominator_check = item_pixel_w_content + padding
                if denominator_check <= 0:
                    items_across_for_this_canvas = 1
                elif item_pixel_w_content + (2 * padding) > actual_canvas_width:
                    items_across_for_this_canvas = 0
                    if item_pixel_w_content <= actual_canvas_width:
                        items_across_for_this_canvas = 1
                else:
                    items_across_for_this_canvas = (actual_canvas_width - padding) // denominator_check
                items_across_for_this_canvas = max(1, items_across_for_this_canvas)
                _debug(f"     {canvas_name} - Calculated items_across: {items_across_for_this_canvas}")

                target_row, _ = divmod(supertile_index, items_across_for_this_canvas)
                target_item_y_top_content = target_row * (item_pixel_h_content + padding) + padding
                target_item_y_bottom_content = target_item_y_top_content + item_pixel_h_content
                _debug(f"     {canvas_name} - Target ST Index: {supertile_index}, Target Row: {target_row}")
                _debug(f"     {canvas_name} - Target Item Y Content (top/bottom): {target_item_y_top_content} / {target_item_y_bottom_content}")

                scroll_region_str_list = canvas_widget.cget("scrollregion")
                if not scroll_region_str_list: _debug(f"     {canvas_name} - Scrollregion is empty/None."); continue
                scroll_info_parts = str(scroll_region_str_list).split()
                if len(scroll_info_parts) != 4: _debug(f"     {canvas_name} - Invalid scrollregion format: {scroll_info_parts}."); continue
                
                total_content_height_in_scrollregion = float(scroll_info_parts[3])
                _debug(f"     {canvas_name} - Total Content Height in Scrollregion: {total_content_height_in_scrollregion}")

                if total_content_height_in_scrollregion <= 0: _debug(f"     {canvas_name} - Scrollregion height is zero or negative."); continue
                
                # --- Visibility Check ---
                # Get current viewport in content coordinates
                current_view_y1_content = canvas_widget.canvasy(0)
                current_view_y2_content = canvas_widget.canvasy(canvas_viewport_height)
                _debug(f"     {canvas_name} - Current Viewport Y (content coords): {current_view_y1_content:.2f} to {current_view_y2_content:.2f}")

                # Is the item already fully visible?
                # Add a small tolerance (e.g., 1 pixel) for floating point comparisons
                tolerance = 1 
                is_top_edge_visible = target_item_y_top_content >= (current_view_y1_content - tolerance)
                is_bottom_edge_visible = target_item_y_bottom_content <= (current_view_y2_content + tolerance)

                if is_top_edge_visible and is_bottom_edge_visible:
                    _debug(f"     {canvas_name} - Item {supertile_index} IS ALREADY FULLY VISIBLE. No scroll initiated.")
                else:
                    _debug(f"     {canvas_name} - Item {supertile_index} NOT fully visible (TopEdgeVis: {is_top_edge_visible}, BotEdgeVis: {is_bottom_edge_visible}). Proceeding with scroll calculation.")
                    # If item's top is above current view, scroll to bring its top to view_top
                    # If item's bottom is below current view, scroll to bring its bottom to view_bottom
                    # If item is larger than viewport, scroll to bring its top to view_top

                    target_scroll_y_content = target_item_y_top_content # Default: bring top of item to top of view

                    if target_item_y_bottom_content > current_view_y2_content and target_item_y_top_content > current_view_y1_content:
                        # If item's bottom is below view AND its top is also below (or at) view_top (i.e., item is mostly below)
                        # Scroll to make item's bottom align with viewport bottom
                        target_scroll_y_content = target_item_y_bottom_content - canvas_viewport_height
                    
                    # target_scroll_y_content is the desired content Y coordinate for the top of the viewport
                    fraction = target_scroll_y_content / total_content_height_in_scrollregion
                    clamped_fraction = min(1.0, max(0.0, fraction))
                
                    _debug(f"     {canvas_name} - Calculated scroll fraction: {fraction:.4f}, Clamped fraction: {clamped_fraction:.4f}")
                    
                    # Only call yview_moveto if the new fraction is different enough from the current one
                    current_y_view_fractions = canvas_widget.yview()
                    if abs(current_y_view_fractions[0] - clamped_fraction) > (1 / total_content_height_in_scrollregion) : # Only if change is > 1 pixel approx
                        _debug(f"     {canvas_name} - Current yview_frac[0]={current_y_view_fractions[0]:.4f}. Calling yview_moveto({clamped_fraction:.4f}).")
                        canvas_widget.yview_moveto(clamped_fraction)

                        correct_highlight_index = -1
                        if canvas_widget == self.supertile_selector_canvas:
                            correct_highlight_index = current_supertile_index
                        elif canvas_widget == self.map_supertile_selector_canvas:
                            correct_highlight_index = selected_supertile_for_map
                        self.draw_supertile_selector(canvas_widget, correct_highlight_index)
                    else:
                        _debug(f"     {canvas_name} - Calculated scroll fraction {clamped_fraction:.4f} is too close to current yview_frac[0]={current_y_view_fractions[0]:.4f}. Scroll yview_moveto SKIPPED.")


            except tk.TclError as e_scroll:
                _error(f"     {canvas_name} - TclError during scroll: {e_scroll}")
            except Exception as e_scroll_generic:
                _error(f"     {canvas_name} - Unexpected error during scroll: {e_scroll_generic}")
        _debug(f" scroll_selectors_to_supertile: Finished processing for ST Index {supertile_index}\n")

    def toggle_supertile_grid(self):
        """Callback for the supertile grid checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide grid

    def toggle_window_view(self):
        """Callback for the window view checkbutton."""
        self.draw_map_canvas()  # Redraw map to show/hide window view
        self.draw_minimap()

    def cycle_grid_color(self):
        """Cycles through the available grid colors."""
        self.grid_color_index = (self.grid_color_index + 1) % len(GRID_COLOR_CYCLE)
        # Redraw map if grids are visible
        if self.show_supertile_grid.get() or self.show_window_view.get():
            self.draw_map_canvas()
        print(f"Grid color set to: {GRID_COLOR_CYCLE[self.grid_color_index]}")

    def apply_window_size_from_entries(self):
        """Applies the W/H values from the Entry widgets."""
        try:
            new_w = self.window_view_tile_w.get()  # Get value from IntVar
            new_h = self.window_view_tile_h.get()

            # Validate range
            min_w, max_w = 1, 32
            min_h, max_h = 1, MAX_WIN_VIEW_HEIGHT_TILES
            valid = True
            if not (min_w <= new_w <= max_w):
                messagebox.showerror(
                    "Invalid Width", f"Window width must be {min_w}-{max_w}."
                )
                valid = False
            if not (min_h <= new_h <= max_h):
                messagebox.showerror(
                    "Invalid Height", f"Window height must be {min_h}-{max_h}."
                )
                valid = False

            if not valid:
                # Reset entries to current state if invalid
                self._update_window_size_vars_from_state()  # Use internal helper
                return

            # If size changed (or even if not, just redraw for simplicity)
            self._clamp_window_view_position()  # Ensure position is valid for new size
            self.draw_map_canvas()
            self.draw_minimap()
            print(f"Window view size set to {new_w}x{new_h} tiles via input.")

        except tk.TclError:  # Handles non-integer input in IntVars
            messagebox.showerror(
                "Invalid Input",
                "Please enter valid integer numbers for width and height.",
            )
            self._update_window_size_vars_from_state()  # Reset on error
        except Exception as e:
            messagebox.showerror("Error", f"Could not apply size: {e}")
            self._update_window_size_vars_from_state()

    def _update_window_size_vars_from_state(self):
        """Internal helper to set IntVars from the state variables."""
        # Needed because the IntVars are bound to entries, direct setting is best
        self.window_view_tile_w.set(
            self.window_view_tile_w.get()
        )  # Trigger update if needed
        self.window_view_tile_h.set(self.window_view_tile_h.get())

    def _clamp_window_view_position(self):
        current_w = self.window_view_tile_w.get()
        current_h = self.window_view_tile_h.get()

        total_map_tiles_w = map_width * self.supertile_grid_width
        total_map_tiles_h = map_height * self.supertile_grid_height

        max_tile_x_clamp = total_map_tiles_w - current_w
        max_tile_y_clamp = total_map_tiles_h - current_h

        max_tile_x_clamp = max(0, max_tile_x_clamp)
        max_tile_y_clamp = max(0, max_tile_y_clamp)
        
        self.window_view_tile_x = max(0, min(self.window_view_tile_x, max_tile_x_clamp))
        self.window_view_tile_y = max(0, min(self.window_view_tile_y, max_tile_y_clamp))

    # --- Window View Drag/Resize Handlers ---
    def _get_handle_at(self, canvas_x, canvas_y):
        """Checks if the click is on a resize handle, returns handle tag ('nw', 'n', etc.) or None."""
        if not self.show_window_view.get():
            return None
        # Find items tagged 'window_view_handle' near the click
        search_radius = WIN_VIEW_HANDLE_SIZE  # Search slightly larger than handle
        items = self.map_canvas.find_overlapping(
            canvas_x - search_radius,
            canvas_y - search_radius,
            canvas_x + search_radius,
            canvas_y + search_radius,
        )
        for item_id in items:
            tags = self.map_canvas.gettags(item_id)
            if "window_view_handle" in tags:
                for t in tags:
                    if t.startswith("handle_"):
                        return t.split("_")[1]  # Return 'nw', 'n', etc.
        return None  # No handle found

    def _is_inside_window_view(self, canvas_x, canvas_y):
        """Checks if the click is inside the window view rectangle bounds."""
        if not self.show_window_view.get():
            return False
        zoomed_tile_size = self.get_zoomed_tile_size()
        win_px = self.window_view_tile_x * zoomed_tile_size
        win_py = self.window_view_tile_y * zoomed_tile_size
        win_pw = self.window_view_tile_w.get() * zoomed_tile_size
        win_ph = self.window_view_tile_h.get() * zoomed_tile_size
        return (
            win_px <= canvas_x < win_px + win_pw
            and win_py <= canvas_y < win_py + win_ph
        )

    def handle_map_click_or_drag_start(self, event):
        """
        Handles initial NON-CTRL click to start a paint stroke or window view drag.
        """
        # --- Cancel any pending single-click paint from a previous click ---
        if self.single_click_timer is not None:
            self.root.after_cancel(self.single_click_timer)
            self.single_click_timer = None

        # --- Standard modifier and action checks ---
        if self.is_shift_pressed or (event.state & 0x0004) or self.current_mouse_action is not None:
            return "break"

        self._clear_map_selection()
        canvas = self.map_canvas
        canvas.focus_set()
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # --- Window view drag/resize logic ---
        handle = self._get_handle_at(canvas_x, canvas_y)
        if handle and self.show_window_view.get():
            self.current_mouse_action = "window_resizing"
            self.window_view_resize_handle = handle
            self.drag_start_x, self.drag_start_y = canvas_x, canvas_y
            self.drag_start_win_tx, self.drag_start_win_ty = self.window_view_tile_x, self.window_view_tile_y
            self.drag_start_win_tw, self.drag_start_win_th = self.window_view_tile_w.get(), self.window_view_tile_h.get()
            self._update_map_cursor()
            return "break"
        elif self._is_inside_window_view(canvas_x, canvas_y) and self.show_window_view.get():
            self.current_mouse_action = "window_dragging"
            self.drag_start_x, self.drag_start_y = canvas_x, canvas_y
            self.drag_start_win_tx, self.drag_start_win_ty = self.window_view_tile_x, self.window_view_tile_y
            self._update_map_cursor()
            return "break"
        
        # --- Start a paint action ---
        self.current_mouse_action = "painting"
        self.pending_command_list.clear() # Clear list for new stroke
        self._paint_map_cell(canvas_x, canvas_y)

    def handle_map_drag(self, event):
        """Handles motion for non-panning actions (paint, window drag/resize)."""

        # Ignore if panning or no suitable action is set from Button-1 press
        # This prevents interference if Ctrl was pressed *after* Button-1 was down but before motion.
        if self.current_mouse_action not in [
            "painting",
            "window_dragging",
            "window_resizing",
        ]:
            return  # Don't handle if not in a valid non-pan drag state

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # Perform action based on the current state
        if self.current_mouse_action == "painting":
            self._paint_map_cell(canvas_x, canvas_y)
        elif self.current_mouse_action == "window_dragging":
            self._do_window_move_drag(canvas_x, canvas_y)
        elif self.current_mouse_action == "window_resizing":
            self._do_window_resize_drag(canvas_x, canvas_y)

        return "break"  # Prevent other B1-Motion bindings

    def handle_map_drag_release(self, event):
        """Handles mouse button release: ends paint, pan, or window ops, committing commands."""
        global last_painted_map_cell
        action_at_release = self.current_mouse_action

        # If the action was painting and we have pending commands, create a composite command.
        if action_at_release == "painting" and self.pending_command_list:
            composite = CompositeCommand("Paint Stroke", self.pending_command_list[:], self)
            self.undo_manager.register(composite)
            self.pending_command_list.clear()

        last_painted_map_cell = None
        self.current_mouse_action = None

        if action_at_release == "panning":
            self.draw_map_canvas()
        elif action_at_release == "window_resizing":
            self._clamp_window_view_position()
            self._update_window_size_vars_from_state()
            self.window_view_resize_handle = None
            self.draw_map_canvas()

        self._update_map_cursor()
        self.draw_minimap()

    def toggle_minimap(self):
        """Opens/raises the resizable minimap window."""
        if self.minimap_window is None or not tk.Toplevel.winfo_exists(
            self.minimap_window
        ):
            self.minimap_window = tk.Toplevel(self.root)
            self.minimap_window.title("Minimap")
            # Set initial size, but allow resizing
            self.minimap_window.geometry(
                f"{MINIMAP_INITIAL_WIDTH}x{MINIMAP_INITIAL_HEIGHT}"
            )
            # self.minimap_window.resizable(False, False) # REMOVE or set True

            self.minimap_canvas = tk.Canvas(
                self.minimap_window, bg="dark slate gray", highlightthickness=0
            )
            # Make canvas fill the resizable window
            self.minimap_canvas.pack(fill=tk.BOTH, expand=True)  # MODIFIED pack options
            self.minimap_window.protocol("WM_DELETE_WINDOW", self._on_minimap_close)
            self.minimap_window.bind("<Configure>", self._on_minimap_configure)

            # Initial draw (will use initial geometry)
            # Need to ensure canvas has dimensions before first draw
            self.minimap_window.update_idletasks()  # Process geometry requests
            self.draw_minimap()
        else:
            self.minimap_window.lift()
            self.minimap_window.focus_set()

    def _on_minimap_close(self):
        """Handles the closing of the minimap window."""
        if self.minimap_window:
            self.minimap_window.destroy()  # Destroy the window
        self.minimap_window = None  # Reset state variable
        self.minimap_canvas = None

    def draw_minimap(self):
        if self.minimap_window is None or self.minimap_canvas is None:
            return
        if not tk.Toplevel.winfo_exists(self.minimap_window):
            self._on_minimap_close()
            return

        canvas_mm = self.minimap_canvas # Renamed
        canvas_mm.delete("all")

        current_minimap_w_px = canvas_mm.winfo_width()
        current_minimap_h_px = canvas_mm.winfo_height()
        if current_minimap_w_px <= 1 or current_minimap_h_px <= 1:
            return

        if (
            self.minimap_background_cache is None
            or self.minimap_bg_rendered_width != current_minimap_w_px
            or self.minimap_bg_rendered_height != current_minimap_h_px
        ):
            self.minimap_background_cache = self._create_minimap_background_image(
                current_minimap_w_px, current_minimap_h_px
            )

        if self.minimap_background_cache:
            canvas_mm.create_image(
                0, 0, image=self.minimap_background_cache, anchor=tk.NW, tags="minimap_bg_image"
            )
        else:
            canvas_mm.create_rectangle(
                0, 0, current_minimap_w_px, current_minimap_h_px, fill="gray10"
            )

        # Total map dimensions in base MSX pixels
        map_total_msx_pixel_w = map_width * self.supertile_grid_width * TILE_WIDTH
        map_total_msx_pixel_h = map_height * self.supertile_grid_height * TILE_HEIGHT
        
        if map_total_msx_pixel_w <= 0 or map_total_msx_pixel_h <= 0:
            return

        scale_x_overlay = current_minimap_w_px / map_total_msx_pixel_w
        scale_y_overlay = current_minimap_h_px / map_total_msx_pixel_h
        scale_overlay = min(scale_x_overlay, scale_y_overlay)

        scaled_map_content_w_overlay = map_total_msx_pixel_w * scale_overlay
        scaled_map_content_h_overlay = map_total_msx_pixel_h * scale_overlay
        offset_x_overlay_render = (current_minimap_w_px - scaled_map_content_w_overlay) / 2
        offset_y_overlay_render = (current_minimap_h_px - scaled_map_content_h_overlay) / 2

        try:
            main_map_canvas = self.map_canvas # Renamed
            scroll_x_fractions = main_map_canvas.xview()
            scroll_y_fractions = main_map_canvas.yview()

            # Total BASE map dimensions in MSX pixels (same as map_total_msx_pixel_w/h above)
            # This is what the scroll fractions are relative to.
            # map_total_base_msx_w = map_width * self.supertile_grid_width * TILE_WIDTH
            # map_total_base_msx_h = map_height * self.supertile_grid_height * TILE_HEIGHT
            # No need to recalculate, use map_total_msx_pixel_w/h

            if map_total_msx_pixel_w > 0 and map_total_msx_pixel_h > 0:
                map_viewport_msx_px_x1 = scroll_x_fractions[0] * map_total_msx_pixel_w
                map_viewport_msx_px_y1 = scroll_y_fractions[0] * map_total_msx_pixel_h
                map_viewport_msx_px_x2 = scroll_x_fractions[1] * map_total_msx_pixel_w
                map_viewport_msx_px_y2 = scroll_y_fractions[1] * map_total_msx_pixel_h

                vp_x1_draw = offset_x_overlay_render + map_viewport_msx_px_x1 * scale_overlay
                vp_y1_draw = offset_y_overlay_render + map_viewport_msx_px_y1 * scale_overlay
                vp_x2_draw = offset_x_overlay_render + map_viewport_msx_px_x2 * scale_overlay
                vp_y2_draw = offset_y_overlay_render + map_viewport_msx_px_y2 * scale_overlay

                canvas_mm.create_rectangle(
                    vp_x1_draw, vp_y1_draw, vp_x2_draw, vp_y2_draw,
                    outline=self.MINIMAP_VIEWPORT_COLOR, width=2, tags="minimap_viewport"
                )
        except Exception as e:
            _error(f"Error drawing minimap viewport: {e}")
            pass

        if self.show_window_view.get():
            try:
                win_tx_mm = self.window_view_tile_x # In base tiles
                win_ty_mm = self.window_view_tile_y
                win_tw_mm = self.window_view_tile_w.get()
                win_th_mm = self.window_view_tile_h.get()

                # Window view dimensions in MSX pixels
                win_map_msx_px1 = win_tx_mm * TILE_WIDTH
                win_map_msx_py1 = win_ty_mm * TILE_HEIGHT
                win_map_msx_px2 = win_map_msx_px1 + (win_tw_mm * TILE_WIDTH)
                win_map_msx_py2 = win_map_msx_py1 + (win_th_mm * TILE_HEIGHT)

                wv_x1_draw = offset_x_overlay_render + win_map_msx_px1 * scale_overlay
                wv_y1_draw = offset_y_overlay_render + win_map_msx_py1 * scale_overlay
                wv_x2_draw = offset_x_overlay_render + win_map_msx_px2 * scale_overlay
                wv_y2_draw = offset_y_overlay_render + win_map_msx_py2 * scale_overlay

                canvas_mm.create_rectangle(
                    wv_x1_draw, wv_y1_draw, wv_x2_draw, wv_y2_draw,
                    outline=self.MINIMAP_WIN_VIEW_COLOR, width=2, dash=(4, 4), tags="minimap_window_view"
                )
            except Exception as e:
                _error(f"Error drawing minimap window view: {e}")
                pass

    def _on_minimap_configure(self, event):
        """Callback when the minimap window is resized/moved."""
        # We only care about size changes for redrawing
        # Basic debouncing: wait a short time after the last configure event
        # before redrawing to avoid excessive calls during drag-resizing.
        debounce_ms = 150  # Adjust as needed (milliseconds)

        # Cancel any pending redraw timer
        if self.minimap_resize_timer is not None:
            self.root.after_cancel(self.minimap_resize_timer)

        # Schedule a new redraw after the debounce period
        self.minimap_resize_timer = self.root.after(
            debounce_ms, self._redraw_minimap_after_resize
        )

    def _redraw_minimap_after_resize(self):
        self.minimap_resize_timer = None 

        if not self.minimap_window or not tk.Toplevel.winfo_exists(self.minimap_window):
            return

        if self._minimap_resizing_internally:
            return

        try:
            current_width_mm_cfg = self.minimap_window.winfo_width()
            current_height_mm_cfg = self.minimap_window.winfo_height()

            # Map aspect ratio based on total MSX pixels
            map_total_msx_pixel_w_cfg = map_width * self.supertile_grid_width * TILE_WIDTH
            map_total_msx_pixel_h_cfg = map_height * self.supertile_grid_height * TILE_HEIGHT

            if map_total_msx_pixel_h_cfg <= 0 or map_total_msx_pixel_w_cfg <= 0 or \
               current_width_mm_cfg <= 1 or current_height_mm_cfg <= 1:
                self.invalidate_minimap_background_cache()
                self.draw_minimap()
                return

            map_aspect_ratio_cfg = map_total_msx_pixel_w_cfg / map_total_msx_pixel_h_cfg
            ideal_height_cfg = int(round(current_width_mm_cfg / map_aspect_ratio_cfg))

            if abs(current_height_mm_cfg - ideal_height_cfg) > 1: # Allow 1px tolerance
                self._minimap_resizing_internally = True
                new_geometry_cfg = f"{current_width_mm_cfg}x{ideal_height_cfg}"
                _debug(f"Minimap Configure: Forcing aspect ratio. New geometry: {new_geometry_cfg}")
                self.minimap_window.geometry(new_geometry_cfg)
                self.root.after(50, setattr, self, "_minimap_resizing_internally", False)
                # Redraw will be triggered by the geometry change causing another <Configure>
                return 
        except Exception as e:
            _error(f"Error during minimap aspect ratio enforcement: {e}")
            self._minimap_resizing_internally = False # Ensure flag is reset

        _debug(f"Minimap Configure: Aspect ratio OK or no change needed. Redrawing.")
        self.invalidate_minimap_background_cache()
        self.draw_minimap()

    def _trigger_minimap_reconfigure(self):
        """Forces the minimap to re-evaluate its size and aspect ratio if it exists."""
        if self.minimap_window and tk.Toplevel.winfo_exists(self.minimap_window):
            # A simple way to trigger <Configure> is to slightly change the size
            # We can just call the resize logic directly though.
            print("Map dimensions changed, triggering minimap aspect check/redraw.")
            # Reset the resize timer to avoid duplicate calls if configure is also pending
            if self.minimap_resize_timer is not None:
                self.root.after_cancel(self.minimap_resize_timer)
                self.minimap_resize_timer = None
            # Directly call the logic that handles resizing and drawing
            self._redraw_minimap_after_resize()

    def invalidate_minimap_background_cache(self):
        """Clears the cached minimap background image."""
        self.minimap_background_cache = None
        # Reset rendered size trackers too
        self.minimap_bg_rendered_width = 0
        self.minimap_bg_rendered_height = 0

    def _create_minimap_background_image(self, target_width_mm, target_height_mm):
        if target_width_mm <= 0 or target_height_mm <= 0:
            return None

        minimap_img_bg = tk.PhotoImage(width=target_width_mm, height=target_height_mm)
        
        map_base_pixel_w = map_width * self.supertile_grid_width * TILE_WIDTH
        map_base_pixel_h = map_height * self.supertile_grid_height * TILE_HEIGHT

        if map_base_pixel_w <= 0 or map_base_pixel_h <= 0:
            _warning("Invalid base map pixel dimensions for minimap background.")
            minimap_img_bg.put("black", to=(0, 0, target_width_mm, target_height_mm))
            self.minimap_bg_rendered_width = target_width_mm
            self.minimap_bg_rendered_height = target_height_mm
            self.minimap_background_cache = minimap_img_bg
            return minimap_img_bg

        scale_x_mm = target_width_mm / map_base_pixel_w
        scale_y_mm = target_height_mm / map_base_pixel_h
        scale_mm = min(scale_x_mm, scale_y_mm)
        
        scaled_map_content_w = map_base_pixel_w * scale_mm
        scaled_map_content_h = map_base_pixel_h * scale_mm
        offset_x_mm_render = (target_width_mm - scaled_map_content_w) / 2
        offset_y_mm_render = (target_height_mm - scaled_map_content_h) / 2
        
        bg_fill_color_mm = "#000000"

        for y_pix_mm in range(target_height_mm):
            row_hex_colors_mm = []
            for x_pix_mm in range(target_width_mm):
                pixel_color_hex_mm = bg_fill_color_mm

                if (offset_x_mm_render <= x_pix_mm < offset_x_mm_render + scaled_map_content_w and
                    offset_y_mm_render <= y_pix_mm < offset_y_mm_render + scaled_map_content_h):

                    map_src_base_x = (x_pix_mm - offset_x_mm_render) / max(1e-9, scale_mm)
                    map_src_base_y = (y_pix_mm - offset_y_mm_render) / max(1e-9, scale_mm)

                    map_src_base_x = max(0, min(map_base_pixel_w - 1, map_src_base_x))
                    map_src_base_y = max(0, min(map_base_pixel_h - 1, map_src_base_y))

                    map_pixel_col_src = int(map_src_base_x)
                    map_pixel_row_src = int(map_src_base_y)

                    pixels_per_st_w = self.supertile_grid_width * TILE_WIDTH
                    pixels_per_st_h = self.supertile_grid_height * TILE_HEIGHT
                    if pixels_per_st_w <=0 : pixels_per_st_w = 1
                    if pixels_per_st_h <=0 : pixels_per_st_h = 1

                    st_col_mm = map_pixel_col_src // pixels_per_st_w
                    st_row_mm = map_pixel_row_src // pixels_per_st_h

                    tile_col_in_st_mm = (map_pixel_col_src % pixels_per_st_w) // TILE_WIDTH
                    tile_row_in_st_mm = (map_pixel_row_src % pixels_per_st_h) // TILE_HEIGHT
                    
                    pixel_col_in_tile_mm = map_pixel_col_src % TILE_WIDTH
                    pixel_row_in_tile_mm = map_pixel_row_src % TILE_HEIGHT
                    
                    try:
                        if 0 <= st_row_mm < map_height and 0 <= st_col_mm < map_width:
                            supertile_idx_mm = map_data[st_row_mm][st_col_mm]
                            if 0 <= supertile_idx_mm < len(supertiles_data):
                                st_def_mm = supertiles_data[supertile_idx_mm]
                                if st_def_mm and len(st_def_mm) == self.supertile_grid_height and \
                                   (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(st_def_mm[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0) and \
                                   0 <= tile_row_in_st_mm < self.supertile_grid_height and \
                                   0 <= tile_col_in_st_mm < self.supertile_grid_width:

                                    tile_idx_mm = st_def_mm[tile_row_in_st_mm][tile_col_in_st_mm]
                                    if 0 <= tile_idx_mm < len(tileset_patterns):
                                        if 0 <= pixel_row_in_tile_mm < TILE_HEIGHT and \
                                           0 <= pixel_col_in_tile_mm < TILE_WIDTH:
                                            pattern_val_mm = tileset_patterns[tile_idx_mm][pixel_row_in_tile_mm][pixel_col_in_tile_mm]
                                            fg_idx_mm, bg_idx_mm = tileset_colors[tile_idx_mm][pixel_row_in_tile_mm]
                                            
                                            if not (0 <= fg_idx_mm < len(self.active_msx_palette) and \
                                                    0 <= bg_idx_mm < len(self.active_msx_palette)):
                                                _warning(f"Invalid palette indices ({fg_idx_mm}, {bg_idx_mm}) in minimap render.")
                                                fg_idx_mm = WHITE_IDX; bg_idx_mm = BLACK_IDX

                                            fg_color_mm = self.active_msx_palette[fg_idx_mm]
                                            bg_color_mm = self.active_msx_palette[bg_idx_mm]
                                            pixel_color_hex_mm = fg_color_mm if pattern_val_mm == 1 else bg_color_mm
                                        else: pixel_color_hex_mm = INVALID_TILE_COLOR
                                    else: pixel_color_hex_mm = INVALID_TILE_COLOR
                                else: pixel_color_hex_mm = INVALID_SUPERTILE_COLOR
                            else: pixel_color_hex_mm = INVALID_SUPERTILE_COLOR
                        else: pixel_color_hex_mm = "#808080"
                    except IndexError:
                        pixel_color_hex_mm = "#FF0000"
                
                row_hex_colors_mm.append(pixel_color_hex_mm)

            try:
                minimap_img_bg.put("{" + " ".join(row_hex_colors_mm) + "}", to=(0, y_pix_mm))
            except tk.TclError as e:
                _warning(f"[Minimap BG]: TclError put row {y_pix_mm}: {e}")
                if row_hex_colors_mm:
                    minimap_img_bg.put(row_hex_colors_mm[0], to=(0, y_pix_mm, target_width_mm, y_pix_mm + 1))

        _debug("Minimap background generated.")
        self.minimap_bg_rendered_width = target_width_mm
        self.minimap_bg_rendered_height = target_height_mm
        self.minimap_background_cache = minimap_img_bg
        return minimap_img_bg

    def _update_window_title(self):
        """Updates the main window title based on the current project path."""
        base_title = "MSX Tile Forge"
        modifier = "*" if self.project_modified else ""

        if self.current_project_base_path:
            # Extract just the filename part
            project_name = os.path.basename(self.current_project_base_path)
            self.root.title(
                f"{base_title} - {project_name}{modifier}"
            )  # Prepend modifier
        else:
            self.root.title(f"{base_title} - Untitled{modifier}")  # Prepend modifier

    def _update_map_cursor(self):
        """Sets the map canvas cursor based on current action and modifier keys."""
        if not hasattr(self, "map_canvas") or not self.map_canvas.winfo_exists():
            return

        new_cursor = ""  # Default arrow cursor

        # Determine cursor based on the active operation FIRST
        if self.current_mouse_action == "panning":
            new_cursor = "fleur"
        elif self.current_mouse_action == "window_dragging":
            new_cursor = "fleur"
        elif self.current_mouse_action == "window_resizing":
            new_cursor = "sizing"  # Generic resize
        elif self.map_selection_active:  # NEW: Selection in progress
            new_cursor = "crosshair"
        # --- Modifier key hints (if NO mouse action is active) ---
        elif self.is_ctrl_pressed:
            try:  # Check location for hinting
                canvas_x = self.map_canvas.canvasx(
                    self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                )
                canvas_y = self.map_canvas.canvasy(
                    self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                )
                handle = (
                    self._get_handle_at(canvas_x, canvas_y)
                    if self.show_window_view.get()
                    else None
                )
                if handle:
                    new_cursor = "sizing"  # Hint resize
                elif (
                    self._is_inside_window_view(canvas_x, canvas_y)
                    and self.show_window_view.get()
                ):
                    new_cursor = "fleur"  # Hint window drag
                else:
                    new_cursor = "hand2"  # Hint panning
            except tk.TclError:
                new_cursor = "hand2"  # Default hint for Ctrl pressed
        elif self.is_shift_pressed:  # NEW: Shift held, no action -> hint selection
            new_cursor = "crosshair"
        # --- Default action (if no action and no relevant modifier) ---
        else:
            new_cursor = "pencil"  # Default paint cursor

        # Only change the cursor if it's different
        try:
            current_cursor = self.map_canvas.cget("cursor")
            if current_cursor != new_cursor:
                self.map_canvas.config(cursor=new_cursor)
        except tk.TclError:
            pass

    def handle_ctrl_press(self, event):
        """Handles Control key press."""
        # Check if the key is actually Control_L or Control_R
        if "Control" in event.keysym:
            # Only update state and cursor if Ctrl wasn't already considered pressed
            if not self.is_ctrl_pressed:
                self.is_ctrl_pressed = True
                # If a tile/supertile drag is active, change the cursor
                if self.drag_active and self.drag_item_type in ["tile", "supertile"]:
                    if self.drag_canvas and self.drag_canvas.winfo_exists():
                        try:
                            self.drag_canvas.config(cursor="exchange")
                        except tk.TclError:
                            pass
                # Otherwise, update the map cursor normally
                elif self.current_mouse_action is None:
                    self._update_map_cursor()

    def handle_ctrl_release(self, event):
        """Handles Control key release. Stops panning if active."""
        # Check if the key is actually Control_L or Control_R
        if "Control" in event.keysym:
            # Only update state if Ctrl was actually considered pressed
            if self.is_ctrl_pressed:
                self.is_ctrl_pressed = False
                
                # If a tile/supertile drag is active, change the cursor back
                if self.drag_active and self.drag_item_type in ["tile", "supertile"]:
                    if self.drag_canvas and self.drag_canvas.winfo_exists():
                        try:
                            self.drag_canvas.config(cursor="target")
                        except tk.TclError:
                            pass
                # Handle map-related actions
                elif self.current_mouse_action == "panning":
                    self.current_mouse_action = None
                
                # Update the map cursor for other cases (e.g., hinting)
                self._update_map_cursor()

    def handle_pan_start(self, event):
        """Handles the start of panning (Ctrl + Left Click) OR window dragging with Ctrl."""
        # --- Check for Shift modifier ---
        if self.is_shift_pressed:
            _debug("Shift pressed, ignoring Ctrl-Button-1 for pan/window drag.")
            return "break"

        ctrl_pressed_at_click = event.state & 0x0004  # Check state at event time
        if not ctrl_pressed_at_click or self.current_mouse_action is not None:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # --- Clear previous selection when starting pan/window drag ---
        self._clear_map_selection()  # Clear selection visual and state

        if (
            self._is_inside_window_view(canvas_x, canvas_y)
            and self.show_window_view.get()
        ):
            self.current_mouse_action = "window_dragging"
            self.drag_start_x = canvas_x
            self.drag_start_y = canvas_y
            self.drag_start_win_tx = self.window_view_tile_x
            self.drag_start_win_ty = self.window_view_tile_y
            self._update_map_cursor()
        else:
            # Initiate PANNING
            self.current_mouse_action = "panning"
            canvas.scan_mark(event.x, event.y)
            self._update_map_cursor()

        return "break"

    def handle_pan_motion(self, event):
        """Handles mouse motion during panning OR window dragging with Ctrl."""
        if self.current_mouse_action not in ["panning", "window_dragging"]:
            return

        canvas = self.map_canvas

        if self.current_mouse_action == "panning":
            canvas.scan_dragto(event.x, event.y, gain=1)
            self.draw_minimap()

        elif self.current_mouse_action == "window_dragging":
            canvas_x = canvas.canvasx(event.x)
            canvas_y = canvas.canvasy(event.y)
            self._do_window_move_drag(canvas_x, canvas_y)

        return "break"

    def handle_canvas_enter(self, event):
        """Handles mouse entering the canvas area."""
        # Set cursor based on current state
        self._update_map_cursor()

        if event.widget == self.map_canvas:
            is_map_tab_active = False
            if self.notebook and self.notebook.winfo_exists():
                try:
                     selected_tab_index = self.notebook.index(self.notebook.select())
                     if selected_tab_index == 3: # Map Editor tab index
                         is_map_tab_active = True
                except tk.TclError:
                    pass # Ignore if notebook not ready

            # Draw preview if map tab active and clipboard has data
            if is_map_tab_active and self.map_clipboard_data:
                self._draw_paste_preview_rect(event=event)

    def handle_canvas_leave(self, event):
        """Handles mouse leaving the canvas area."""
        # Reset cursor to default when leaving, unless an action is in progress
        if self.current_mouse_action is None:
            # Only reset if the specific widget leaving is the map canvas
            if event.widget == self.map_canvas:
                try:
                    if self.map_canvas.winfo_exists():
                        self.map_canvas.config(cursor="")
                except tk.TclError:
                    pass # Ignore if destroyed

        # Reset coordinate display when mouse leaves map canvas
        if event.widget == self.map_canvas and hasattr(self, "map_coords_label"):
            self.map_coords_label.config(text="ST Coords: -, -")

        # Clear paste preview when leaving map canvas
        if event.widget == self.map_canvas:
            self._clear_paste_preview_rect()

    def _update_edit_menu_state(self):
        if not self.edit_menu:
            _debug(" _update_edit_menu_state: self.edit_menu is None. Aborting.")
            return
        if not tk.Menu.winfo_exists(self.edit_menu):
            _debug(" _update_edit_menu_state: self.edit_menu widget no longer exists. Aborting.")
            return

        # Correct indices after adding Undo/Redo
        copy_item_index = 0
        paste_item_index = 1
        undo_item_index = 3
        redo_item_index = 4

        selected_tab_index = 0 
        try:
            if self.notebook and self.notebook.winfo_exists():
                current_selection = self.notebook.select()
                if current_selection:
                    selected_tab_index = self.notebook.index(current_selection)
        except tk.TclError:
            selected_tab_index = 0 

        can_copy = False
        can_paste = False
        copy_label = "Copy"
        paste_label = "Paste"

        if selected_tab_index == 1:
            copy_label = "Copy Tile"
            paste_label = "Paste Tile"
            can_copy = 0 <= current_tile_index < len(tileset_patterns)
            
            can_paste = False
            if 0 <= current_tile_index < len(tileset_patterns):
                try:
                    clipboard_data = json.loads(self.root.clipboard_get())
                    if isinstance(clipboard_data, dict) and \
                       clipboard_data.get("data_type") == "tile" and \
                       clipboard_data.get("app_id") == "MSXTileForge":
                        can_paste = True
                except (tk.TclError, json.JSONDecodeError):
                    pass 

        elif selected_tab_index == 2: 
            copy_label = "Copy Supertile"
            paste_label = "Paste Supertile"
            can_copy = 0 <= current_supertile_index < len(supertiles_data)
            
            can_paste = False
            if 0 <= current_supertile_index < len(supertiles_data):
                try:
                    clipboard_data = json.loads(self.root.clipboard_get())
                    if isinstance(clipboard_data, dict) and \
                       clipboard_data.get("data_type") == "supertile" and \
                       clipboard_data.get("app_id") == "MSXTileForge":
                        can_paste = True
                except (tk.TclError, json.JSONDecodeError):
                    pass 

        elif selected_tab_index == 3: 
            copy_label = "Copy Map Region"
            paste_label = "Paste Map Region"
            can_copy = (
                self.map_selection_start_st is not None
                and self.map_selection_end_st is not None
            )
            can_paste = self.map_clipboard_data is not None

        else: 
            copy_label = "Copy"
            paste_label = "Paste"
            can_copy = False
            can_paste = False

        copy_state = tk.NORMAL if can_copy else tk.DISABLED
        paste_state = tk.NORMAL if can_paste else tk.DISABLED
        undo_state = tk.NORMAL if self.undo_manager.can_undo() else tk.DISABLED
        redo_state = tk.NORMAL if self.undo_manager.can_redo() else tk.DISABLED
        
        undo_label = "Undo"
        if self.undo_manager.can_undo():
            undo_label = f"Undo {self.undo_manager.undo_stack[-1].description}"

        redo_label = "Redo"
        if self.undo_manager.can_redo():
            redo_label = f"Redo {self.undo_manager.redo_stack[-1].description}"

        try:
            self.edit_menu.entryconfig(copy_item_index, state=copy_state, label=copy_label)
            self.edit_menu.entryconfig(paste_item_index, state=paste_state, label=paste_label)
            self.edit_menu.entryconfig(undo_item_index, state=undo_state, label=undo_label)
            self.edit_menu.entryconfig(redo_item_index, state=redo_state, label=redo_label)
        except tk.TclError as e:
            _error(f" _update_edit_menu_state: TclError during entryconfig: {e}")

    def handle_generic_copy(self):
        """Handles the generic 'Copy' menu command based on the active tab."""
        active_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                active_tab_index = self.notebook.index(self.notebook.select())
        except tk.TclError:
            return # Cannot determine active tab

        # Clear map clipboard and preview ONLY if copy action is NOT for map region
        if active_tab_index != 3:
            # Check if map clipboard actually needs clearing before doing work
            if self.map_clipboard_data is not None:
                self.map_clipboard_data = None
                self._clear_paste_preview_rect()
                # Update menu state since map paste is now disabled
                self._update_edit_menu_state() # Update only if clipboard was cleared

        # Perform copy based on active tab
        if active_tab_index == 1:  # Tile Editor Tab
            self.copy_current_tile()
        elif active_tab_index == 2:  # Supertile Editor Tab
            self.copy_current_supertile()
        elif active_tab_index == 3:  # Map Editor Tab
            norm_coords = self._get_normalized_selection_st()
            if norm_coords: # If a selection exists, perform the copy
                min_c, min_r, max_c, max_r = norm_coords
                sel_w = max_c - min_c + 1
                sel_h = max_r - min_r + 1
                copied_data = []
                for r_idx in range(min_r, max_r + 1):
                    row_data = []
                    for c_idx in range(min_c, max_c + 1):
                        if 0 <= r_idx < map_height and 0 <= c_idx < map_width:
                            row_data.append(map_data[r_idx][c_idx])
                        else:
                            row_data.append(0)  # Append default if outside map
                    copied_data.append(row_data)

                # Set the map clipboard
                self.map_clipboard_data = {
                    "width": sel_w,
                    "height": sel_h,
                    "data": copied_data,
                }
                # Clear selection visual/state after successful copy
                self._clear_map_selection()
                # Explicitly clear any old paste preview visual
                self._clear_paste_preview_rect()
                # Redraw map canvas to remove selection rectangle
                self.draw_map_canvas()
                # Update menu state (enables Paste)
                self._update_edit_menu_state()
                # Attempt to draw the *new* paste preview based on current mouse pos
                try:
                    pointer_x = self.map_canvas.winfo_pointerx() - self.map_canvas.winfo_rootx()
                    pointer_y = self.map_canvas.winfo_pointery() - self.map_canvas.winfo_rooty()
                    if (0 <= pointer_x < self.map_canvas.winfo_width() and
                        0 <= pointer_y < self.map_canvas.winfo_height()):
                        canvas_x = self.map_canvas.canvasx(pointer_x)
                        canvas_y = self.map_canvas.canvasy(pointer_y)
                        self._draw_paste_preview_rect(canvas_coords=(canvas_x, canvas_y))
                except Exception:
                     pass # Ignore errors getting pointer position

            # else: # If no selection exists, simply do nothing for the map clipboard
            #    print("Copy Map Region: No selection active.") # Optional info message

    def handle_generic_paste(self):
        """Handles the generic 'Paste' menu command based on the active tab."""
        active_tab_index = -1
        try:
            if self.notebook and self.notebook.winfo_exists():
                active_tab_index = self.notebook.index(self.notebook.select())
        except tk.TclError:
            return 

        # 1. Check if marks were present BEFORE any action is taken.
        marks_were_cleared = self._clear_marked_unused(trigger_redraw=False)
        # 2. Get the length of the undo stack BEFORE the action.
        undo_stack_size_before = len(self.undo_manager.undo_stack)

        if active_tab_index == 1:
            self.paste_tile() 
        elif active_tab_index == 2:
            self.paste_supertile() 
        elif active_tab_index == 3:
            self.paste_map()
        
        # 3. Get the length of the undo stack AFTER the action.
        undo_stack_size_after = len(self.undo_manager.undo_stack)
        action_was_performed = (undo_stack_size_after > undo_stack_size_before)

        # 4. If marks were cleared BUT no new undoable action was actually performed,
        #    we must manually trigger a redraw to clear the old highlights from the screen.
        if marks_were_cleared and not action_was_performed:
            _debug("handle_generic_paste: Marks were cleared but no data was modified. Forcing a redraw.")
            self.update_all_displays(changed_level="all")

    def _setup_global_key_bindings(self):
        # Sets up global keyboard shortcuts (accelerators) for menu commands.
        # The lambda functions are required to absorb the 'event' object passed by the binding.
        self.root.bind_all("<Control-n>", lambda event: self._handle_new_project_action())
        self.root.bind_all("<Control-o>", lambda event: self._handle_open_project_action())
        self.root.bind_all("<Control-s>", lambda event: self.save_project())
        self.root.bind_all(
            "<Control-Shift-KeyPress-S>", lambda event: self.save_project_as()
        )
        self.root.bind_all("<Control-q>", lambda event: self.confirm_quit())
        self.root.bind_all("<Control-c>", lambda event: self.handle_generic_copy())
        self.root.bind_all("<Control-v>", lambda event: self.handle_generic_paste())
        self.root.bind_all("<Control-z>", lambda event: self.undo_manager.undo())
        self.root.bind_all("<Control-y>", lambda event: self.undo_manager.redo())
        self.root.bind_all("<Control-m>", lambda event: self.toggle_minimap())

        self.root.bind_all("<F1>", lambda event: self.toggle_color_usage_window())
        self.root.bind_all("<F2>", lambda event: self.toggle_tile_usage_window())
        self.root.bind_all("<F3>", lambda event: self.toggle_supertile_usage_window())
        
        # Bind Ctrl+R and Alt+R to post the recent menus at the cursor
        self.root.bind_all("<Control-r>", lambda event: self._post_menu_at_cursor(event, self.recent_projects_menu))
        self.root.bind_all("<Alt-r>", lambda event: self._post_menu_at_cursor(event, self.recent_modules_menu))

        # Bind Ctrl+Number and Alt+Number for recent files using the correct event names.
        for i in range(1, 10): # For keys 1 through 9
            # Use "<Control-Key-i>" and "<Alt-Key-i>"
            self.root.bind_all(f"<Control-Key-{i}>", lambda event, index=i-1: self._open_recent_by_index('projects', index))
            self.root.bind_all(f"<Alt-Key-{i}>", lambda event, index=i-1: self._open_recent_by_index('modules', index))
        
        # Bind key 0 to the 10th item (index 9)
        self.root.bind_all("<Control-Key-0>", lambda event: self._open_recent_by_index('projects', 9))
        self.root.bind_all("<Alt-Key-0>", lambda event: self._open_recent_by_index('modules', 9))

        self.root.bind("<FocusIn>", self._on_window_focus_in)

        _debug(" Global key bindings set up.")

    def handle_map_tab_keypress(self, event):
        """Handles key presses specifically bound when the Map Tab is active."""
        key = event.keysym.lower()

        if key == "g":  # MODIFIED CHECK
            # Only cycle color if the key is 'g' (this handler is only active on map tab)
            self.cycle_grid_color()
            return "break"  # Prevent any other default actions for 'g'

    def _place_tile_in_supertile(self, r_place, c_place):
        global supertiles_data, current_supertile_index, selected_tile_for_supertile
        
        if not (0 <= current_supertile_index < len(supertiles_data)):
            return False
        if not (0 <= selected_tile_for_supertile < len(tileset_patterns)):
            return False
        
        if not (0 <= r_place < self.supertile_grid_height and 0 <= c_place < self.supertile_grid_width):
            return False

        current_definition_place = supertiles_data[current_supertile_index]
        if not current_definition_place or len(current_definition_place) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and (len(current_definition_place[0]) != self.supertile_grid_width)):
            _warning(f"Supertile {current_supertile_index} dim mismatch in _place_tile_in_supertile.")
            return False

        if current_definition_place[r_place][c_place] != selected_tile_for_supertile:
            if self._clear_marked_unused(trigger_redraw=False):
                self.update_all_displays(changed_level="all")

            command = PlaceTileInSupertileCommand(self, current_supertile_index, r_place, c_place, selected_tile_for_supertile)
            command.execute() # Apply change immediately for visual feedback
            self.pending_command_list.append(command)
            
            if not (self.marked_unused_tiles or self.marked_unused_supertiles):
                self.update_all_displays(changed_level="supertile")
            else:
                self.update_all_displays(changed_level="all")
            self._mark_project_modified()

            self._update_st_tab_selected_tile_info_panel()
            return True
        else:
            return False

    def handle_supertile_def_drag(self, event):
        if self.last_placed_supertile_cell is None:
            return

        if not (0 <= selected_tile_for_supertile < len(tileset_patterns)):
            return

        canvas = self.supertile_def_canvas
        mini_tile_dsize = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_dsize <= 0 or not canvas.winfo_exists():
            return

        col_drag = event.x // mini_tile_dsize
        row_drag = event.y // mini_tile_dsize

        current_cell_drag = (row_drag, col_drag)

        if (0 <= row_drag < self.supertile_grid_height and \
            0 <= col_drag < self.supertile_grid_width and \
            current_cell_drag != self.last_placed_supertile_cell):

            if self._place_tile_in_supertile(row_drag, col_drag):
                self.last_placed_supertile_cell = current_cell_drag

    def handle_supertile_def_release(self, event):
        """Finalizes a paint stroke in the supertile editor, creating a single undo command."""
        if self.pending_command_list:
            composite = CompositeCommand("Place Tiles", self.pending_command_list[:], self)
            self.undo_manager.register(composite)
            self.pending_command_list.clear()

        if self.last_placed_supertile_cell is not None:
            _debug("Supertile paint finished, requesting final usage window refresh.")
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

        self.last_placed_supertile_cell = None

    def _update_map_coords_display(self, event):
        """Updates the coordinate label based on mouse motion over the map canvas."""
        if not hasattr(self, "map_canvas") or not self.map_canvas.winfo_exists():
            return

        canvas = self.map_canvas
        try:
            canvas_x = canvas.canvasx(event.x)
            canvas_y = canvas.canvasy(event.y)

            # Calculate supertile size at current zoom USING PROJECT DIMENSIONS
            zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims() # <--- USE THIS

            if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0: # Check both
                if hasattr(self, "map_coords_label"):
                    self.map_coords_label.config(text="ST Coords: Error")
                return

            # Calculate supertile row/col
            st_col = int(canvas_x // zoomed_st_pixel_w) # Use width for col
            st_row = int(canvas_y // zoomed_st_pixel_h) # Use height for row

            if 0 <= st_row < map_height and 0 <= st_col < map_width:
                coords_text = f"ST Coords: {st_col}, {st_row}"
            else:
                coords_text = "ST Coords: Out"

            if hasattr(self, "map_coords_label"):
                self.map_coords_label.config(text=coords_text)

        except Exception as e:
            if hasattr(self, "map_coords_label"):
                self.map_coords_label.config(text="ST Coords: Error")

    def _mark_project_modified(self):
        """Sets the project modified flag to True and updates the window title if needed."""
        if not self.project_modified:
            self.project_modified = True
            self._update_window_title()  # Update title when first marked as modified

    def flip_supertile_horizontal(self):
        global supertiles_data, current_supertile_index
        if not (0 <= current_supertile_index < len(supertiles_data)):
            messagebox.showwarning("Flip Supertile", "No valid supertile selected.", parent=self.root)
            return
        current_definition = supertiles_data[current_supertile_index]
        if not (current_definition and 
                len(current_definition) == self.supertile_grid_height and
                (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(current_definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
            _warning(f"Supertile {current_supertile_index} dimensions mismatch for horizontal flip. Cannot flip.")
            messagebox.showerror("Flip Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot flip.", parent=self.root)
            return

        command = TransformCommand("Flip Supertile Horizontal", self, supertiles_data, current_supertile_index, self.invalidate_supertile_cache)

        new_definition_flipped_h_st = []
        for r_flip_st_h in range(self.supertile_grid_height):
            if r_flip_st_h < len(current_definition) and isinstance(current_definition[r_flip_st_h], list):
                 new_definition_flipped_h_st.append(current_definition[r_flip_st_h][::-1]) 
            else: 
                 new_definition_flipped_h_st.append([0] * self.supertile_grid_width)
        supertiles_data[current_supertile_index] = new_definition_flipped_h_st

        command.capture_new_state()
        self.undo_manager.execute(command)
        
        _debug(f"Supertile {current_supertile_index} flipped horizontally.")

    def flip_supertile_vertical(self):
        global supertiles_data, current_supertile_index
        if not (0 <= current_supertile_index < len(supertiles_data)):
            messagebox.showwarning("Flip Supertile", "No valid supertile selected.", parent=self.root)
            return
        current_definition_to_flip_st = supertiles_data[current_supertile_index]
        if not (current_definition_to_flip_st and 
                len(current_definition_to_flip_st) == self.supertile_grid_height and
                (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(current_definition_to_flip_st[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
            _warning(f"Supertile {current_supertile_index} dimensions mismatch for vertical flip. Cannot flip.")
            messagebox.showerror("Flip Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot flip.", parent=self.root)
            return
            
        command = TransformCommand("Flip Supertile Vertical", self, supertiles_data, current_supertile_index, self.invalidate_supertile_cache)
        
        current_definition_to_flip_st.reverse()

        command.capture_new_state()
        self.undo_manager.execute(command)
        
        _debug(f"Supertile {current_supertile_index} flipped vertically.")

    def rotate_supertile_90cw(self):
        global supertiles_data, current_supertile_index
        if not (0 <= current_supertile_index < len(supertiles_data)):
            messagebox.showwarning("Rotate Supertile", "No valid supertile selected.", parent=self.root)
            return
        if self.supertile_grid_width != self.supertile_grid_height:
            messagebox.showinfo("Rotate Supertile", "Rotation is only enabled for square supertiles.", parent=self.root)
            return

        current_definition_rotate_st = supertiles_data[current_supertile_index]
        dim_st_rotate = self.supertile_grid_width
        if not (current_definition_rotate_st and 
                len(current_definition_rotate_st) == dim_st_rotate and
                (dim_st_rotate == 0 or all(len(row) == dim_st_rotate for row in current_definition_rotate_st))):
            _warning(f"Supertile {current_supertile_index} dimensions mismatch for rotation. Cannot rotate.")
            messagebox.showerror("Rotate Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot rotate.", parent=self.root)
            return

        command = TransformCommand("Rotate Supertile", self, supertiles_data, current_supertile_index, self.invalidate_supertile_cache)

        new_definition_rotated_st = [[0 for _c in range(dim_st_rotate)] for _r in range(dim_st_rotate)]
        for r_rot_st_val in range(dim_st_rotate):
            for c_rot_st_val in range(dim_st_rotate):
                if r_rot_st_val < len(current_definition_rotate_st) and c_rot_st_val < len(current_definition_rotate_st[r_rot_st_val]):
                    new_definition_rotated_st[c_rot_st_val][(dim_st_rotate - 1) - r_rot_st_val] = current_definition_rotate_st[r_rot_st_val][c_rot_st_val]
        supertiles_data[current_supertile_index] = new_definition_rotated_st

        command.capture_new_state()
        self.undo_manager.execute(command)
        
        _debug(f"Supertile {current_supertile_index} rotated 90 CW.")

    def shift_supertile_up(self):
        global supertiles_data, current_supertile_index
        current_st_h_for_shift = self.supertile_grid_height
        if not (0 <= current_supertile_index < len(supertiles_data)) or current_st_h_for_shift <= 0:
            if current_st_h_for_shift <=1 and 0 <= current_supertile_index < len(supertiles_data) :
                 _debug(f"Supertile {current_supertile_index} is {current_st_h_for_shift} unit(s) high, cannot shift up.")
                 return
            messagebox.showwarning("Shift Supertile", "Invalid supertile or dimensions for shift operation.", parent=self.root)
            return
        current_definition_shift_st_up = supertiles_data[current_supertile_index]
        if not (current_definition_shift_st_up and 
                len(current_definition_shift_st_up) == current_st_h_for_shift and
                (current_st_h_for_shift == 0 or (self.supertile_grid_width > 0 and len(current_definition_shift_st_up[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
            _warning(f"Supertile {current_supertile_index} dimensions mismatch for shift up. Cannot shift.")
            messagebox.showerror("Shift Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return
            
        command = TransformCommand("Shift Supertile Up", self, supertiles_data, current_supertile_index, self.invalidate_supertile_cache)

        first_row_data_st = current_definition_shift_st_up.pop(0)
        current_definition_shift_st_up.append(first_row_data_st)
        
        command.capture_new_state()
        self.undo_manager.execute(command)
        
        _debug(f"Supertile {current_supertile_index} shifted up.")

    def shift_supertile_down(self):
        global supertiles_data, current_supertile_index
        current_st_h_for_shift_d = self.supertile_grid_height
        if not (0 <= current_supertile_index < len(supertiles_data)) or current_st_h_for_shift_d <= 0:
            if current_st_h_for_shift_d <=1 and 0 <= current_supertile_index < len(supertiles_data):
                _debug(f"Supertile {current_supertile_index} is {current_st_h_for_shift_d} unit(s) high, cannot shift down.")
                return
            messagebox.showwarning("Shift Supertile", "Invalid supertile or dimensions for shift operation.", parent=self.root)
            return
        current_definition_shift_st_d = supertiles_data[current_supertile_index]
        if not (current_definition_shift_st_d and 
                len(current_definition_shift_st_d) == current_st_h_for_shift_d and
                (current_st_h_for_shift_d == 0 or (self.supertile_grid_width > 0 and len(current_definition_shift_st_d[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
            _warning(f"Supertile {current_supertile_index} dimensions mismatch for shift down. Cannot shift.")
            messagebox.showerror("Shift Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return
            
        command = TransformCommand("Shift Supertile Down", self, supertiles_data, current_supertile_index, self.invalidate_supertile_cache)

        last_row_data_st = current_definition_shift_st_d.pop(-1)
        current_definition_shift_st_d.insert(0, last_row_data_st)

        command.capture_new_state()
        self.undo_manager.execute(command)
        
        _debug(f"Supertile {current_supertile_index} shifted down.")

    def shift_supertile_left(self):
        global supertiles_data, current_supertile_index
        current_st_w_for_shift_l = self.supertile_grid_width
        current_st_h_for_shift_l = self.supertile_grid_height
        if not (0 <= current_supertile_index < len(supertiles_data)) or current_st_w_for_shift_l <= 0 or current_st_h_for_shift_l <= 0:
            if current_st_w_for_shift_l <=1 and 0 <= current_supertile_index < len(supertiles_data) :
                 _debug(f"Supertile {current_supertile_index} is {current_st_w_for_shift_l} unit(s) wide, cannot shift left.")
                 return
            messagebox.showwarning("Shift Supertile", "Invalid supertile or dimensions for shift operation.", parent=self.root)
            return
        current_definition_shift_st_l = supertiles_data[current_supertile_index]
        if not (current_definition_shift_st_l and 
                len(current_definition_shift_st_l) == current_st_h_for_shift_l and
                (current_st_h_for_shift_l == 0 or (current_st_w_for_shift_l > 0 and len(current_definition_shift_st_l[0]) == current_st_w_for_shift_l) or current_st_w_for_shift_l == 0)):
            _warning(f"Supertile {current_supertile_index} dimensions mismatch for shift left. Cannot shift.")
            messagebox.showerror("Shift Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return

        command = TransformCommand("Shift Supertile Left", self, supertiles_data, current_supertile_index, self.invalidate_supertile_cache)

        for r_shift_st_l_val in range(current_st_h_for_shift_l):
            if r_shift_st_l_val < len(current_definition_shift_st_l):
                row_data_list_st_l = current_definition_shift_st_l[r_shift_st_l_val]
                if len(row_data_list_st_l) == current_st_w_for_shift_l and current_st_w_for_shift_l > 0:
                    first_tile_in_row_st = row_data_list_st_l.pop(0)
                    row_data_list_st_l.append(first_tile_in_row_st)

        command.capture_new_state()
        self.undo_manager.execute(command)
        
        _debug(f"Supertile {current_supertile_index} shifted left.")

    def shift_supertile_right(self):
        global supertiles_data, current_supertile_index
        current_st_w_for_shift_r = self.supertile_grid_width
        current_st_h_for_shift_r = self.supertile_grid_height
        if not (0 <= current_supertile_index < len(supertiles_data)) or current_st_w_for_shift_r <= 0 or current_st_h_for_shift_r <= 0:
            if current_st_w_for_shift_r <= 1 and 0 <= current_supertile_index < len(supertiles_data) :
                 _debug(f"Supertile {current_supertile_index} is {current_st_w_for_shift_r} unit(s) wide, cannot shift right.")
                 return
            messagebox.showwarning("Shift Supertile", "Invalid supertile or dimensions for shift operation.", parent=self.root)
            return
        current_definition_shift_st_r = supertiles_data[current_supertile_index]
        if not (current_definition_shift_st_r and 
                len(current_definition_shift_st_r) == current_st_h_for_shift_r and
                (current_st_h_for_shift_r == 0 or (current_st_w_for_shift_r > 0 and len(current_definition_shift_st_r[0]) == current_st_w_for_shift_r) or current_st_w_for_shift_r == 0)):
            _warning(f"Supertile {current_supertile_index} dimensions mismatch for shift right. Cannot shift.")
            messagebox.showerror("Shift Error", f"Supertile {current_supertile_index} data is inconsistent. Cannot shift.", parent=self.root)
            return

        command = TransformCommand("Shift Supertile Right", self, supertiles_data, current_supertile_index, self.invalidate_supertile_cache)

        for r_shift_st_r_val in range(current_st_h_for_shift_r):
            if r_shift_st_r_val < len(current_definition_shift_st_r):
                row_data_list_st_r = current_definition_shift_st_r[r_shift_st_r_val]
                if len(row_data_list_st_r) == current_st_w_for_shift_r and current_st_w_for_shift_r > 0:
                    last_tile_in_row_st = row_data_list_st_r.pop(-1)
                    row_data_list_st_r.insert(0, last_tile_in_row_st)
        
        command.capture_new_state()
        self.undo_manager.execute(command)
        
        _debug(f"Supertile {current_supertile_index} shifted right.")

    def handle_supertile_def_right_click(self, event):
        global selected_tile_for_supertile, current_supertile_index, supertiles_data

        canvas = self.supertile_def_canvas
        # SUPERTILE_DEF_TILE_SIZE is display size of one mini-tile in editor
        mini_tile_disp_size = SUPERTILE_DEF_TILE_SIZE 
        if mini_tile_disp_size <= 0 or not canvas.winfo_exists():
            return

        col = event.x // mini_tile_disp_size
        row = event.y // mini_tile_disp_size

        # Check click against current project's supertile dimensions
        if (
            0 <= row < self.supertile_grid_height
            and 0 <= col < self.supertile_grid_width
            and 0 <= current_supertile_index < len(supertiles_data)
        ):
            try:
                # Ensure definition structure matches before accessing
                definition_rc = supertiles_data[current_supertile_index]
                if not definition_rc or len(definition_rc) != self.supertile_grid_height or \
                   (self.supertile_grid_height > 0 and (len(definition_rc[0]) != self.supertile_grid_width)):
                    _warning(f"ST def {current_supertile_index} dim mismatch in right_click.")
                    return

                clicked_tile_index_val = definition_rc[row][col]

                if 0 <= clicked_tile_index_val < len(tileset_patterns):
                    if selected_tile_for_supertile != clicked_tile_index_val:
                        selected_tile_for_supertile = clicked_tile_index_val
                        _debug(f"Right-click selected Tile: {selected_tile_for_supertile}")
                        self.draw_tileset_viewer(
                            self.st_tileset_canvas, selected_tile_for_supertile
                        )
                        self._update_st_tab_selected_tile_info_panel()
                        self.scroll_viewers_to_tile(selected_tile_for_supertile)
                # else:
                    _debug(f"Right-click: Tile index {clicked_tile_index_val} at ST def [{row},{col}] is out of tile bounds (max {len(tileset_patterns)-1}).")

            except IndexError: # Should be caught by structure check above
                _error(f"Right-click: IndexError accessing supertile data for ST {current_supertile_index} at def [{row},{col}].")
                pass
            except Exception as e:
                _error(f"Right-click: Unexpected error in supertile def handler: {e}")
                pass
        # else: Click was outside the definition grid based on current W/H dimensions

    def handle_map_canvas_right_click(self, event):
        """Handles right-click on the map canvas to select the clicked supertile."""
        global selected_supertile_for_map, map_data, map_width, map_height

        # Prevent interference with panning or other actions
        if self.current_mouse_action is not None:
            return "break"  # Stop event propagation if another action is active

        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return

        zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims()

        if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0:
            return

        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        # Calculate map column and row using correct dimensions
        map_col = int(canvas_x // zoomed_st_pixel_w)
        map_row = int(canvas_y // zoomed_st_pixel_h)

        # Check if the click is within the map bounds
        if 0 <= map_row < map_height and 0 <= map_col < map_width:
            try:
                # Get the supertile index at the clicked map cell
                clicked_supertile_index = map_data[map_row][map_col]

                # Check if the retrieved supertile index is valid
                if 0 <= clicked_supertile_index < len(supertiles_data):
                    # Check if the selection actually changed
                    if selected_supertile_for_map != clicked_supertile_index:
                        selected_supertile_for_map = clicked_supertile_index
                        print(
                            f"Right-click selected Supertile: {selected_supertile_for_map}"
                        )
                        # Redraw the supertile selector in the map tab
                        self.draw_supertile_selector(
                            self.map_supertile_selector_canvas,
                            selected_supertile_for_map,
                        )
                        # Update the info label
                        self.update_map_info_labels()
                        # Scroll the selector to the selected supertile
                        self.scroll_selectors_to_supertile(selected_supertile_for_map)
                else:
                    print(
                        f"Right-click: Supertile index {clicked_supertile_index} at map [{map_row},{map_col}] is out of bounds (max {len(supertiles_data)-1})."
                    )

            except IndexError:
                _error(f"Right-click: Error accessing map data at [{map_row},{map_col}].")
            except Exception as e:
                _error(f"Right-click: Unexpected error in map canvas handler: {e}")

    def _check_tile_usage(self, tile_index_check): # Renamed tile_index
        used_in_supertiles_list = [] # Renamed
        if not (0 <= tile_index_check < len(tileset_patterns)):
            return used_in_supertiles_list

        for st_idx_check in range(len(supertiles_data)):
            definition_check = supertiles_data[st_idx_check] # global
            
            # Check consistency of this definition with project settings
            if not definition_check or len(definition_check) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(definition_check[0]) != self.supertile_grid_width)):
                _warning(f"Supertile {st_idx_check} has inconsistent dimensions in _check_tile_usage. Skipping.")
                continue # Skip this malformed supertile definition

            found_in_current_st = False
            for r_check in range(self.supertile_grid_height):
                for c_check in range(self.supertile_grid_width):
                    # Bounds check for r_check, c_check within definition_check already done by loops
                    # and the initial structure check.
                    if definition_check[r_check][c_check] == tile_index_check:
                        if st_idx_check not in used_in_supertiles_list:
                            used_in_supertiles_list.append(st_idx_check)
                        found_in_current_st = True
                        break 
                if found_in_current_st:
                    break 
        return used_in_supertiles_list

    def _check_supertile_usage(self, supertile_index):
        """Checks if a supertile_index is used in the map data.
        Returns a list of (row, col) map coordinates that use it.
        """
        used_in_map = []
        if not (0 <= supertile_index < len(supertiles_data)):
            return used_in_map  # Invalid index

        for r in range(map_height):
            for c in range(map_width):
                if map_data[r][c] == supertile_index:
                    used_in_map.append((r, c))
        return used_in_map

    def _update_supertile_refs_for_tile_change(self, tile_idx_changed, action_type): # Renamed index, action
        references_changed = False # Flag to track if any ST def was actually modified
        for st_idx_update in range(len(supertiles_data)):
            current_definition_update = supertiles_data[st_idx_update] 

            if not current_definition_update or len(current_definition_update) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and (len(current_definition_update[0]) != self.supertile_grid_width)):
                _warning(f"Supertile {st_idx_update} has inconsistent dimensions in _update_supertile_refs. Skipping.")
                continue

            for r_update in range(self.supertile_grid_height):
                for c_update in range(self.supertile_grid_width):
                    current_tile_ref = current_definition_update[r_update][c_update]
                    original_ref_for_comparison = current_tile_ref # Store before modification
                    
                    if action_type == "insert":
                        if current_tile_ref >= tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] += 1
                    elif action_type == "delete":
                        if current_tile_ref == tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] = 0 
                        elif current_tile_ref > tile_idx_changed:
                            supertiles_data[st_idx_update][r_update][c_update] -= 1
                    
                    if supertiles_data[st_idx_update][r_update][c_update] != original_ref_for_comparison:
                        references_changed = True
                        self.invalidate_supertile_cache(st_idx_update)

        if references_changed:
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

    def _update_map_refs_for_supertile_change(self, index, action):
        map_changed_by_refs = False 
        if action == "insert":
            for r in range(map_height):
                for c in range(map_width):
                    if map_data[r][c] >= index:
                        # Ensure incremented index does not exceed MAX_SUPERTILES - 1
                        if map_data[r][c] < MAX_SUPERTILES - 1:
                            map_data[r][c] += 1
                            map_changed_by_refs = True
                        elif map_data[r][c] == MAX_SUPERTILES -1 and index <= MAX_SUPERTILES -1 :
                             # If current ref is already at max, and we insert before/at it,
                             # it effectively gets pushed "out of bounds" conceptually.
                             # For safety, could map to a default like 0, or log.
                             # Current logic: it would remain MAX_SUPERTILES-1 if index makes it shift.
                             # If index makes map_data[r][c] need to be > MAX_SUPERTILES-1, it's an issue.
                             # Let's assume for now that len(supertiles_data) management prevents this.
                             # A safer increment:
                             # original_val = map_data[r][c]
                             # map_data[r][c] = min(MAX_SUPERTILES - 1, original_val + 1)
                             # if map_data[r][c] != original_val: map_changed_by_refs = True
                             pass # Current logic might be okay if MAX_SUPERTILES is large

        elif action == "delete":
            for r in range(map_height):
                for c in range(map_width):
                    if map_data[r][c] == index:
                        map_data[r][c] = 0
                        map_changed_by_refs = True
                    elif map_data[r][c] > index:
                        map_data[r][c] -= 1
                        map_changed_by_refs = True # Also a change
        else:
            _warning(f"Unknown action '{action}' in _update_map_refs_for_supertile_change")

        if map_changed_by_refs:
            self._mark_project_modified() # If map data changed, project is modified
            self.invalidate_minimap_background_cache() # Minimap needs update
            # The map canvas itself will be redrawn by the caller of insert/delete ST usually.
            self._request_supertile_usage_refresh()

    def _insert_tile(self, index):
        global tileset_patterns, tileset_colors, WHITE_IDX, BLACK_IDX

        if not (
            0 <= index <= len(tileset_patterns)
        ):  
            _error(f"Insert tile index {index} out of range [0, {len(tileset_patterns)}].")
            return False
        if len(tileset_patterns) >= MAX_TILES:
            _error("Cannot insert tile, maximum tiles reached.")
            return False

        blank_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        blank_colors = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]

        tileset_patterns.insert(index, blank_pattern)
        tileset_colors.insert(index, blank_colors)
        
        if len(tileset_patterns) > MAX_TILES:
            tileset_patterns.pop()
        if len(tileset_colors) > MAX_TILES:
            tileset_colors.pop()

        self._update_supertile_refs_for_tile_change(index, "insert") # calls _request_tile_usage_refresh

        self._mark_project_modified()
        return True

    def _delete_tile(self, index):
        global tileset_patterns, tileset_colors

        if not (0 <= index < len(tileset_patterns)):
            _error(f"Delete tile index {index} out of range [0, {len(tileset_patterns) - 1}]."
            )
            return False
        if len(tileset_patterns) <= 1:
            _error("Cannot delete the last tile.")
            return False

        del tileset_patterns[index]
        del tileset_colors[index]

        self._update_supertile_refs_for_tile_change(index, "delete") # calls _request_tile_usage_refresh

        self._mark_project_modified()
        return True

    def _insert_supertile(self, index_to_insert_at): 
        global supertiles_data 

        if not (0 <= index_to_insert_at <= len(supertiles_data)):
            _error(f"Insert supertile index {index_to_insert_at} out of range [0, {len(supertiles_data)}].")
            return False
        if len(supertiles_data) >= MAX_SUPERTILES:
            _error("Cannot insert supertile, maximum reached.")
            return False

        blank_st_definition = [
            [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
        ]

        supertiles_data.insert(index_to_insert_at, blank_st_definition) 
        
        if len(supertiles_data) > MAX_SUPERTILES:
            supertiles_data.pop() 

        self._update_map_refs_for_supertile_change(index_to_insert_at, "insert")
        self._mark_project_modified()
        self._request_tile_usage_refresh()

        return True

    def _delete_supertile(self, index):
        """Core logic to delete the supertile at the specified index.

        Args:
            index (int): The index of the supertile to delete.

        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        global supertiles_data

        if not (0 <= index < len(supertiles_data)):
            _error(f"Delete supertile index {index} out of range [0, {len(supertiles_data) - 1}].")
            return False
        if len(supertiles_data) <= 1:
            _error("Cannot delete the last supertile.")
            return False

        # --- Confirmation is handled by the UI caller ---

        # Delete from data list
        del supertiles_data[index]
        # Let list shrink

        # Update references in map
        self._update_map_refs_for_supertile_change(index, "delete")

        self._mark_project_modified()
        return True

    def _update_editor_button_states(self):
        # --- Tile Editor Buttons ---
        can_add_tile = len(tileset_patterns) < self.project_tile_limit
        can_insert_tile = len(tileset_patterns) < self.project_tile_limit
        can_delete_tile = len(tileset_patterns) > 1

        if hasattr(self, "add_tile_button") and self.add_tile_button.winfo_exists():
            self.add_tile_button.config(
                state=tk.NORMAL if can_add_tile else tk.DISABLED
            )
        if hasattr(self, "add_many_tiles_button") and self.add_many_tiles_button.winfo_exists():
            self.add_many_tiles_button.config(
                state=tk.NORMAL if can_add_tile else tk.DISABLED # Same condition as "Add New"
            )
        if hasattr(self, "insert_tile_button") and self.insert_tile_button.winfo_exists():
            self.insert_tile_button.config(
                state=tk.NORMAL if can_insert_tile else tk.DISABLED
            )
        if hasattr(self, "delete_tile_button") and self.delete_tile_button.winfo_exists():
            self.delete_tile_button.config(
                state=tk.NORMAL if can_delete_tile else tk.DISABLED
            )

        can_add_supertile = len(supertiles_data) < self.project_supertile_limit
        can_insert_supertile = len(supertiles_data) < self.project_supertile_limit
        can_delete_supertile = len(supertiles_data) > 1

        if hasattr(self, "add_supertile_button") and self.add_supertile_button.winfo_exists():
            self.add_supertile_button.config(
                state=tk.NORMAL if can_add_supertile else tk.DISABLED
            )
        if hasattr(self, "add_many_supertiles_button") and self.add_many_supertiles_button.winfo_exists():
            self.add_many_supertiles_button.config(
                state=tk.NORMAL if can_add_supertile else tk.DISABLED # Same condition as "Add New"
            )
        if hasattr(self, "insert_supertile_button") and self.insert_supertile_button.winfo_exists():
            self.insert_supertile_button.config(
                state=tk.NORMAL if can_insert_supertile else tk.DISABLED
            )
        if hasattr(self, "delete_supertile_button") and self.delete_supertile_button.winfo_exists():
            self.delete_supertile_button.config(
                state=tk.NORMAL if can_delete_supertile else tk.DISABLED
            )

    def handle_add_tile(self):  
        global current_tile_index

        if len(tileset_patterns) >= self.project_tile_limit:
            messagebox.showwarning("Add Tile Failed", f"Could not add tile. The tileset limit is set to {self.project_tile_limit}.")
            return
    
        if self._clear_marked_unused(trigger_redraw=False):
            pass

        new_tile_idx = len(tileset_patterns)
        blank_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        blank_colors = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]

        pattern_command = ModifyListCommand("Add Tile", tileset_patterns, new_tile_idx, blank_pattern, is_insert=True)
        color_command = ModifyListCommand("Add Tile", tileset_colors, new_tile_idx, blank_colors, is_insert=True)
        
        # Command to update application state (counts and selections)
        old_state = (current_tile_index,)
        new_state = (new_tile_idx,)

        def state_setter(state_tuple):
            global current_tile_index
            current_tile_index = state_tuple[0]
        
        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)

        # Define post-action hooks for UI updates
        def post_add_hooks():
            self._mark_project_modified()
            self.clear_all_caches()  
            self.invalidate_minimap_background_cache()
            self._update_editor_button_states()  
            self._request_color_usage_refresh()
            self.scroll_viewers_to_tile(current_tile_index)

        composite = CompositeCommand(
            "Add Tile", 
            [pattern_command, color_command, state_command],
            app_ref=self,
            post_hooks=[post_add_hooks]
    )
        self.undo_manager.execute(composite)
        
        _debug(f"Added new tile {new_tile_idx}")

    def handle_insert_tile(self):
        global current_tile_index, selected_tile_for_supertile
        if len(tileset_patterns) >= self.project_tile_limit:
            messagebox.showwarning("Insert Tile Failed", f"Could not insert tile. The tileset limit is set to {self.project_tile_limit}.")
            return
        if self._clear_marked_unused(trigger_redraw=False): pass 

        insert_idx = current_tile_index
        
        blank_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
        blank_colors = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]
        pattern_command = ModifyListCommand("Insert Tile", tileset_patterns, insert_idx, blank_pattern, is_insert=True)
        color_command = ModifyListCommand("Insert Tile", tileset_colors, insert_idx, blank_colors, is_insert=True)
        
        st_refs_command = UpdateSupertileRefsForTileCommand("Update Supertile Refs", self, insert_idx, is_insert=True)

        old_state = (current_tile_index, selected_tile_for_supertile)
        new_num_tiles = len(tileset_patterns) + 1 # This is still needed to calculate the clamped new_st_selection
        new_selection = insert_idx
        new_st_selection = selected_tile_for_supertile + 1 if selected_tile_for_supertile >= insert_idx else selected_tile_for_supertile
        new_st_selection = min(new_st_selection, new_num_tiles - 1)
        new_state = (new_selection, new_st_selection)
        def state_setter(state_tuple):
            global current_tile_index, selected_tile_for_supertile
            current_tile_index, selected_tile_for_supertile = state_tuple
        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)

        def post_insert_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self._update_editor_button_states()
            self._request_color_usage_refresh()
            self.scroll_viewers_to_tile(current_tile_index)

        composite = CompositeCommand("Insert Tile", [pattern_command, color_command, st_refs_command, state_command], app_ref=self, post_hooks=[post_insert_hooks])
        self.undo_manager.execute(composite)
        _debug(f"Inserted tile at index {insert_idx}")

    def handle_delete_tile(self):
        global current_tile_index, selected_tile_for_supertile
        if len(tileset_patterns) <= 1:
            messagebox.showinfo("Delete Tile", "Cannot delete the last tile.")
            return
        delete_idx = current_tile_index
        if not (0 <= delete_idx < len(tileset_patterns)):
            messagebox.showerror("Delete Tile Error", "Invalid tile index selected.")
            return

        usage = self._check_tile_usage(delete_idx)
        confirm_msg = f"Delete Tile {delete_idx}?"
        if usage:
            confirm_msg += "\n\n*** WARNING! ***\nThis tile is used by the following Supertile(s):\n" + ", ".join(map(str, usage[:10]))
            if len(usage) > 10: confirm_msg += "..."
            confirm_msg += f"\n\nReferences in these Supertiles will be reset to Tile 0."
        if not messagebox.askokcancel("Confirm Delete", confirm_msg, icon="warning"): return

        self._adjust_marked_indices_after_delete(self.marked_unused_tiles, delete_idx)

        pattern_command = ModifyListCommand("Delete Tile", tileset_patterns, delete_idx, is_insert=False)
        color_command = ModifyListCommand("Delete Tile", tileset_colors, delete_idx, is_insert=False)
        
        # Use the new, optimized command for updating supertile references
        st_refs_command = UpdateSupertileRefsForTileCommand("Update Supertile Refs", self, delete_idx, is_insert=False)
        
        old_state = (current_tile_index, selected_tile_for_supertile)
        new_num_tiles = len(tileset_patterns) - 1
        new_selection = min(delete_idx, new_num_tiles - 1)
        new_st_selection = selected_tile_for_supertile
        if selected_tile_for_supertile == delete_idx: new_st_selection = 0
        elif selected_tile_for_supertile > delete_idx: new_st_selection -= 1
        new_st_selection = min(new_st_selection, new_num_tiles - 1)
        new_state = (new_selection, new_st_selection)
        def state_setter(state_tuple):
            global current_tile_index, selected_tile_for_supertile
            current_tile_index, selected_tile_for_supertile = state_tuple
        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)

        def post_delete_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self._update_editor_button_states()
            self._request_color_usage_refresh()
            self.scroll_viewers_to_tile(current_tile_index)

        composite = CompositeCommand("Delete Tile", [pattern_command, color_command, st_refs_command, state_command], app_ref=self, post_hooks=[post_delete_hooks])
        self.undo_manager.execute(composite)
        _debug(f"Deleted tile at index {delete_idx}")

    def handle_add_supertile(self):  
        global current_supertile_index

        if len(supertiles_data) >= self.project_supertile_limit:
            messagebox.showwarning("Add Supertile Failed", f"Could not add supertile. The supertile limit is set to {self.project_supertile_limit}.")
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        new_st_idx = len(supertiles_data)
        blank_st_definition = [
            [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
        ]

        st_add_command = ModifyListCommand("Add Supertile", supertiles_data, new_st_idx, blank_st_definition, is_insert=True)
        
        # Command to update application state
        old_state = (current_supertile_index,)
        new_state = (new_st_idx,)
        
        def state_setter(state_tuple):
            global current_supertile_index
            current_supertile_index = state_tuple[0]

        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)

        # Define post-action hooks for UI updates
        def post_add_hooks():
            self._mark_project_modified()
            self.supertile_image_cache.clear()
            self.map_render_cache.clear()
            self.invalidate_minimap_background_cache()
            self._update_editor_button_states()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()
            self.scroll_selectors_to_supertile(current_supertile_index)

        # Combine actions into one command
        composite = CompositeCommand(
            "Add Supertile", 
            [st_add_command, state_command],
            app_ref=self,
            post_hooks=[post_add_hooks]
        )
        self.undo_manager.execute(composite)
        
        _debug(f"Added new supertile {new_st_idx}")

    def handle_insert_supertile(self):
        global current_supertile_index, selected_supertile_for_map

        if len(supertiles_data) >= self.project_supertile_limit:
            messagebox.showwarning("Insert Supertile Failed", f"Could not insert supertile. The supertile limit is set to {self.project_supertile_limit}.")
            return

        if self._clear_marked_unused(trigger_redraw=False):
            pass

        insert_idx = current_supertile_index
        
        blank_st_definition = [
            [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
        ]
        st_insert_command = ModifyListCommand("Insert Supertile", supertiles_data, insert_idx, blank_st_definition, is_insert=True)
        
        old_map_data = copy.deepcopy(map_data)
        new_map_data = copy.deepcopy(map_data)
        for r in range(map_height - 1, -1, -1):
            for c in range(map_width - 1, -1, -1):
                if new_map_data[r][c] >= insert_idx:
                    new_map_data[r][c] += 1
        
        def map_data_setter(data):
            global map_data
            map_data = data
        
        map_refs_command = SetDataCommand("Update Map Refs", self, map_data_setter, new_map_data, old_map_data)
        
        # Command to update application state
        old_state = (current_supertile_index, selected_supertile_for_map)
        new_num_supertiles = len(supertiles_data) + 1
        new_selection = insert_idx
        new_map_selection = selected_supertile_for_map + 1 if selected_supertile_for_map >= insert_idx else selected_supertile_for_map
        new_map_selection = min(new_map_selection, new_num_supertiles - 1)
        new_state = (new_selection, new_map_selection)

        def state_setter(state_tuple):
            global current_supertile_index, selected_supertile_for_map
            current_supertile_index, selected_supertile_for_map = state_tuple

        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)

        # Define post-action hooks for UI updates
        def post_insert_hooks():
            self._mark_project_modified()
            self.supertile_image_cache.clear()
            self.map_render_cache.clear()
            self.invalidate_minimap_background_cache()
            self._update_editor_button_states()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()
            self.scroll_selectors_to_supertile(current_supertile_index)

        # --- Combine all actions into one ---
        composite = CompositeCommand("Insert Supertile", [st_insert_command, map_refs_command, state_command], app_ref=self, post_hooks=[post_insert_hooks])
        self.undo_manager.execute(composite)

        _debug(f"Inserted supertile at index {insert_idx}")

    def handle_delete_supertile(self):
        global current_supertile_index, selected_supertile_for_map

        if len(supertiles_data) <= 1:
            messagebox.showinfo("Delete Supertile", "Cannot delete the last supertile.", parent=self.root)
            return

        delete_idx = current_supertile_index
        if not (0 <= delete_idx < len(supertiles_data)):
            messagebox.showerror("Delete Supertile Error", "Invalid supertile index selected.", parent=self.root)
            return

        usage = self._check_supertile_usage(delete_idx)
        confirm_msg = f"Delete Supertile {delete_idx}?"
        if usage:
            map_coords_str = ", ".join(
                [f"({r_idx},{c_idx})" for r_idx, c_idx in usage[:10]] 
            )  
            confirm_msg += "\n\n*** WARNING! ***\nThis supertile is used on the Map at:\n"
            confirm_msg += map_coords_str
            if len(usage) > 10:
                confirm_msg += "..."
            confirm_msg += f"\n\nReferences on the Map will be reset to Supertile 0."

        if not messagebox.askokcancel("Confirm Delete", confirm_msg, icon="warning", parent=self.root):
            return
        
        self._adjust_marked_indices_after_delete(self.marked_unused_supertiles, delete_idx)
        
        st_delete_command = ModifyListCommand("Delete Supertile", supertiles_data, delete_idx, is_insert=False)
        
        old_map_data = copy.deepcopy(map_data)
        new_map_data = copy.deepcopy(map_data)
        for r in range(map_height - 1, -1, -1):
            for c in range(map_width - 1, -1, -1):
                if new_map_data[r][c] == delete_idx:
                    new_map_data[r][c] = 0
                elif new_map_data[r][c] > delete_idx:
                    new_map_data[r][c] -= 1

        def map_data_setter(data):
            global map_data
            map_data = data
        
        map_refs_command = SetDataCommand("Update Map Refs", self, map_data_setter, new_map_data, old_map_data)
        
        old_state = (current_supertile_index, selected_supertile_for_map)
        new_num_supertiles = len(supertiles_data) - 1
        new_selection = min(delete_idx, new_num_supertiles - 1)
        new_map_selection = selected_supertile_for_map
        if selected_supertile_for_map == delete_idx:
            new_map_selection = 0
        elif selected_supertile_for_map > delete_idx:
            new_map_selection -= 1
        new_map_selection = min(new_map_selection, new_num_supertiles - 1)
        new_state = (new_selection, new_map_selection)

        def state_setter(state_tuple):
            global current_supertile_index, selected_supertile_for_map
            current_supertile_index, selected_supertile_for_map = state_tuple

        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)

        def post_delete_hooks():
            self._mark_project_modified()
            self.supertile_image_cache.clear()
            self.map_render_cache.clear()
            self.invalidate_minimap_background_cache()
            self._update_editor_button_states()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()
            self.scroll_selectors_to_supertile(current_supertile_index)

        composite = CompositeCommand("Delete Supertile", [st_delete_command, map_refs_command, state_command], app_ref=self, post_hooks=[post_delete_hooks])
        self.undo_manager.execute(composite)

        _debug(f"Deleted supertile at index {delete_idx}")

    def _reposition_tile(self, source_index, target_index):
        global tileset_patterns, tileset_colors
        global current_tile_index, selected_tile_for_supertile

        if not (0 <= source_index < len(tileset_patterns)): return False
        clamped_target = max(0, min(target_index, len(tileset_patterns)))
        
        actual_insert_idx = clamped_target
        if source_index < clamped_target:
            actual_insert_idx -= 1
            
        if source_index == actual_insert_idx: return False

        pattern_command = ReorderListCommand("Move Tile", tileset_patterns, source_index, actual_insert_idx)
        color_command = ReorderListCommand("Move Tile", tileset_colors, source_index, actual_insert_idx)

        # Use the new, fast, procedural command
        st_refs_command = UpdateSupertileRefsForTileReorderCommand("Update Supertile Refs", self, source_index, actual_insert_idx)
        
        old_state = (current_tile_index, selected_tile_for_supertile)
        new_cti = current_tile_index
        if current_tile_index == source_index: new_cti = actual_insert_idx
        elif source_index < actual_insert_idx:
            if source_index < current_tile_index <= actual_insert_idx: new_cti -= 1
        else:
            if actual_insert_idx <= current_tile_index < source_index: new_cti += 1
        
        new_sts = selected_tile_for_supertile
        if selected_tile_for_supertile == source_index: new_sts = actual_insert_idx
        elif source_index < actual_insert_idx:
            if source_index < selected_tile_for_supertile <= actual_insert_idx: new_sts -= 1
        else:
            if actual_insert_idx <= selected_tile_for_supertile < source_index: new_sts += 1 
        new_state = (new_cti, new_sts)

        def state_setter(state_tuple):
            global current_tile_index, selected_tile_for_supertile
            current_tile_index, selected_tile_for_supertile = state_tuple
        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)

        def post_hooks():
            self._mark_project_modified()
            # Caches and usage are now handled by the specific command, but we keep these
            # for the state command and final redraw coordination.
            self.scroll_viewers_to_tile(current_tile_index)

        composite = CompositeCommand("Move Tile", [pattern_command, color_command, st_refs_command, state_command], app_ref=self, post_hooks=[post_hooks])
        self.undo_manager.execute(composite)
        return True

    def _reposition_supertile(self, source_index_st, target_index_st):
        global supertiles_data, map_data, map_width, map_height
        global current_supertile_index, selected_supertile_for_map 

        if not (0 <= source_index_st < len(supertiles_data)):
            _error(f"Invalid source index {source_index_st} for supertile move.")
            return False
        
        clamped_target_index_st = max(0, min(target_index_st, len(supertiles_data)))

        if source_index_st == clamped_target_index_st:
            return False
        
        # Adjust target for list.insert() if moving an item down the list
        actual_insert_idx_st = clamped_target_index_st
        if source_index_st < clamped_target_index_st:
            actual_insert_idx_st -= 1

        # --- Create Commands ---
        st_reorder_command = ReorderListCommand("Move Supertile", supertiles_data, source_index_st, actual_insert_idx_st)

        old_map_data = copy.deepcopy(map_data)
        new_map_data = copy.deepcopy(map_data)
        for r_map_refo in range(map_height):
            for c_map_refo in range(map_width):
                current_map_ref = new_map_data[r_map_refo][c_map_refo]
                if current_map_ref == source_index_st:
                    new_map_data[r_map_refo][c_map_refo] = actual_insert_idx_st
                elif source_index_st < actual_insert_idx_st: 
                    if source_index_st < current_map_ref <= actual_insert_idx_st:
                         new_map_data[r_map_refo][c_map_refo] -= 1
                elif source_index_st > actual_insert_idx_st: 
                    if actual_insert_idx_st <= current_map_ref < source_index_st:
                         new_map_data[r_map_refo][c_map_refo] += 1
        def map_data_setter(data):
            global map_data
            map_data = data
        map_refs_command = SetDataCommand("Update Map Refs", self, map_data_setter, new_map_data, old_map_data)

        old_state = (current_supertile_index, selected_supertile_for_map)
        new_csi = current_supertile_index
        if current_supertile_index == source_index_st: new_csi = actual_insert_idx_st
        elif source_index_st < actual_insert_idx_st:
            if source_index_st < current_supertile_index <= actual_insert_idx_st: new_csi -= 1
        else:
            if actual_insert_idx_st <= current_supertile_index < source_index_st: new_csi += 1
        
        new_ssm = selected_supertile_for_map
        if selected_supertile_for_map == source_index_st: new_ssm = actual_insert_idx_st
        elif source_index_st < actual_insert_idx_st:
            if source_index_st < selected_supertile_for_map <= actual_insert_idx_st: new_ssm -= 1
        else:
            if actual_insert_idx_st <= selected_supertile_for_map < source_index_st: new_ssm += 1
        new_state = (new_csi, new_ssm)

        def state_setter(state_tuple):
            global current_supertile_index, selected_supertile_for_map
            current_supertile_index, selected_supertile_for_map = state_tuple
        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)

        def post_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

        composite = CompositeCommand("Move Supertile", [st_reorder_command, map_refs_command, state_command], app_ref=self, post_hooks=[post_hooks])
        self.undo_manager.execute(composite)
        
        _debug(f"  Successfully moved Supertile {source_index_st} to {actual_insert_idx_st}")
        return True

    def _get_index_from_canvas_coords(self, canvas, x_event, y_event, item_type_str):
        padding = 1
        items_across_calc = 0
        item_render_w = 0
        item_render_h = 0
        max_items_count = 0

        if not canvas.winfo_exists(): # Early exit if canvas is gone
            _debug(f" _get_index_from_canvas_coords: Canvas {canvas} does not exist.")
            return -1 

        if item_type_str == "tile":
            items_across_calc = NUM_TILES_ACROSS # Constant for tile viewers
            item_render_w = VIEWER_TILE_SIZE
            item_render_h = VIEWER_TILE_SIZE
            max_items_count = len(tileset_patterns)
        elif item_type_str == "supertile":
            item_render_w = self.supertile_grid_width * TILE_WIDTH
            item_render_h = self.supertile_grid_height * TILE_HEIGHT
            max_items_count = len(supertiles_data)

            if item_render_w <= 0 or item_render_h <= 0:
                _debug(f" _get_index_from_canvas_coords: Invalid item_render_w/h for supertile ({item_render_w}x{item_render_h}).")
                return -1

            actual_canvas_w = canvas.winfo_width()
            if actual_canvas_w <= 1: # Canvas not sized yet or too small
                _debug(f" _get_index_from_canvas_coords: actual_canvas_w ({actual_canvas_w}) too small for supertile.")
                return -1 

            # This logic should now be identical to the one in draw_supertile_selector
            if item_render_w + (2 * padding) > actual_canvas_w : # Not even one fits with padding on both sides
                items_across_calc = 0 
                if item_render_w <= actual_canvas_w : # Fits if no padding considered for this check
                    items_across_calc = 1
                # else: it's wider than canvas, items_across_calc remains 0 (or handle as error/special case)
            else:
                # Calculate max integer number of items that can fit
                if (item_render_w + padding) <= 0: # Avoid division by zero if item_render_w is huge negative (should not happen)
                    items_across_calc = 0
                else:
                    items_across_calc = (actual_canvas_w - padding) // (item_render_w + padding)
            
            items_across_calc = max(1, items_across_calc) # Ensure at least 1 item if possible
            _debug(f" _get_index_from_canvas_coords (supertile): CanvasW={actual_canvas_w}, ItemW={item_render_w}, Calculated items_across_calc={items_across_calc}")

        else:
            _error(f" _get_index_from_canvas_coords: Invalid item_type '{item_type_str}'")
            return -1

        if item_render_w <= 0 or item_render_h <= 0 or items_across_calc <= 0:
            _error(f" _get_index_from_canvas_coords: Invalid calculated layout params for {item_type_str} (item_w={item_render_w}, item_h={item_render_h}, items_across={items_across_calc})")
            return -1

        try:
            canvas_content_x = canvas.canvasx(x_event)
            canvas_content_y = canvas.canvasy(y_event)
        except tk.TclError:
            _error(f" _get_index_from_canvas_coords: TclError getting canvasx/y for {item_type_str}. Canvas likely not ready.")
            return -1 

        # Calculate total content dimensions based on dynamic layout
        num_logical_rows_calc = math.ceil(max_items_count / items_across_calc) if items_across_calc > 0 else 0
        # Use actual_canvas_w for total_content_w if items_across_calc is based on it,
        # or derive from items_across_calc if that's the definitive count.
        # The scrollregion width in draw_supertile_selector is based on its items_across.
        # So, use items_across_calc here for consistency with how scrollregion is set.
        total_content_w = (items_across_calc * item_render_w) + ((items_across_calc + 1) * padding)
        total_content_h = (num_logical_rows_calc * item_render_h) + ((num_logical_rows_calc + 1) * padding)
        
        # Check if click is within the logical content area defined by items_across_calc
        # This check becomes more important if items_across_calc differs from what might physically fit
        # if the canvas is wider than what items_across_calc would fill.
        # However, with the unified logic, items_across_calc should reflect the drawn layout.
        if not (canvas_content_x >= 0 and canvas_content_x < total_content_w and \
                canvas_content_y >= 0 and canvas_content_y < total_content_h):
            # If click is outside the calculated total content width/height based on items_across_calc,
            # it might be in empty space if the canvas is wider than this content.
            # Consider it "outside grid content area".
            _debug(f" _get_index_from_canvas_coords: Click ({canvas_content_x},{canvas_content_y}) outside content area ({total_content_w}x{total_content_h}).")
            return -2 

        col_calc = 0
        if (item_render_w + padding) > 0 : # Avoid division by zero
            col_calc = int(canvas_content_x // (item_render_w + padding))
        
        row_calc = 0
        if (item_render_h + padding) > 0 : # Avoid division by zero
            row_calc = int(canvas_content_y // (item_render_h + padding))
        
        col_calc = max(0, col_calc) 
        row_calc = max(0, row_calc)

        index_calc = row_calc * items_across_calc + col_calc

        if 0 <= index_calc < max_items_count:
            return index_calc
        else:
            # Clicked within the logical grid area but beyond the last *valid* item.
            # This can signify a drop target at the end of the list.
            # Or it could be a click in an empty cell if the grid is not full.
            # Return max_items_count (the count) to indicate this "end of list" target or empty area.
            # For drag-and-drop, targetting max_items_count usually means "append".
            # For a simple click, if index_calc >= max_items_count, it means no valid item was clicked.
            # The caller (e.g., handle_viewer_drag_release or a click handler) needs to interpret this.
            # A click should probably only react if 0 <= index_calc < max_items_count.
            # A drag-release might use max_items_count as a valid drop target.
            _debug(f" _get_index_from_canvas_coords: Calculated index {index_calc} is >= max_items_count {max_items_count}. Returning {max_items_count}.")
            return max_items_count

    def handle_viewer_drag_motion(self, event):
        if self.drag_start_index == -1 or self.drag_item_type is None or self.drag_canvas is None:
            return

        canvas_motion = event.widget 

        if not self.drag_active:
            dx = event.x - self.drag_press_x
            dy = event.y - self.drag_press_y
            distance_squared = dx*dx + dy*dy

            if distance_squared >= (DRAG_THRESHOLD_PIXELS * DRAG_THRESHOLD_PIXELS):
                self.drag_active = True
                
                if self.drag_canvas and self.drag_canvas.winfo_exists():
                    if self.drag_item_type == "tile":
                        other_highlight_idx = -1
                        if self.drag_canvas == self.tileset_canvas:
                             other_highlight_idx = selected_tile_for_supertile
                        elif self.drag_canvas == self.st_tileset_canvas:
                             other_highlight_idx = current_tile_index
                        self.draw_tileset_viewer(self.drag_canvas, other_highlight_idx)
                    elif self.drag_item_type == "supertile":
                        other_highlight_idx_st = -1
                        if self.drag_canvas == self.supertile_selector_canvas:
                            other_highlight_idx_st = selected_supertile_for_map
                        elif self.drag_canvas == self.map_supertile_selector_canvas:
                            other_highlight_idx_st = current_supertile_index
                        self.draw_supertile_selector(self.drag_canvas, other_highlight_idx_st)
                try:
                    if canvas_motion.winfo_exists():
                        cursor_type = "spraycan" if self.is_alt_pressed else ("exchange" if self.is_ctrl_pressed else "target")
                        canvas_motion.config(cursor=cursor_type)
                except tk.TclError: pass
            else:
                return
        
        if not self.drag_active: 
            return

        target_canvas_for_indicator = self.drag_canvas
        if not target_canvas_for_indicator or not target_canvas_for_indicator.winfo_exists():
            self.drag_active = False; self.drag_item_type = None; self.drag_start_index = -1; self.drag_canvas = None
            if self.drag_indicator_id and canvas_motion.winfo_exists():
                try: canvas_motion.delete(self.drag_indicator_id)
                except tk.TclError: pass
            self.drag_indicator_id = None
            return

        target_idx_motion = self._get_index_from_canvas_coords(
            canvas_motion, event.x, event.y, self.drag_item_type
        )

        if self.drag_indicator_id:
            try: target_canvas_for_indicator.delete(self.drag_indicator_id)
            except tk.TclError: pass
            self.drag_indicator_id = None

        if target_idx_motion >= 0 and canvas_motion == target_canvas_for_indicator and not self.is_alt_pressed:
            padding_ind = 1
            item_w_ind, item_h_ind, items_across_ind, max_items_ind = 0,0,0,0

            if self.drag_item_type == "tile":
                item_w_ind = VIEWER_TILE_SIZE
                item_h_ind = VIEWER_TILE_SIZE
                items_across_ind = NUM_TILES_ACROSS
                max_items_ind = len(tileset_patterns)
            elif self.drag_item_type == "supertile":
                item_w_ind = self.supertile_grid_width * TILE_WIDTH
                item_h_ind = self.supertile_grid_height * TILE_HEIGHT
                max_items_ind = len(supertiles_data)
                actual_canvas_w_ind = target_canvas_for_indicator.winfo_width()
                if (item_w_ind + padding_ind) > 0:
                    items_across_ind = max(1, (actual_canvas_w_ind - padding_ind) // (item_w_ind + padding_ind))
                else:
                    items_across_ind = 1

            if item_w_ind > 0 and item_h_ind > 0 and items_across_ind > 0:
                indicator_pos_idx = min(target_idx_motion, max_items_ind) 
                
                row_ind, col_ind = divmod(indicator_pos_idx, items_across_ind)
                
                line_x_pos = (col_ind * (item_w_ind + padding_ind)) + (padding_ind / 2) 
                line_y1_pos = (row_ind * (item_h_ind + padding_ind)) + (padding_ind / 2)
                line_y2_pos = line_y1_pos + item_h_ind 

                self.drag_indicator_id = target_canvas_for_indicator.create_line(
                    line_x_pos, line_y1_pos, line_x_pos, line_y2_pos,
                    fill="yellow", width=3, tags="drop_indicator"
                )
        try:
            if canvas_motion.winfo_exists():
                new_cursor = "spraycan" if self.is_alt_pressed else ("exchange" if self.is_ctrl_pressed else "target")
                if canvas_motion.cget("cursor") != new_cursor:
                     canvas_motion.config(cursor=new_cursor)
        except tk.TclError: pass

    def handle_viewer_drag_release(self, event):
        global current_tile_index, selected_tile_for_supertile
        global current_supertile_index, selected_supertile_for_map

        canvas = event.widget
        was_dragging = self.drag_active
        
        try:
            if not was_dragging:
                item_type_for_click = self.drag_item_type
                if item_type_for_click is None: return

                max_items = 0
                if item_type_for_click == "tile": max_items = len(tileset_patterns)
                elif item_type_for_click == "supertile": max_items = len(supertiles_data)

                index_at_release = self._get_index_from_canvas_coords(canvas, event.x, event.y, item_type_for_click)
                if 0 <= index_at_release < max_items:
                    source_canvas_type = None
                    if canvas == self.tileset_canvas: source_canvas_type = "tile_editor_main"
                    elif canvas == self.st_tileset_canvas: source_canvas_type = "supertile_editor_tile"
                    elif canvas == self.supertile_selector_canvas: source_canvas_type = "supertile_editor_main"
                    elif canvas == self.map_supertile_selector_canvas: source_canvas_type = "map_editor_palette"

                    if item_type_for_click == "tile":
                        if source_canvas_type == "tile_editor_main":
                            if current_tile_index != index_at_release:
                                current_tile_index = index_at_release
                                self.update_all_displays(changed_level="tile_select")
                                self.scroll_viewers_to_tile(current_tile_index)
                        elif source_canvas_type == "supertile_editor_tile":
                            if selected_tile_for_supertile != index_at_release:
                                selected_tile_for_supertile = index_at_release
                                self.draw_tileset_viewer(canvas, selected_tile_for_supertile)
                                self._update_st_tab_selected_tile_info_panel()
                                self.scroll_viewers_to_tile(selected_tile_for_supertile)
                    elif item_type_for_click == "supertile":
                        if source_canvas_type == "supertile_editor_main":
                            if current_supertile_index != index_at_release:
                                current_supertile_index = index_at_release
                                self.update_all_displays(changed_level="supertile")
                                self.scroll_selectors_to_supertile(current_supertile_index)
                        elif source_canvas_type == "map_editor_palette":
                            if selected_supertile_for_map != index_at_release:
                                selected_supertile_for_map = index_at_release
                                self.update_all_displays(changed_level="map")
                                self.scroll_selectors_to_supertile(selected_supertile_for_map)
            
            elif self.drag_item_type is not None: # Drag was active
                item_type = self.drag_item_type
                max_items = 0
                if item_type == "tile": max_items = len(tileset_patterns)
                elif item_type == "supertile": max_items = len(supertiles_data)
                
                is_alt_down = (event.state & 0x20000) != 0
                is_ctrl_down = (event.state & 0x0004) != 0
                source_index = self.drag_start_index
                target_index = self._get_index_from_canvas_coords(canvas, event.x, event.y, item_type)

                if is_alt_down and 0 <= target_index < max_items:
                    self._execute_replace_all_references(item_type, source_index, target_index)
                
                elif is_ctrl_down and 0 <= target_index < max_items and target_index != source_index:
                    success = self._swap_items(item_type, source_index, target_index)
                    if success:
                        self.clear_all_caches()
                        self.invalidate_minimap_background_cache()
                        self.update_all_displays(changed_level="all")
                        if item_type == "tile":
                            self.scroll_viewers_to_tile(current_tile_index)
                            self._request_tile_usage_refresh()
                            self._request_supertile_usage_refresh()
                        elif item_type == "supertile":
                            self.scroll_selectors_to_supertile(current_supertile_index)
                            self._request_tile_usage_refresh()
                            self._request_supertile_usage_refresh()
                
                elif not is_ctrl_down and not is_alt_down: # MOVE LOGIC
                    valid_drop_target = (0 <= target_index <= max_items)
                    if valid_drop_target and target_index != source_index:
                        success = False
                        if item_type == "tile": success = self._reposition_tile(source_index, target_index)
                        elif item_type == "supertile": success = self._reposition_supertile(source_index, target_index)
                        
                        if success:
                            self.clear_all_caches()
                            self.invalidate_minimap_background_cache()
                            self.update_all_displays(changed_level="all")
                            if item_type == "tile":
                                self.scroll_viewers_to_tile(current_tile_index)
                                self._request_tile_usage_refresh()
                                self._request_supertile_usage_refresh()
                            elif item_type == "supertile":
                                self.scroll_selectors_to_supertile(current_supertile_index)
                                self._request_tile_usage_refresh()
                                self._request_supertile_usage_refresh()
                        else:
                            messagebox.showerror("Reposition Error", f"Failed to move {item_type} from {source_index} to {target_index}.")
                            self.update_all_displays(changed_level="all")
                    else:
                        self.update_all_displays(changed_level="all")
        finally:
            if self.drag_indicator_id:
                try:
                    if self.drag_canvas and self.drag_canvas.winfo_exists():
                        self.drag_canvas.delete(self.drag_indicator_id)
                except (tk.TclError, AttributeError): pass
                self.drag_indicator_id = None
            
            if hasattr(self, 'drag_canvas') and self.drag_canvas and self.drag_canvas.winfo_exists():
                try:
                    self.drag_canvas.config(cursor="")
                except tk.TclError: pass
            
            self.drag_active = False
            self.drag_item_type = None
            self.drag_start_index = -1
            self.drag_canvas = None
            self.is_alt_pressed = False

    def _set_pencil_cursor(self, event):
        """Sets the cursor to 'pencil' for the widget that received the event."""
        try:
            # Check if widget still exists before configuring
            if event.widget.winfo_exists():
                event.widget.config(cursor="pencil")
        except tk.TclError:
            pass  # Ignore if widget is destroyed during event handling

    def _reset_cursor(self, event):
        """Resets the cursor to default for the widget that received the event."""
        try:
            if event.widget.winfo_exists():
                # Don't reset map canvas blindly, let its own logic handle it on leave
                if event.widget != self.map_canvas:
                    event.widget.config(cursor="")
                # If it *is* the map canvas, its existing <Leave> handler will take care of it
        except tk.TclError:
            pass  # Ignore if widget is destroyed

    # --- New Handlers and Helpers for Map Selection ---

    def handle_shift_press(self, event):
        """Handles Shift key press."""
        if "Shift" in event.keysym:
            if not self.is_shift_pressed:
                self.is_shift_pressed = True
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def handle_shift_release(self, event):
        """Handles Shift key release."""
        if "Shift" in event.keysym:
            if self.is_shift_pressed:
                self.is_shift_pressed = False
                if self.current_mouse_action is None:
                    self._update_map_cursor()

    def _get_supertile_coords_from_canvas(self, canvas_x_coord, canvas_y_coord): # Renamed params
        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w, zoomed_st_pixel_h = self._get_zoomed_supertile_pixel_dims()

        if zoomed_st_pixel_w <= 0 or zoomed_st_pixel_h <= 0:
            return None # Cannot calculate if dimensions are invalid

        st_col_calc = int(canvas_x_coord // zoomed_st_pixel_w)
        st_row_calc = int(canvas_y_coord // zoomed_st_pixel_h)

        if 0 <= st_row_calc < map_height and 0 <= st_col_calc < map_width:
            return (st_col_calc, st_row_calc)
        else:
            return None

    def _get_normalized_selection_st(self):
        """Returns normalized selection bounds (min_c, min_r, max_c, max_r) or None."""
        if self.map_selection_start_st is None or self.map_selection_end_st is None:
            return None

        start_c, start_r = self.map_selection_start_st
        end_c, end_r = self.map_selection_end_st

        min_c = min(start_c, end_c)
        min_r = min(start_r, end_r)
        max_c = max(start_c, end_c)
        max_r = max(start_r, end_r)

        return (min_c, min_r, max_c, max_r)

    def _draw_selection_rectangle(self):
        canvas = self.map_canvas
        if not canvas.winfo_exists():
            return

        if self.map_selection_rect_id:
            try:
                canvas.delete(self.map_selection_rect_id)
            except tk.TclError:
                pass # Item might already be gone
            self.map_selection_rect_id = None

        norm_coords_sel = self._get_normalized_selection_st()
        if norm_coords_sel is None:
            return

        min_c_sel, min_r_sel, max_c_sel, max_r_sel = norm_coords_sel

        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w_sel, zoomed_st_pixel_h_sel = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_pixel_w_sel <= 0 or zoomed_st_pixel_h_sel <= 0:
            return

        px1_sel = min_c_sel * zoomed_st_pixel_w_sel
        py1_sel = min_r_sel * zoomed_st_pixel_h_sel
        px2_sel = (max_c_sel + 1) * zoomed_st_pixel_w_sel # +1 because coords are inclusive
        py2_sel = (max_r_sel + 1) * zoomed_st_pixel_h_sel

        try:
            self.map_selection_rect_id = canvas.create_rectangle(
                px1_sel, py1_sel, px2_sel, py2_sel,
                outline="yellow",
                dash=(4, 4),
                width=2,
                tags=("selection_rect",)
            )
            # Ensure it's drawn below other interactive elements
            if canvas.find_withtag("window_view_item"):
                canvas.tag_lower(self.map_selection_rect_id, "window_view_item")
            elif canvas.find_withtag("supertile_grid"):
                canvas.tag_lower(self.map_selection_rect_id, "supertile_grid")
        except tk.TclError:
            self.map_selection_rect_id = None # Failed to create

    def _clear_map_selection(self):
        """Clears ONLY the map selection visual and related state variables."""
        canvas = self.map_canvas
        # Clear the visual rectangle
        if self.map_selection_rect_id:
            try:
                if canvas.winfo_exists():
                    canvas.delete(self.map_selection_rect_id)
            except tk.TclError:
                pass
            self.map_selection_rect_id = None

        # Check if state needs updating before resetting (for menu update trigger)
        needs_menu_update = self.map_selection_start_st is not None

        # Reset selection state variables
        self.map_selection_start_st = None
        self.map_selection_end_st = None
        self.map_selection_active = False # Ensure selection drag state is reset

        # Update menu if selection was active
        if needs_menu_update:
            self._update_edit_menu_state()
        # Do not redraw map here, let the caller handle redraw if needed
        # Do not clear paste preview or clipboard here

    def handle_map_selection_start(self, event):
        """Handles Shift + Button-1 press to start map selection."""
        if self.is_ctrl_pressed or self.current_mouse_action is not None:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        self._clear_map_selection()

        start_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)

        if start_coords:
            self.map_selection_start_st = start_coords
            self.map_selection_end_st = start_coords
            self.map_selection_active = True
            self._draw_selection_rectangle()
            self._update_map_cursor()
        else:
            self.map_selection_start_st = None
            self.map_selection_end_st = None
            self.map_selection_active = False

        return "break"

    def handle_map_selection_motion(self, event):
        """Handles Shift + B1 motion to update selection rectangle."""
        if not self.map_selection_active:
            return

        canvas = self.map_canvas
        canvas_x = canvas.canvasx(event.x)
        canvas_y = canvas.canvasy(event.y)

        current_coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)

        if current_coords:
            if self.map_selection_end_st != current_coords:
                self.map_selection_end_st = current_coords
                self._draw_selection_rectangle()
        # else: # Keep last valid end_st when mouse is outside

        return "break"

    def handle_map_selection_release(self, event):
        """Handles Shift + Button-1 release to finalize map selection."""
        if not self.map_selection_active:
            self._clear_map_selection()
            return

        self.map_selection_active = False

        if (
            self.map_selection_start_st is not None
            and self.map_selection_end_st is not None
        ):
            _debug(f"Selection finalized: {self.map_selection_start_st} to {self.map_selection_end_st}")
            # Final rectangle drawn by motion handler, redraw map to make it persistent
            self.draw_map_canvas()
            self._update_edit_menu_state()
        else:
            self._clear_map_selection()

        self._update_map_cursor()

        return "break"

    def handle_map_escape(self, event):
        """Handles Escape key press on map canvas to clear clipboard, paste preview, and selection."""
        _debug("Escape pressed on map, clearing clipboard, paste preview, and all highlights.")

        # Check what was active before clearing to see if a redraw is needed
        cleared_clipboard = self.map_clipboard_data is not None
        cleared_preview = self.map_paste_preview_rect_id is not None
        cleared_selection = self.map_selection_start_st is not None
        cleared_map_highlights = bool(self.highlighted_map_cells)
        cleared_st_marks = bool(self.marked_unused_supertiles)

        # Always attempt to clear all relevant states
        self.map_clipboard_data = None
        self._clear_paste_preview_rect()
        self._clear_map_selection() # This now only clears selection visuals/state
        self.highlighted_map_cells.clear() # Clear map highlights
        self.marked_unused_supertiles.clear() # Clear ST highlights in palette

        # Update menu state if the clipboard was cleared
        if cleared_clipboard:
            self._update_edit_menu_state()

        # A redraw is needed if any visual element was cleared
        if cleared_selection or cleared_map_highlights or cleared_st_marks:
            if self.map_canvas.winfo_exists():
                 self.draw_map_canvas()
            # Also redraw the selector palette to remove its highlights
            if self.map_supertile_selector_canvas.winfo_exists():
                 self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

        return "break" # Prevent other Escape bindings

    def _update_map_cursor_and_coords(self, event):
        """Combined handler for Motion to update both cursor and coords, and manage paste preview."""
        # Update coordinate display first
        self._update_map_coords_display(event)

        # Update cursor based on current state (e.g., pan, select, paint)
        self._update_map_cursor()

        # --- Paste Preview Logic ---
        is_map_tab_active = False
        if self.notebook and self.notebook.winfo_exists():
            try:
                 selected_tab_index = self.notebook.index(self.notebook.select())
                 if selected_tab_index == 3: # Map Editor tab index
                     is_map_tab_active = True
            except tk.TclError:
                pass # Ignore if notebook not ready

        # Conditions to show paste preview: Map tab active AND map clipboard has data
        if is_map_tab_active and self.map_clipboard_data:
            self._draw_paste_preview_rect(event=event)
        else:
            # Clear preview if conditions are not met (e.g., wrong tab, no clipboard data)
            # This handles cases where clipboard is cleared while mouse is over canvas
            self._clear_paste_preview_rect()

    # --- New Paste Preview Methods ---
    def _draw_paste_preview_rect(self, event=None, canvas_coords=None):
        canvas = self.map_canvas
        if not canvas.winfo_exists() or not self.map_clipboard_data or not self.notebook:
            self._clear_paste_preview_rect()
            return
        try:
            if self.notebook.index(self.notebook.select()) != 3: # Map Editor tab index
                 self._clear_paste_preview_rect()
                 return
        except tk.TclError:
            self._clear_paste_preview_rect()
            return

        current_canvas_x_paste, current_canvas_y_paste = -1, -1
        if canvas_coords:
            current_canvas_x_paste, current_canvas_y_paste = canvas_coords
        elif event:
            try:
                current_canvas_x_paste = canvas.canvasx(event.x)
                current_canvas_y_paste = canvas.canvasy(event.y)
            except tk.TclError:
                self._clear_paste_preview_rect()
                return
        else:
             self._clear_paste_preview_rect()
             return

        paste_st_coords_preview = self._get_supertile_coords_from_canvas(current_canvas_x_paste, current_canvas_y_paste)

        if paste_st_coords_preview is None:
            self._clear_paste_preview_rect()
            return

        paste_st_col_preview, paste_st_row_preview = paste_st_coords_preview
        clip_w_preview = self.map_clipboard_data.get('width', 0)
        clip_h_preview = self.map_clipboard_data.get('height', 0)

        if clip_w_preview <= 0 or clip_h_preview <= 0:
            self._clear_paste_preview_rect()
            return

        # Get current zoomed supertile pixel dimensions
        zoomed_st_pixel_w_preview, zoomed_st_pixel_h_preview = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_pixel_w_preview <= 0 or zoomed_st_pixel_h_preview <= 0:
             self._clear_paste_preview_rect()
             return

        px1_preview = paste_st_col_preview * zoomed_st_pixel_w_preview
        py1_preview = paste_st_row_preview * zoomed_st_pixel_h_preview
        px2_preview = px1_preview + (clip_w_preview * zoomed_st_pixel_w_preview)
        py2_preview = py1_preview + (clip_h_preview * zoomed_st_pixel_h_preview)

        fill_color_preview = "#0000FF"
        stipple_pattern_preview = "gray50"

        if self.map_paste_preview_rect_id:
            try:
                canvas.coords(self.map_paste_preview_rect_id, px1_preview, py1_preview, px2_preview, py2_preview)
                canvas.itemconfig(self.map_paste_preview_rect_id, state=tk.NORMAL, fill=fill_color_preview, stipple=stipple_pattern_preview)
            except tk.TclError:
                self.map_paste_preview_rect_id = None
        
        if not self.map_paste_preview_rect_id:
            try:
                self.map_paste_preview_rect_id = canvas.create_rectangle(
                    px1_preview, py1_preview, px2_preview, py2_preview,
                    fill=fill_color_preview,
                    stipple=stipple_pattern_preview,
                    outline="", 
                    width=0,
                    tags=("paste_preview_rect",)
                )
            except tk.TclError:
                 self.map_paste_preview_rect_id = None
                 return

        try:
            if self.map_selection_rect_id:
                 canvas.tag_lower(self.map_paste_preview_rect_id, self.map_selection_rect_id)
            if canvas.find_withtag("window_view_item"):
                canvas.tag_lower(self.map_paste_preview_rect_id, "window_view_item")
            elif canvas.find_withtag("supertile_grid"):
                 canvas.tag_lower(self.map_paste_preview_rect_id, "supertile_grid")
        except tk.TclError:
            pass


    def _clear_paste_preview_rect(self):
        """Safely deletes the paste preview rectangle from the canvas."""
        canvas = self.map_canvas
        if self.map_paste_preview_rect_id:
            try:
                if canvas.winfo_exists():
                    canvas.delete(self.map_paste_preview_rect_id)
            except tk.TclError:
                pass # Ignore error if item already deleted or canvas gone
            finally:
                 # Ensure ID is cleared even if deletion fails
                 self.map_paste_preview_rect_id = None

    def show_about_box(self):
        """Displays the About information box with the application icon."""
        # Create a Toplevel window
        about_win = tk.Toplevel(self.root)
        about_win.title("About MSX Tile Forge")
        about_win.resizable(False, False) 
        about_win.transient(self.root) 
        about_win.grab_set() 

        # Main frame for content
        main_frame = ttk.Frame(about_win, padding="15")
        main_frame.pack(expand=True, fill="both")

        icon_label = None
        # Try to get the icon reference stored during startup on the root window
        app_icon_photo = getattr(self.root, 'app_icon_ref', None)

        if app_icon_photo:
            icon_label = ttk.Label(main_frame, image=app_icon_photo)
            # Keep reference for the label within this Toplevel
            icon_label.image = app_icon_photo 
            icon_label.grid(row=0, column=0, padx=(0, 15), pady=(0, 10), sticky="nw")

        # Text information frame
        text_frame = ttk.Frame(main_frame)
        text_frame.grid(row=0, column=1, sticky="nsew")

        # Program Name (Bold)
        style = ttk.Style()
        style.configure("About.TLabel", font=("-size", 10, "bold"))
        name_label = ttk.Label(text_frame, text="MSX Tile Forge", style="About.TLabel")
        name_label.pack(anchor="w", pady=(0, 5))

        # Version and Author
        info_text = f"Version: {APP_VERSION}\nAuthor: Damned Angel + Gemini AI"
        info_label = ttk.Label(text_frame, text=info_text, justify=tk.LEFT)
        info_label.pack(anchor="w")
        
        # Contribution Info Frame
        contrib_frame = ttk.LabelFrame(text_frame, text="Contribute")
        contrib_frame.pack(pady=(10, 0), anchor="w", fill='x')

        bmac_url = "https://www.buymeacoffee.com/DamnedAngel"
        
        # Use a standard Label widget for hyperlink-like behavior
        bmac_label = tk.Label(contrib_frame, text="Buy Me a Coffee", fg="blue", cursor="hand2")
        bmac_label.pack(anchor="w", padx=5, pady=(2,0))
        bmac_label.bind("<Button-1>", lambda e: webbrowser.open_new(bmac_url))
        
        # Use a font with underline for visual cue
        link_font_about = font.Font(bmac_label, bmac_label.cget("font"))
        link_font_about.configure(underline=True)
        bmac_label.configure(font=link_font_about)

        ttk.Label(contrib_frame, text="PayPal: danilo@angelo.eng.br").pack(anchor="w", padx=5)
        ttk.Label(contrib_frame, text="Pix: danilo@angelo.eng.br").pack(anchor="w", padx=5, pady=(0,2))
        
        # OK Button frame (moved to a new row)
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=1, column=0, columnspan=2 if icon_label else 1, pady=(15, 0))

        ok_button = ttk.Button(button_frame, text="OK", command=about_win.destroy, width=10)
        ok_button.pack()

        about_win.update_idletasks() 
        main_width = self.root.winfo_width()
        main_height = self.root.winfo_height()
        main_x = self.root.winfo_x()
        main_y = self.root.winfo_y()

        pop_width = about_win.winfo_width()
        pop_height = about_win.winfo_height()

        pop_x = main_x + (main_width // 2) - (pop_width // 2)
        pop_y = main_y + (main_height // 2) - (pop_height // 2)

        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        pop_x = max(0, min(pop_x, screen_width - pop_width))
        pop_y = max(0, min(pop_y, screen_height - pop_height))

        about_win.geometry(f"+{pop_x}+{pop_y}")
        ok_button.focus_set()
        about_win.wait_window()

    def _find_unused_tiles(self):
        used_tile_indices = set()
        for st_idx in range(len(supertiles_data)):
            definition = supertiles_data[st_idx]
            if not definition or len(definition) != self.supertile_grid_height or \
               (self.supertile_grid_height > 0 and len(definition[0]) != self.supertile_grid_width):
                continue

            for r in range(self.supertile_grid_height):
                for c in range(self.supertile_grid_width):
                    used_tile_indices.add(definition[r][c])
        
        unused_tiles = set()
        for i in range(1, len(tileset_patterns)):
            if i not in used_tile_indices:
                unused_tiles.add(i)
        return unused_tiles

    def _find_unused_supertiles(self):
        """Identifies supertiles not used in the map_data."""
        global map_data, map_width, map_height
        used_st_indices = set()
        # Supertile 0 is implicitly used/reserved
        for r_idx in range(map_height): # Renamed r
            for c_idx in range(map_width): # Renamed c
                used_st_indices.add(map_data[r_idx][c_idx])
        # _debug(f"DEBUG: Used Supertile Indices from map_data: {used_st_indices}") # DEBUG

        unused_supertiles = set()
        for i in range(1, len(supertiles_data)): # Start from 1
            if i not in used_st_indices:
                unused_supertiles.add(i)
        _debug(f"DEBUG: Found Unused Supertiles (indices): {unused_supertiles}") # DEBUG
        return unused_supertiles

    def _clear_marked_unused(self, trigger_redraw=True):
        """Clears all 'marked unused' states and optionally redraws relevant viewers."""
        tile_marks_cleared = bool(self.marked_unused_tiles)
        st_marks_cleared = bool(self.marked_unused_supertiles)
        map_marks_cleared = bool(self.highlighted_map_cells) # Check if map highlights are active

        self.marked_unused_tiles.clear()
        self.marked_unused_supertiles.clear()
        self.highlighted_map_cells.clear() # Clear the map highlights as well

        # Check if any type of mark was cleared
        any_marks_cleared = tile_marks_cleared or st_marks_cleared or map_marks_cleared

        if trigger_redraw and any_marks_cleared:
            # Redraw only if marks were actually cleared to avoid unnecessary redraws
            # Determine active tab to redraw correctly
            current_tab_index = -1
            try:
                if self.notebook and self.notebook.winfo_exists():
                    selected_tab_name = self.notebook.select()
                    if selected_tab_name:
                        current_tab_index = self.notebook.index(selected_tab_name)
            except tk.TclError:
                pass

            if current_tab_index == 1: # Tile Editor
                if tile_marks_cleared:
                    self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)
            elif current_tab_index == 2: # Supertile Editor
                if tile_marks_cleared:
                    self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
                if st_marks_cleared:
                    self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
            elif current_tab_index == 3: # Map Editor
                # Redraw map if its highlights were cleared
                if map_marks_cleared:
                    self.draw_map_canvas()
                # Redraw selector if its highlights were cleared
                if st_marks_cleared: 
                    self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
        
        return any_marks_cleared


    def _adjust_marked_indices_after_delete(self, marked_set, deleted_index):
        """Adjusts indices in a 'marked_set' after an item at 'deleted_index' is removed."""
        if deleted_index in marked_set:
            marked_set.remove(deleted_index)
        
        new_marked_set = set()
        for idx in marked_set:
            if idx > deleted_index:
                new_marked_set.add(idx - 1)
            else:
                new_marked_set.add(idx)
        marked_set.clear()
        marked_set.update(new_marked_set)


    def handle_mark_unused_tiles(self):
        """Handles the 'Mark Unused' button click in the Tile Editor tab."""
        if self.marked_unused_tiles: # If already marked, clear them
            self._clear_marked_unused(trigger_redraw=False) 
            self.draw_tileset_viewer(self.tileset_canvas, current_tile_index) 
        else:
            # Clear any supertile marks from other tab before marking tiles
            # This ensures only tile marks are active if this button is pressed
            if self.marked_unused_supertiles:
                self.marked_unused_supertiles.clear()
                 # Redraw ST selectors if they were marked to remove blue borders
                if hasattr(self, 'supertile_selector_canvas') and self.supertile_selector_canvas.winfo_exists():
                    self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
                if hasattr(self, 'map_supertile_selector_canvas') and self.map_supertile_selector_canvas.winfo_exists():
                    self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)

            self.marked_unused_tiles = self._find_unused_tiles()
            if not self.marked_unused_tiles:
                messagebox.showinfo("Mark Unused Tiles", "No unused tiles found.")
            else:
                print(f"Marked unused tiles: {sorted(list(self.marked_unused_tiles))}") # Print sorted list
            self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)

    def handle_mark_unused_supertiles_and_tiles(self):
        """Handles the 'Mark Unused' button in the Supertile Editor tab."""
        # If either set has marks, clear both
        if self.marked_unused_tiles or self.marked_unused_supertiles:
            self._clear_marked_unused(trigger_redraw=False) 
            # Redraw viewers in this tab
            self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
        else: # Neither set has marks, so we are in "mark" mode
            self.marked_unused_tiles = self._find_unused_tiles()
            self.marked_unused_supertiles = self._find_unused_supertiles() 
            
            if not self.marked_unused_tiles and not self.marked_unused_supertiles:
                messagebox.showinfo("Mark Unused", "No unused tiles or supertiles found.")
            else:
                # Only print the sets if they contain items
                if self.marked_unused_tiles: 
                    print(f"Marked unused tiles: {sorted(list(self.marked_unused_tiles))}") # Print sorted list for consistency
                if self.marked_unused_supertiles: 
                    print(f"Marked unused supertiles: {sorted(list(self.marked_unused_supertiles))}") # Print sorted list

            # Redraw viewers in this tab
            self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
            self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)

    # --- ROM Importer Methods ---

    def open_rom_importer(self):
        """Handles the 'Import Tiles from ROM...' menu command."""
        # Prevent opening multiple importer dialogs
        if self.rom_import_dialog is not None and tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.rom_import_dialog.lift()
            self.rom_import_dialog.focus_set()
            return

        rom_filepath = filedialog.askopenfilename(
            title="Select ROM File",
            filetypes=[("All files", "*.*"), ("Binary files", "*.bin"), ("ROM files", "*.rom")]
        )
        if not rom_filepath:
            return # User cancelled

        try:
            with open(rom_filepath, "rb") as f:
                rom_data = f.read()
            if not rom_data:
                messagebox.showerror("ROM Import Error", "Selected file is empty.")
                return
        except Exception as e:
            messagebox.showerror("ROM Import Error", f"Could not read ROM file:\n{e}")
            return

        # If successful, create and show the dialog
        self._create_rom_importer_dialog(rom_filepath, rom_data)

    def _create_rom_importer_dialog(self, rom_filepath, rom_data):
        # Prevent opening multiple importer dialogs
        if self.rom_import_dialog is not None and tk.Toplevel.winfo_exists(self.rom_import_dialog):
            self.rom_import_dialog.lift()
            self.rom_import_dialog.focus_set()
            return

        self.rom_import_dialog = tk.Toplevel(self.root)
        dialog = self.rom_import_dialog
        dialog.title(f"ROM Tile Importer - {os.path.basename(rom_filepath)}")
        dialog.transient(self.root)
        dialog.grab_set()

        dialog.rom_data = rom_data
        dialog.rom_filepath = rom_filepath
        dialog.fine_offset_var = tk.IntVar(value=0)
        dialog.rom_importer_selection = {}
        dialog.rom_importer_anchor_idx = -1
        dialog.current_importer_fg_idx = WHITE_IDX
        dialog.current_importer_bg_idx = BLACK_IDX
        dialog.hover_info_text_var = tk.StringVar(value="Offset: N/A | Grid Index: N/A")
        dialog.selection_info_text_var = tk.StringVar(value="Tiles Selected: 0")
        dialog.top_left_grid_byte_offset_text_var = tk.StringVar(value="Grid Top-Left Byte: N/A")
        dialog.redraw_timer_id = None
        dialog.slider_redraw_timer_id = None
        dialog.rom_importer_grid_cols = 1

        dialog.pil_rom_viewport_image = None 
        dialog.tk_rom_photoimage = None      

        try:
            safe_tile_w = max(1, TILE_WIDTH)
            safe_tile_h = max(1, TILE_HEIGHT)
            dialog.temp_tile_image_unscaled_ref = tk.PhotoImage(width=safe_tile_w, height=safe_tile_h)
        except tk.TclError as e_photo:
            _debug(f" CRITICAL: Failed to create temp_tile_image_unscaled_ref: {e_photo}")
            messagebox.showerror("Importer Init Error", "Failed to initialize image resources for importer.", parent=dialog)
            if tk.Toplevel.winfo_exists(dialog):
                dialog.destroy()
            return

        main_dialog_frame = ttk.Frame(dialog, padding=5)
        main_dialog_frame.pack(expand=True, fill="both")
        main_dialog_frame.grid_columnconfigure(0, weight=0)
        main_dialog_frame.grid_columnconfigure(1, weight=1)
        main_dialog_frame.grid_rowconfigure(0, weight=1)
        main_dialog_frame.grid_rowconfigure(1, weight=0)

        left_column_frame = ttk.Frame(main_dialog_frame)
        left_column_frame.grid(row=0, column=0, sticky="nswe", padx=(0, 10))

        preview_label_frame = ttk.LabelFrame(left_column_frame, text="Live Preview")
        preview_label_frame.pack(side=tk.TOP, pady=(0, 10), anchor="n", fill=tk.X)
        preview_canvas_size = TILE_WIDTH * EDITOR_PIXEL_SIZE
        dialog.preview_canvas = tk.Canvas(
            preview_label_frame,
            width=max(1, preview_canvas_size),
            height=max(1, preview_canvas_size),
            bg="grey",
            highlightthickness=0
        )
        dialog.preview_canvas.pack(padx=5, pady=5, anchor="center")

        offset_control_frame = ttk.Frame(left_column_frame)
        offset_control_frame.pack(side=tk.TOP, pady=(0,10), fill=tk.X)
        ttk.Label(offset_control_frame, text="Fine Offset (0-7 bytes):").pack(side=tk.TOP, anchor="w")
        offset_slide_frame = ttk.Frame(offset_control_frame)
        offset_slide_frame.pack(side=tk.TOP, fill=tk.X, expand=True, padx=9)
        offset_slider = ttk.Scale(
            offset_slide_frame, from_=0, to=7, orient=tk.HORIZONTAL,
            variable=dialog.fine_offset_var, command=self._on_fine_offset_slider_change
        )
        offset_slider.pack(side=tk.TOP, fill=tk.X, expand=True)
        offset_tick_frame = ttk.Frame(offset_control_frame)
        offset_tick_frame.pack(side=tk.TOP, fill=tk.X, expand=True, pady=(2,0))
        for i in range(8):
            offset_tick_frame.grid_columnconfigure(i, weight=1)
            lbl = ttk.Label(offset_tick_frame, text=str(i), font=("TkSmallCaptionFont", 7))
            lbl.grid(row=0, column=i)

        importer_color_frame = ttk.LabelFrame(left_column_frame, text="Preview/Import Colors")
        importer_color_frame.pack(side=tk.TOP, pady=(10,5), fill=tk.X)

        fg_color_subframe = ttk.Frame(importer_color_frame)
        fg_color_subframe.pack(fill=tk.X, pady=2)
        ttk.Label(fg_color_subframe, text="FG (1-bits):").pack(side=tk.LEFT, padx=(5,2))
        dialog.importer_fg_swatch = tk.Label(fg_color_subframe, text="   ", relief="raised", borderwidth=2)
        dialog.importer_fg_swatch.pack(side=tk.LEFT, padx=2)
        dialog.importer_fg_swatch.bind("<Button-1>",
            lambda e, swatch_type='fg': self._pick_importer_color(swatch_type))

        bg_color_subframe = ttk.Frame(importer_color_frame)
        bg_color_subframe.pack(fill=tk.X, pady=2)
        ttk.Label(bg_color_subframe, text="BG (0-bits):").pack(side=tk.LEFT, padx=(5,2))
        dialog.importer_bg_swatch = tk.Label(bg_color_subframe, text="   ", relief="raised", borderwidth=2)
        dialog.importer_bg_swatch.pack(side=tk.LEFT, padx=2)
        dialog.importer_bg_swatch.bind("<Button-1>",
            lambda e, swatch_type='bg': self._pick_importer_color(swatch_type))

        info_bar_frame = ttk.Frame(left_column_frame, padding=3)
        info_bar_frame.pack(side=tk.TOP, fill=tk.X, expand=False, pady=(5,5))
        dialog.status_bar_top_left_label = ttk.Label(info_bar_frame, textvariable=dialog.top_left_grid_byte_offset_text_var, anchor="w", justify=tk.LEFT)
        dialog.status_bar_top_left_label.pack(side=tk.TOP, fill=tk.X)
        hover_label = ttk.Label(info_bar_frame, textvariable=dialog.hover_info_text_var, anchor="w", justify=tk.LEFT)
        hover_label.pack(side=tk.TOP, fill=tk.X)
        selection_label = ttk.Label(info_bar_frame, textvariable=dialog.selection_info_text_var, anchor="w", justify=tk.LEFT)
        selection_label.pack(side=tk.TOP, fill=tk.X)

        canvas_frame = ttk.Frame(main_dialog_frame)
        canvas_frame.grid(row=0, column=1, sticky="nswe")
        canvas_frame.grid_rowconfigure(0, weight=1)
        canvas_frame.grid_columnconfigure(0, weight=1)

        rom_v_scroll = ttk.Scrollbar(canvas_frame, orient=tk.VERTICAL)
        rom_h_scroll = ttk.Scrollbar(canvas_frame, orient=tk.HORIZONTAL)

        dialog.canvas = tk.Canvas(
            canvas_frame,
            bg="darkgrey",
            yscrollcommand=rom_v_scroll.set,
            xscrollcommand=rom_h_scroll.set,
            highlightthickness=0
        )

        def _schedule_debounced_draw_from_scroll_rom():
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            if not hasattr(current_dialog, 'redraw_timer_id'): current_dialog.redraw_timer_id = None

            if current_dialog.redraw_timer_id is not None:
                current_dialog.after_cancel(current_dialog.redraw_timer_id)
            current_dialog.redraw_timer_id = current_dialog.after(30, self._perform_debounced_rom_canvas_draw)

        def yview_wrapper_debounced_rom(*args):
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            current_canvas = getattr(current_dialog, 'canvas', None)
            if not current_canvas or not current_canvas.winfo_exists(): return
            current_canvas.yview(*args)
            _schedule_debounced_draw_from_scroll_rom()

        def xview_wrapper_debounced_rom(*args):
            current_dialog = getattr(self, 'rom_import_dialog', None)
            if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
            current_canvas = getattr(current_dialog, 'canvas', None)
            if not current_canvas or not current_canvas.winfo_exists(): return
            current_canvas.xview(*args)
            _schedule_debounced_draw_from_scroll_rom()

        rom_v_scroll.config(command=yview_wrapper_debounced_rom)
        rom_h_scroll.config(command=xview_wrapper_debounced_rom)

        dialog.canvas.grid(row=0, column=0, sticky="nsew")
        rom_v_scroll.grid(row=0, column=1, sticky="ns")
        rom_h_scroll.grid(row=1, column=0, sticky="ew")

        buttons_frame = ttk.Frame(main_dialog_frame)
        buttons_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10,0))
        buttons_frame.grid_columnconfigure(0, weight=1)
        buttons_frame.grid_columnconfigure(1, weight=0)
        buttons_frame.grid_columnconfigure(2, weight=0)
        buttons_frame.grid_columnconfigure(3, weight=1)

        dialog.import_button = ttk.Button(
            buttons_frame, text="Import", command=self._execute_rom_tile_import, state=tk.DISABLED
        )
        cancel_button = ttk.Button(
            buttons_frame, text="Cancel", command=self._close_rom_importer_dialog
        )
        dialog.import_button.grid(row=0, column=1, padx=(0,5))
        cancel_button.grid(row=0, column=2, padx=(5,0))

        dialog.canvas.bind("<Configure>", lambda e: self._on_rom_importer_setting_change(configure_event=True))
        dialog.canvas.bind("<Motion>", self._on_rom_canvas_motion)
        dialog.canvas.bind("<Leave>", self._on_rom_canvas_leave)
        dialog.canvas.bind("<Button-1>", self._on_rom_canvas_left_click)
        dialog.canvas.bind("<Button-3>", self._on_rom_canvas_right_click)
        dialog.bind("<Escape>", lambda e: self._clear_rom_import_selection()) 
        dialog.canvas.bind("<FocusIn>", lambda e: None) 
        dialog.canvas.bind("<Key>", self._on_rom_canvas_keypress)
        dialog.canvas.bind("<MouseWheel>", self._on_mousewheel_scroll)
        dialog.canvas.bind("<Button-4>", self._on_mousewheel_scroll)
        dialog.canvas.bind("<Button-5>", self._on_mousewheel_scroll)
        dialog.canvas.focus_set()
        dialog.protocol("WM_DELETE_WINDOW", self._close_rom_importer_dialog)

        self._update_importer_color_swatches()
        dialog.after(50, lambda: self._on_rom_importer_setting_change(configure_event=True))

        dialog.update_idletasks()
        root_w = self.root.winfo_width()
        root_h = self.root.winfo_height()
        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        dialog.update_idletasks() 
        dialog_w = dialog.winfo_reqwidth()
        dialog_h = dialog.winfo_reqheight()
        
        x_pos = root_x + (root_w // 2) - (dialog_w // 2)
        y_pos = root_y + (root_h // 2) - (dialog_h // 2)
        
        screen_width_dialog = dialog.winfo_screenwidth()
        screen_height_dialog = dialog.winfo_screenheight()
        x_pos = max(0, min(x_pos, screen_width_dialog - dialog_w))
        y_pos = max(0, min(y_pos, screen_height_dialog - dialog_h))

        dialog.geometry(f"{dialog_w}x{dialog_h}+{x_pos}+{y_pos}")
        dialog.lift()

    def _close_rom_importer_dialog(self):
        """Closes and cleans up the ROM importer dialog."""
        if self.rom_import_dialog:
            self.rom_import_dialog.grab_release() # Release grab before destroying
            self.rom_import_dialog.destroy()
            self.rom_import_dialog = None # Clear reference

    def _on_rom_importer_setting_change(self, event=None, configure_event=False):
        # Called when fine_offset slider changes or canvas is configured/resized.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        if configure_event:
            _debug(" _on_rom_importer_setting_change: Configure event triggered.")
            
            if not hasattr(dialog, 'redraw_timer_id'): # Ensure attribute exists
                dialog.redraw_timer_id = None

            if dialog.redraw_timer_id is not None:
                dialog.after_cancel(dialog.redraw_timer_id)
            # _perform_debounced_rom_canvas_draw handles clearing its own timer ID
            dialog.redraw_timer_id = dialog.after(150, self._perform_debounced_rom_canvas_draw) # Standard debounce for configure
            return 
        # else:
            # Non-configure events (e.g., direct calls if any, or slider)
            # Slider changes are handled by _on_fine_offset_slider_change which has its own debounce.
            # If this function were to be called directly for an immediate update by something else,
            # then that calling code would be responsible for the context.
            _debug(" _on_rom_importer_setting_change: Non-configure event. No action taken here directly.")
            pass

    def _draw_rom_importer_canvas(self):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        _debug(f"\n ### _draw_rom_importer_canvas ### Pillow Viewport Strategy")

        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            _debug("[D] Canvas gone.")
            return

        rom_data = dialog.rom_data
        global_fine_offset_for_grid = dialog.fine_offset_var.get()
        current_fg_render_idx = getattr(dialog, 'current_importer_fg_idx', WHITE_IDX)
        current_bg_render_idx = getattr(dialog, 'current_importer_bg_idx', BLACK_IDX)
        selection_dict = getattr(dialog, 'rom_importer_selection', {})

        # Canvas viewport dimensions
        canvas_viewport_width = canvas.winfo_width()
        canvas_viewport_height = canvas.winfo_height()

        if canvas_viewport_width <= 1 or canvas_viewport_height <= 1:
            _debug("[D] Canvas too small for Pillow viewport.")
            # Optionally clear canvas or draw a placeholder if needed
            try:
                if canvas.winfo_exists():
                    canvas.delete("all_rom_content")
                    canvas.config(scrollregion=(0,0,1,1))
            except tk.TclError: pass
            self._update_rom_importer_info_labels()
            return

        # Delete old main image content (if any)
        try:
            if canvas.winfo_exists(): canvas.delete("rom_content_image")
        except tk.TclError: _debug("[D] TclError deleting old rom_content_image."); # Continue if possible

        # Display parameters for items in the grid
        tile_display_size = VIEWER_TILE_SIZE # How big each 8x8 ROM tile appears on canvas
        padding = 1

        # Determine number of grid columns based on current canvas width
        current_draw_grid_cols = max(1, canvas_viewport_width // (tile_display_size + padding))
        dialog.rom_importer_grid_cols = current_draw_grid_cols # Store for other functions

        # Calculate total potential tiles from ROM data
        total_potential_tiles = 0
        if len(rom_data) > global_fine_offset_for_grid:
            total_potential_tiles = (len(rom_data) - global_fine_offset_for_grid) // TILE_WIDTH

        if total_potential_tiles <= 0:
            # Handle empty ROM data or offset beyond data length
            try:
                if canvas.winfo_exists():
                    canvas.config(scrollregion=(0,0,1,1))
                    # Create/clear the Pillow viewport even if empty
                    if dialog.pil_rom_viewport_image is None or \
                       dialog.pil_rom_viewport_image.width != canvas_viewport_width or \
                       dialog.pil_rom_viewport_image.height != canvas_viewport_height:
                        dialog.pil_rom_viewport_image = Image.new('RGB', (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), canvas.cget("bg"))
                    else:
                        dialog.pil_rom_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height))
                    
                    dialog.tk_rom_photoimage = ImageTk.PhotoImage(dialog.pil_rom_viewport_image)
                    view_content_x1_empty, view_content_y1_empty = 0,0 
                    try:
                        view_content_x1_empty = canvas.canvasx(0)
                        view_content_y1_empty = canvas.canvasy(0)
                    except tk.TclError: pass
                    canvas.create_image(view_content_x1_empty, view_content_y1_empty, image=dialog.tk_rom_photoimage, anchor=tk.NW, tags=("rom_content_image", "all_rom_content"))
            except tk.TclError: pass
            self._update_rom_importer_info_labels()
            _debug(" ### _draw_rom_importer_canvas END (no potential tiles) ###")
            return

        # Calculate scrollregion based on total content
        num_total_content_rows = math.ceil(total_potential_tiles / current_draw_grid_cols) if current_draw_grid_cols > 0 else 0
        scroll_region_width = current_draw_grid_cols * (tile_display_size + padding) + padding
        scroll_region_height = num_total_content_rows * (tile_display_size + padding) + padding
        scroll_region_width = max(1.0, float(scroll_region_width))
        scroll_region_height = max(1.0, float(scroll_region_height))
        
        current_scroll_region_str = ""
        try:
            sr_val = canvas.cget("scrollregion")
            current_scroll_region_str = " ".join(map(str, sr_val)) if isinstance(sr_val, tuple) else str(sr_val)
        except tk.TclError: pass
        new_scroll_region_str = f"0 0 {scroll_region_width} {scroll_region_height}"
        if current_scroll_region_str != new_scroll_region_str:
            try:
                if canvas.winfo_exists(): canvas.config(scrollregion=(0, 0, scroll_region_width, scroll_region_height))
            except tk.TclError: _debug("[D] TclError setting scrollregion."); return

        # Get current viewport's top-left content coordinates
        view_content_x1 = canvas.canvasx(0)
        view_content_y1 = canvas.canvasy(0)

        # Update top-left grid byte offset label
        # (This logic remains similar, calculating based on visible grid start)
        start_grid_row_idx_for_label = max(0, int(view_content_y1 // (tile_display_size + padding)))
        start_grid_col_idx_for_label = max(0, int(view_content_x1 // (tile_display_size + padding)))
        actual_first_visible_tile_idx_in_data = (start_grid_row_idx_for_label * current_draw_grid_cols) + start_grid_col_idx_for_label
        if not hasattr(dialog, 'top_left_grid_byte_offset'): dialog.top_left_grid_byte_offset = 0
        dialog.top_left_grid_byte_offset = global_fine_offset_for_grid + (actual_first_visible_tile_idx_in_data * TILE_WIDTH)
        if hasattr(dialog, 'top_left_grid_byte_offset_text_var'):
            try:
                dialog.top_left_grid_byte_offset_text_var.set(f"Grid Top-Left Byte: {dialog.top_left_grid_byte_offset} (0x{dialog.top_left_grid_byte_offset:X})")
            except tk.TclError: pass

        # Create/Resize Pillow viewport image buffer
        if dialog.pil_rom_viewport_image is None or \
           dialog.pil_rom_viewport_image.width != canvas_viewport_width or \
           dialog.pil_rom_viewport_image.height != canvas_viewport_height:
            try:
                dialog.pil_rom_viewport_image = Image.new('RGB', (max(1,canvas_viewport_width), max(1,canvas_viewport_height)), canvas.cget("bg"))
                _debug(f"Created/Resized dialog.pil_rom_viewport_image to {canvas_viewport_width}x{canvas_viewport_height}")
            except (ValueError, tk.TclError) as e_pil_new:
                _error(f"Error creating pil_rom_viewport_image: {e_pil_new}"); return
        else:
            # Fill existing image with background color
            try:
                dialog.pil_rom_viewport_image.paste(canvas.cget("bg"), (0,0,canvas_viewport_width,canvas_viewport_height) )
            except Exception as e_fill:
                _error(f"Error filling pil_rom_viewport_image: {e_fill}. Filling with darkgrey.")
                dialog.pil_rom_viewport_image.paste("darkgrey", (0,0,canvas_viewport_width,canvas_viewport_height) )

        # Determine visible grid range
        start_grid_row_idx = max(0, int(view_content_y1 // (tile_display_size + padding)))
        end_grid_row_idx = min(num_total_content_rows, int(math.ceil((view_content_y1 + canvas_viewport_height) / (tile_display_size + padding))))
        
        start_grid_col_idx = max(0, int(view_content_x1 // (tile_display_size + padding)))
        end_grid_col_idx = min(current_draw_grid_cols, int(math.ceil((view_content_x1 + canvas_viewport_width) / (tile_display_size + padding))))
        
        _debug(f"Visible Grid - Rows: {start_grid_row_idx}-{end_grid_row_idx-1}, Cols: {start_grid_col_idx}-{end_grid_col_idx-1}")

        # Temporary 8x8 Pillow image for rendering individual base tiles
        pil_temp_base_tile = Image.new('RGB', (TILE_WIDTH, TILE_HEIGHT))
        # Scale factor for resizing 8x8 to tile_display_size
        # Pillow's resize requires positive dimensions.
        scaled_tile_w_for_pil = max(1, tile_display_size)
        scaled_tile_h_for_pil = max(1, tile_display_size)

        for r_grid in range(start_grid_row_idx, end_grid_row_idx):
            for c_grid in range(start_grid_col_idx, end_grid_col_idx):
                current_rom_tile_absolute_idx = r_grid * current_draw_grid_cols + c_grid
                if current_rom_tile_absolute_idx >= total_potential_tiles:
                    continue

                # Determine FG/BG colors and fine offset for this specific tile
                tile_fg_idx, tile_bg_idx, fine_offset_for_this_tile_render = -1, -1, -1
                if current_rom_tile_absolute_idx in selection_dict:
                    stored_props = selection_dict[current_rom_tile_absolute_idx]
                    tile_fg_idx, tile_bg_idx, fine_offset_for_this_tile_render = stored_props[0], stored_props[1], stored_props[2]
                else:
                    tile_fg_idx = current_fg_render_idx
                    tile_bg_idx = current_bg_render_idx
                    fine_offset_for_this_tile_render = global_fine_offset_for_grid # Use global if not selected

                safe_tile_fg_idx = tile_fg_idx if 0 <= tile_fg_idx < len(self.active_msx_palette) else WHITE_IDX
                safe_tile_bg_idx = tile_bg_idx if 0 <= tile_bg_idx < len(self.active_msx_palette) else BLACK_IDX
                color_for_fg_pixel = self.active_msx_palette[safe_tile_fg_idx]
                color_for_bg_pixel = self.active_msx_palette[safe_tile_bg_idx]

                # Calculate byte start position using the determined fine offset for this tile
                rom_byte_start_pos = fine_offset_for_this_tile_render + (current_rom_tile_absolute_idx * TILE_WIDTH)

                if not (0 <= rom_byte_start_pos < len(rom_data)):
                    _debug(f"[D] Tile {current_rom_tile_absolute_idx} calculated offset {rom_byte_start_pos} out of bounds. Skipping.")
                    continue
                
                bytes_to_read = TILE_HEIGHT # Assuming TILE_WIDTH is bytes per tile, TILE_HEIGHT is rows
                if rom_byte_start_pos + bytes_to_read > len(rom_data):
                    num_bytes_avail = len(rom_data) - rom_byte_start_pos
                    tile_bytes_data = rom_data[rom_byte_start_pos:] + bytes(bytes_to_read - num_bytes_avail) # Pad if short
                else:
                    tile_bytes_data = rom_data[rom_byte_start_pos : rom_byte_start_pos + bytes_to_read]

                # Render the 8x8 tile onto pil_temp_base_tile
                pixel_data_for_base_tile = []
                for y_pixel_in_base in range(TILE_HEIGHT):
                    if y_pixel_in_base >= len(tile_bytes_data): break # Should not happen with padding
                    row_byte = tile_bytes_data[y_pixel_in_base]
                    for x_pixel_in_base in range(TILE_WIDTH):
                        pixel_val = (row_byte >> (7 - x_pixel_in_base)) & 1
                        hex_color_to_use = color_for_fg_pixel if pixel_val == 1 else color_for_bg_pixel
                        try:
                            r_int = int(hex_color_to_use[1:3], 16)
                            g_int = int(hex_color_to_use[3:5], 16)
                            b_int = int(hex_color_to_use[5:7], 16)
                            pixel_data_for_base_tile.append((r_int, g_int, b_int))
                        except ValueError:
                            pixel_data_for_base_tile.append((255,0,255)) # Magenta for error

                if len(pixel_data_for_base_tile) == TILE_WIDTH * TILE_HEIGHT:
                    pil_temp_base_tile.putdata(pixel_data_for_base_tile)

                    # Scale the 8x8 temporary image
                    pil_scaled_base_tile = pil_temp_base_tile.resize(
                        (scaled_tile_w_for_pil, scaled_tile_h_for_pil),
                        Image.Resampling.NEAREST
                    )

                    # Calculate paste position on the pil_rom_viewport_image
                    # This is the tile's top-left on the viewport image, relative to (0,0) of the viewport image
                    paste_x_on_viewport_img = round((c_grid * (tile_display_size + padding) + padding) - view_content_x1)
                    paste_y_on_viewport_img = round((r_grid * (tile_display_size + padding) + padding) - view_content_y1)
                    
                    dialog.pil_rom_viewport_image.paste(pil_scaled_base_tile, (paste_x_on_viewport_img, paste_y_on_viewport_img))
                else:
                    _debug(f"[D] Incorrect pixel data length for tile {current_rom_tile_absolute_idx}. Skipping paste.")


        # Convert Pillow viewport image to Tk PhotoImage and display
        try:
            dialog.tk_rom_photoimage = ImageTk.PhotoImage(dialog.pil_rom_viewport_image)
        except Exception as e_photoimg:
            _error(f"Error converting PIL to Tk PhotoImage for ROM importer: {e_photoimg}"); return

        try:
            if canvas.winfo_exists():
                canvas.create_image(view_content_x1, view_content_y1,
                                    image=dialog.tk_rom_photoimage,
                                    anchor=tk.NW,
                                    tags=("rom_content_image", "all_rom_content"))
        except tk.TclError as e_create_img:
            _debug(f"[D] TclError creating canvas image for ROM importer: {e_create_img}")

        # Redraw selection highlights on top
        self._draw_rom_import_selection_highlight(grid_cols_for_this_draw=current_draw_grid_cols)
        self._update_rom_importer_info_labels()

        if canvas.winfo_exists():
            canvas.update_idletasks() # Ensure image is drawn before method returns

        _debug(" ### _draw_rom_importer_canvas END ### Pillow Viewport Strategy")

    def _draw_rom_import_selection_highlight(self, grid_cols_for_this_draw=None):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            _debug(" Highlight: Canvas widget no longer exists. Aborting.")
            return

        try:
            canvas.delete("rom_selection_border")
        except tk.TclError:
            _debug(" Highlight: TclError deleting 'rom_selection_border'. Ignoring.")

        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if not selection_dict:
            _debug(" Highlight: No selection in selection_dict. Nothing to highlight.")
            return 
        
        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        
        current_grid_cols = 0
        if grid_cols_for_this_draw is not None and grid_cols_for_this_draw > 0:
            current_grid_cols = grid_cols_for_this_draw
        else:
            current_grid_cols = getattr(dialog, 'rom_importer_grid_cols', 1)
            if current_grid_cols <= 0: 
                canvas_width_current = 0
                try:
                    if canvas.winfo_exists(): canvas_width_current = canvas.winfo_width()
                except tk.TclError: _debug(" Highlight: TclError getting canvas_width for fallback."); return
                if canvas_width_current <= 1 : _debug(" Highlight: canvas_width too small for fallback."); return
                current_grid_cols = max(1, canvas_width_current // (tile_display_size + padding))
            _debug(f" Highlight: Using fallback/dialog grid_cols: {current_grid_cols}")
        
        if current_grid_cols <= 0:
            _debug(" Highlight: current_grid_cols is zero or negative. Cannot draw highlights.")
            return

        main_image_items = canvas.find_withtag("rom_content_image")
        
        for selected_tile_idx in selection_dict.keys():
            if not isinstance(selected_tile_idx, int) or selected_tile_idx < 0:
                continue

            grid_r_content, grid_c_content = divmod(selected_tile_idx, current_grid_cols)

            tile_box_content_x1 = grid_c_content * (tile_display_size + padding) + padding
            tile_box_content_y1 = grid_r_content * (tile_display_size + padding) + padding
            tile_box_content_x2 = tile_box_content_x1 + tile_display_size
            tile_box_content_y2 = tile_box_content_y1 + tile_display_size
            
            try:
                if canvas.winfo_exists():
                    rect_id = canvas.create_rectangle(
                        tile_box_content_x1, tile_box_content_y1, 
                        tile_box_content_x2, tile_box_content_y2,
                        outline="yellow", width=1, 
                        tags=("rom_selection_border", "all_rom_content") 
                    )
                    if main_image_items:
                        canvas.tag_raise(rect_id, main_image_items[0]) 
            except tk.TclError as e_rect:
                _debug(f" Highlight: TclError creating rectangle for Idx {selected_tile_idx}: {e_rect}")
                break 
        
        _debug(" --- _draw_rom_import_selection_highlight END ---")

    def _on_rom_canvas_motion(self, event):
        """Handles mouse motion over the ROM importer canvas for hover info and preview."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists(): return

        rom_data = dialog.rom_data
        fine_offset = dialog.fine_offset_var.get()

        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        
        canvas_width_current = 0
        try:
            if canvas.winfo_exists():
                canvas_width_current = canvas.winfo_width()
        except tk.TclError: return

        if canvas_width_current <= 1: return
        tiles_across = max(1, canvas_width_current // (tile_display_size + padding))

        cx = canvas.canvasx(event.x)
        cy = canvas.canvasy(event.y)
        
        clicked_grid_col = int(cx // (tile_display_size + padding)) # Renamed for clarity, though not a click
        clicked_grid_row = int(cy // (tile_display_size + padding))
        hovered_rom_tile_absolute_idx = clicked_grid_row * tiles_across + clicked_grid_col
        
        total_potential_tiles = 0
        if len(rom_data) > fine_offset:
            total_potential_tiles = (len(rom_data) - fine_offset) // TILE_WIDTH
        
        # Make sure hovered_rom_tile_absolute_idx is valid before proceeding
        is_valid_hover_idx = (0 <= hovered_rom_tile_absolute_idx < total_potential_tiles)

        if is_valid_hover_idx:
            hovered_byte_start_pos = fine_offset + (hovered_rom_tile_absolute_idx * TILE_WIDTH)
            
            if hasattr(dialog, 'hover_info_text_var') and isinstance(dialog.hover_info_text_var, tk.StringVar):
                try:
                    dialog.hover_info_text_var.set(
                        f"Offset: {hovered_byte_start_pos} (0x{hovered_byte_start_pos:X}) | Grid Index: {hovered_rom_tile_absolute_idx}"
                    )
                except tk.TclError: pass # Dialog might be closing
            # Pass hovered_rom_tile_absolute_idx to the preview function
            self._draw_rom_tile_preview(hovered_byte_start_pos, hovered_rom_tile_absolute_idx)
        else:
            if hasattr(dialog, 'hover_info_text_var') and isinstance(dialog.hover_info_text_var, tk.StringVar):
                try:
                    dialog.hover_info_text_var.set("Offset: N/A | Grid Index: N/A")
                except tk.TclError: pass
            
            preview_canvas = getattr(dialog, 'preview_canvas', None)
            if preview_canvas and preview_canvas.winfo_exists():
                try:
                    preview_canvas.delete("all")
                except tk.TclError: pass

    def _on_rom_canvas_leave(self, event):
        """Clears hover info and preview when mouse leaves ROM importer canvas."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        self.rom_import_dialog.hover_info_text_var.set("Offset: N/A | Grid Index: N/A")
        if hasattr(self.rom_import_dialog, 'preview_canvas'): # Check if preview_canvas exists
             self.rom_import_dialog.preview_canvas.delete("all")

    def _on_rom_canvas_left_click(self, event):
        # Handles left-click on ROM importer canvas for complex selection.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            return

        rom_data = dialog.rom_data
        current_global_fine_offset = dialog.fine_offset_var.get() 
        tile_display_size = VIEWER_TILE_SIZE
        padding = 1
        canvas_width_current = 0
        try:
            if canvas.winfo_exists(): canvas_width_current = canvas.winfo_width()
        except tk.TclError: return
        if canvas_width_current <=1: return
        
        # Use dialog.rom_importer_grid_cols as it should be up-to-date from the last full draw
        # If it's the very first click before any draw, this might need a default.
        # The _create_rom_importer_dialog now initializes dialog.rom_importer_grid_cols.
        tiles_across = getattr(dialog, 'rom_importer_grid_cols', max(1, canvas_width_current // (tile_display_size + padding)))
        if tiles_across <= 0: tiles_across = 1 # Ensure positive

        cx = canvas.canvasx(event.x)
        cy = canvas.canvasy(event.y)
        clicked_grid_col = int(cx // (tile_display_size + padding))
        clicked_grid_row = int(cy // (tile_display_size + padding))
        clicked_rom_tile_absolute_idx = clicked_grid_row * tiles_across + clicked_grid_col

        total_potential_tiles = 0
        fine_offset_for_total_calc = dialog.fine_offset_var.get()
        if len(rom_data) > fine_offset_for_total_calc :
            total_potential_tiles = (len(rom_data) - fine_offset_for_total_calc) // TILE_WIDTH
        if not (0 <= clicked_rom_tile_absolute_idx < total_potential_tiles):
            _debug(f" Click outside valid tile area. Clicked index: {clicked_rom_tile_absolute_idx}, Total potential: {total_potential_tiles}")
            return


        is_shift_pressed = (event.state & 0x0001) != 0
        is_ctrl_pressed = (event.state & 0x0004) != 0
        selection_dict = dialog.rom_importer_selection
        current_anchor_idx = dialog.rom_importer_anchor_idx
        fg_to_associate = dialog.current_importer_fg_idx
        bg_to_associate = dialog.current_importer_bg_idx
        offset_to_associate = current_global_fine_offset # Use current global offset from slider
        properties_tuple_to_associate = (fg_to_associate, bg_to_associate, offset_to_associate)

        _debug(f"\n _on_rom_canvas_left_click: Clicked Idx: {clicked_rom_tile_absolute_idx}")
        _debug(f" Tiles Across used for click logic: {tiles_across}")
        _debug(f" Shift: {is_shift_pressed}, Ctrl: {is_ctrl_pressed}")
        _debug(f" Current Anchor: {current_anchor_idx}")
        _debug(f" Props to associate: {properties_tuple_to_associate}")
        _debug(f" Selection BEFORE: {dict(selection_dict)}") # Less verbose

        selection_changed_in_dict = False # More specific flag

        if is_ctrl_pressed and is_shift_pressed:
            _debug(" Path: Ctrl+Shift+Click")
            # ... (Ctrl+Shift logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            anchor_props_to_use = properties_tuple_to_associate # Default to current
            if current_anchor_idx != -1 and current_anchor_idx in selection_dict:
                anchor_props_to_use = selection_dict[current_anchor_idx]
                _debug(f" Ctrl+Shift: Using properties {anchor_props_to_use} from anchor {current_anchor_idx}.")
            else:
                 _debug(f" Ctrl+Shift: No/Invalid anchor, using current global properties {anchor_props_to_use}.")

            min_idx = min(current_anchor_idx if current_anchor_idx != -1 else clicked_rom_tile_absolute_idx, clicked_rom_tile_absolute_idx)
            max_idx = max(current_anchor_idx if current_anchor_idx != -1 else clicked_rom_tile_absolute_idx, clicked_rom_tile_absolute_idx)
            for i in range(min_idx, max_idx + 1):
                if i not in selection_dict or selection_dict[i] != anchor_props_to_use:
                    selection_dict[i] = anchor_props_to_use
                    selection_changed_in_dict = True
            if current_anchor_idx == -1: # Set anchor if it was not set
                 dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
                 # selection_changed_in_dict = True # Anchor change is part of selection state
        elif is_shift_pressed:
            _debug(" Path: Shift+Click")
            # ... (Shift logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            if current_anchor_idx != -1:
                new_range_selection = {}
                min_idx = min(current_anchor_idx, clicked_rom_tile_absolute_idx)
                max_idx = max(current_anchor_idx, clicked_rom_tile_absolute_idx)
                for i in range(min_idx, max_idx + 1):
                    new_range_selection[i] = properties_tuple_to_associate
                if selection_dict != new_range_selection: # Compare content
                    selection_dict.clear()
                    selection_dict.update(new_range_selection)
                    selection_changed_in_dict = True
            else: # No anchor, treat as normal click for selection, but set anchor
                if not (len(selection_dict) == 1 and clicked_rom_tile_absolute_idx in selection_dict and selection_dict[clicked_rom_tile_absolute_idx] == properties_tuple_to_associate):
                    selection_dict.clear()
                    selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                    selection_changed_in_dict = True
                dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
        elif is_ctrl_pressed:
            _debug(" Path: Ctrl+Click")
            # ... (Ctrl logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            if clicked_rom_tile_absolute_idx in selection_dict:
                del selection_dict[clicked_rom_tile_absolute_idx]
                selection_changed_in_dict = True
                if dialog.rom_importer_anchor_idx == clicked_rom_tile_absolute_idx:
                    dialog.rom_importer_anchor_idx = -1 
            else:
                selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                selection_changed_in_dict = True
            # Set/update anchor if adding to selection or if it's the only one left
            if clicked_rom_tile_absolute_idx in selection_dict and dialog.rom_importer_anchor_idx != clicked_rom_tile_absolute_idx :
                 dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx
            elif not selection_dict : # If selection became empty
                 dialog.rom_importer_anchor_idx = -1

        else: # Normal Click
            _debug(" Path: Normal Click")
            # ... (Normal click logic - same as before, ensure it sets selection_changed_in_dict = True if modified)
            is_already_solely_selected_with_same_props = (
                len(selection_dict) == 1 and
                clicked_rom_tile_absolute_idx in selection_dict and
                selection_dict[clicked_rom_tile_absolute_idx] == properties_tuple_to_associate
            )
            if not is_already_solely_selected_with_same_props:
                selection_dict.clear()
                selection_dict[clicked_rom_tile_absolute_idx] = properties_tuple_to_associate
                selection_changed_in_dict = True
            dialog.rom_importer_anchor_idx = clicked_rom_tile_absolute_idx

        # Check if anchor changed, that also means UI state change
        anchor_state_changed = (dialog.rom_importer_anchor_idx != current_anchor_idx)
        
        _debug(f" Selection AFTER: {dict(selection_dict)}")
        _debug(f" New Anchor: {dialog.rom_importer_anchor_idx}")

        # If selection dict content or anchor changed, then update UI
        if selection_changed_in_dict or anchor_state_changed:
            if hasattr(dialog, 'import_button') and dialog.import_button.winfo_exists():
                dialog.import_button.config(state=tk.NORMAL if selection_dict else tk.DISABLED)
            
            self._update_rom_importer_info_labels() # Updates text vars

            _debug(" Selection/Anchor changed. Triggering full canvas redraw.")
            # Ensure the redraw uses the most recent canvas size if it changed just before click
            # This can be done by calling the configure handler's logic, or just draw
            # self._on_rom_importer_setting_change(configure_event=True) # This will debounce
            # For immediate reflection of selection:
            if canvas.winfo_exists() and canvas.winfo_width() > 1 and canvas.winfo_height() > 1:
                 self._draw_rom_importer_canvas() # Direct call
            else: # If canvas not ready, rely on a later configure event to draw
                 _debug(" Canvas not ready after click, deferring full redraw to configure event.")
        else:
            _debug(" No change in selection_dict content or anchor. Skipping UI updates from click.")

    def _on_rom_canvas_right_click(self, event):
        """Handles right-click on ROM importer canvas to cancel selection."""
        self._clear_rom_import_selection()

    def _clear_rom_import_selection(self):
        # Clears the current tile selection in the ROM importer dialog.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        dialog = self.rom_import_dialog
        
        selection_was_present = bool(getattr(dialog, 'rom_importer_selection', {}))
        anchor_was_present = (getattr(dialog, 'rom_importer_anchor_idx', -1) != -1)

        if hasattr(dialog, 'rom_importer_selection'):
            dialog.rom_importer_selection.clear()
        else:
            dialog.rom_importer_selection = {} # Ensure it exists
            
        dialog.rom_importer_anchor_idx = -1
            
        if hasattr(dialog, 'import_button') and dialog.import_button.winfo_exists():
            dialog.import_button.config(state=tk.DISABLED) 
        
        self._update_rom_importer_info_labels() # Update text vars

        # If there was a selection or anchor, a redraw is needed to remove highlights
        if selection_was_present or anchor_was_present:
            _debug(" Selection cleared. Triggering full canvas redraw.")
            canvas = getattr(dialog, 'canvas', None)
            if canvas and canvas.winfo_exists() and canvas.winfo_width() > 1 and canvas.winfo_height() > 1:
                self._draw_rom_importer_canvas() # Redraw to remove highlights
            else:
                _debug(" Canvas not ready after clearing selection, deferring redraw.")
        # else: # No selection was present, _draw_rom_import_selection_highlight would do nothing anyway
        #    self._draw_rom_import_selection_highlight() # Call to ensure no stale borders if logic changes

    def _update_rom_importer_info_labels(self):
        """Updates dynamic labels in the ROM importer (selected count, top-left byte)."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        
        count = 0
        if hasattr(dialog, 'rom_importer_selection'):
            count = len(dialog.rom_importer_selection)
        
        if hasattr(dialog, 'selection_info_text_var') and isinstance(dialog.selection_info_text_var, tk.StringVar):
            try:
                dialog.selection_info_text_var.set(f"Tiles Selected: {count}")
            except tk.TclError: # Can happen if dialog is closing
                pass
        # top_left_grid_byte_offset_text_var is updated in _draw_rom_importer_canvas

    def _draw_rom_tile_preview(self, rom_byte_start_pos_hover, hovered_rom_tile_absolute_idx=-1):
        """Draws a single tile from ROM data into the preview canvas, using appropriate colors and offset."""
        # rom_byte_start_pos_hover is calculated based on the GLOBAL fine offset for hover info
        # We need to recalculate it here if the tile is selected and has its own offset.

        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog) or \
           not hasattr(self.rom_import_dialog, 'preview_canvas'):
            return

        preview_canvas = self.rom_import_dialog.preview_canvas
        rom_data = self.rom_import_dialog.rom_data
        dialog = self.rom_import_dialog
        preview_canvas.delete("all")

        # Determine FG/BG colors and the FINE OFFSET for this preview
        preview_fg_idx = getattr(dialog, 'current_importer_fg_idx', WHITE_IDX)
        preview_bg_idx = getattr(dialog, 'current_importer_bg_idx', BLACK_IDX)
        fine_offset_for_preview = dialog.fine_offset_var.get() # Default to global slider

        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if hovered_rom_tile_absolute_idx != -1 and hovered_rom_tile_absolute_idx in selection_dict:
            stored_props = selection_dict[hovered_rom_tile_absolute_idx]
            preview_fg_idx, preview_bg_idx, fine_offset_for_preview = stored_props[0], stored_props[1], stored_props[2]

        # Recalculate the actual starting byte position using the determined fine_offset_for_preview
        # hovered_rom_tile_absolute_idx is the tile's index in the grid if the global offset were 0.
        actual_rom_byte_start_for_preview = fine_offset_for_preview + (hovered_rom_tile_absolute_idx * TILE_WIDTH)

        if not (0 <= actual_rom_byte_start_for_preview < len(rom_data)):
            _debug(f" Preview: Invalid actual_rom_byte_start_for_preview {actual_rom_byte_start_for_preview} for tile_idx {hovered_rom_tile_absolute_idx} with offset {fine_offset_for_preview}. Skipping preview.")
            return # Cannot draw if calculated offset is out of bounds

        safe_preview_fg_idx = preview_fg_idx if 0 <= preview_fg_idx < len(self.active_msx_palette) else WHITE_IDX
        safe_preview_bg_idx = preview_bg_idx if 0 <= preview_bg_idx < len(self.active_msx_palette) else BLACK_IDX
        color_for_fg_pixel_preview = self.active_msx_palette[safe_preview_fg_idx]
        color_for_bg_pixel_preview = self.active_msx_palette[safe_preview_bg_idx]

        if actual_rom_byte_start_for_preview + TILE_WIDTH > len(rom_data):
            num_bytes_avail = len(rom_data) - actual_rom_byte_start_for_preview
            tile_bytes_data = rom_data[actual_rom_byte_start_for_preview:] + bytes(TILE_WIDTH - num_bytes_avail)
        else:
            tile_bytes_data = rom_data[actual_rom_byte_start_for_preview : actual_rom_byte_start_for_preview + TILE_WIDTH]

        pixel_render_size = EDITOR_PIXEL_SIZE
        for r_tile_pixel in range(TILE_HEIGHT):
            if r_tile_pixel >= len(tile_bytes_data): continue
            row_byte = tile_bytes_data[r_tile_pixel]
            for c_tile_pixel in range(TILE_WIDTH):
                pixel_is_set = (row_byte >> (7 - c_tile_pixel)) & 1
                color_hex = color_for_fg_pixel_preview if pixel_is_set else color_for_bg_pixel_preview

                x1 = c_tile_pixel * pixel_render_size
                y1 = r_tile_pixel * pixel_render_size
                x2 = x1 + pixel_render_size
                y2 = y1 + pixel_render_size
                try:
                    if preview_canvas.winfo_exists():
                        preview_canvas.create_rectangle(x1, y1, x2, y2, fill=color_hex, outline="grey")
                except tk.TclError:
                    return

    def _on_rom_canvas_keypress(self, event):
        # Handles keyboard navigation for the ROM importer canvas.
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        canvas = getattr(self.rom_import_dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            return
        
        dialog = self.rom_import_dialog # Get dialog reference
        key_pressed = event.keysym
        _debug(f" Keypress: {key_pressed}") # Keep for now if needed

        action_taken = False
        native_scroll_performed = False 

        if key_pressed == "Up":
            canvas.yview_scroll(-1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Down":
            canvas.yview_scroll(1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Left":
            canvas.xview_scroll(-1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Right":
            canvas.xview_scroll(1, "units")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Prior": # PageUp
            canvas.yview_scroll(-1, "pages")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Next": # PageDown
            canvas.yview_scroll(1, "pages")
            action_taken = True; native_scroll_performed = True
        elif key_pressed == "Home":
            current_x_frac, _ = canvas.xview()
            if current_x_frac != 0.0: canvas.xview_moveto(0.0); native_scroll_performed = True
            current_y_frac, _ = canvas.yview()
            if current_y_frac != 0.0: canvas.yview_moveto(0.0); native_scroll_performed = True
            action_taken = True
        elif key_pressed == "End":
            current_x_frac, _ = canvas.xview()
            if current_x_frac < 1.0: canvas.xview_moveto(1.0); native_scroll_performed = True
            current_y_frac, _ = canvas.yview()
            if current_y_frac < 1.0: canvas.yview_moveto(1.0); native_scroll_performed = True
            action_taken = True
        else:
            return 

        if action_taken:
            # If a native scroll was performed, or for Home/End, schedule a debounced redraw
            if native_scroll_performed or key_pressed in ["Home", "End"]:
                _debug(f" Keypress '{key_pressed}': Scheduling debounced _draw_rom_importer_canvas.")
                
                # Use dialog.redraw_timer_id for consistency with <Configure>
                if not hasattr(dialog, 'redraw_timer_id'): # Should have been init in _create_dialog
                    dialog.redraw_timer_id = None

                if dialog.redraw_timer_id is not None:
                    dialog.after_cancel(dialog.redraw_timer_id)
                
                # Perform_debounced_rom_canvas_draw already exists and calls _draw_rom_importer_canvas
                # It also clears its own timer ID.
                dialog.redraw_timer_id = dialog.after(30, self._perform_debounced_rom_canvas_draw) # 30ms delay
        return "break"

    def _execute_rom_tile_import(self):
        """
        Reads selected tile data from ROM and appends to the main tileset.
        This operation is now fully undoable.
        """
        global current_tile_index, tileset_patterns, tileset_colors

        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        selection_dict = getattr(dialog, 'rom_importer_selection', {})
        if not selection_dict:
            messagebox.showwarning("Import Error", "No tiles selected from ROM.", parent=dialog)
            return

        rom_data = dialog.rom_data
        sorted_selected_items = sorted(selection_dict.items(), key=lambda item: item[0])
        num_tiles_to_import_attempt = len(sorted_selected_items)
        
        # --- Prepare data and commands without modifying global state yet ---
        commands_to_execute = []
        tiles_to_add_patterns = []
        tiles_to_add_colors = []
        
        for current_rom_tile_absolute_idx, (fg_idx, bg_idx, fine_offset) in sorted_selected_items:
            current_tileset_size = len(tileset_patterns) + len(tiles_to_add_patterns)
            if current_tileset_size >= self.project_tile_limit:
                messagebox.showinfo(
                    "Import Limit Reached",
                    f"Project tileset limit of {self.project_tile_limit} reached.\n"
                    f"Staged {len(tiles_to_add_patterns)} of {num_tiles_to_import_attempt} selected tiles for import.",
                    parent=dialog
                )
                break

            rom_byte_start_pos = fine_offset + (current_rom_tile_absolute_idx * TILE_WIDTH)
            if not (0 <= rom_byte_start_pos < len(rom_data)):
                _debug(f"ROM Import: Skipping out-of-bounds tile index {current_rom_tile_absolute_idx}")
                continue

            new_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
            new_colors = [(fg_idx, bg_idx) for _ in range(TILE_HEIGHT)]

            bytes_to_read = TILE_HEIGHT
            if rom_byte_start_pos + bytes_to_read > len(rom_data):
                num_bytes_avail = len(rom_data) - rom_byte_start_pos
                tile_bytes = rom_data[rom_byte_start_pos:] + bytes(bytes_to_read - num_bytes_avail)
            else:
                tile_bytes = rom_data[rom_byte_start_pos : rom_byte_start_pos + bytes_to_read]

            for r in range(TILE_HEIGHT):
                if r < len(tile_bytes):
                    row_byte = tile_bytes[r]
                    for c in range(TILE_WIDTH):
                        new_pattern[r][c] = (row_byte >> (7 - c)) & 1
            
            tiles_to_add_patterns.append(new_pattern)
            tiles_to_add_colors.append(new_colors)

        if not tiles_to_add_patterns:
            messagebox.showwarning("Import Notice",
                                   "No new tiles were imported. Tileset might be full or selected ROM data was out of bounds.",
                                   parent=self.root)
            self._close_rom_importer_dialog()
            return
            
        # --- Create the Undoable Commands ---
        
        # Clear any "Marked Unused" highlights before proceeding
        self._clear_marked_unused(trigger_redraw=False)

        first_new_tile_idx = len(tileset_patterns)
        
        for i in range(len(tiles_to_add_patterns)):
            new_idx = len(tileset_patterns) + i
            commands_to_execute.append(ModifyListCommand("Import Tile", tileset_patterns, new_idx, tiles_to_add_patterns[i], is_insert=True))
            commands_to_execute.append(ModifyListCommand("Import Tile", tileset_colors, new_idx, tiles_to_add_colors[i], is_insert=True))
        
        old_state = (current_tile_index,)
        new_state = (first_new_tile_idx,)
        def state_setter(state):
            global current_tile_index
            current_tile_index = state[0]
        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)
        commands_to_execute.append(state_command)

        def post_import_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            if hasattr(self, 'notebook') and hasattr(self, 'tab_tile_editor'):
                try: self.notebook.select(self.tab_tile_editor)
                except tk.TclError: pass
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            self._request_color_usage_refresh()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

        composite = CompositeCommand(f"Import {len(tiles_to_add_patterns)} Tiles", commands_to_execute, app_ref=self, post_hooks=[post_import_hooks])
        
        # Close dialog *before* executing the command
        self._close_rom_importer_dialog()
        
        # Now execute the entire import as one undoable action
        self.undo_manager.execute(composite)
        
        final_message = f"Successfully imported {len(tiles_to_add_patterns)} tile(s)."
        if len(tiles_to_add_patterns) < num_tiles_to_import_attempt:
            final_message += f"\n({num_tiles_to_import_attempt - len(tiles_to_add_patterns)} tiles were not imported due to limits.)"
        messagebox.showinfo("Import Successful", final_message, parent=self.root)

    def _get_zoomed_supertile_pixel_dims(self):
        """
        Calculates the pixel width and height of one supertile on the map canvas
        at the current zoom level, based on the project's supertile dimensions.
        Returns a tuple (width_pixels, height_pixels).
        """
        zoomed_tile_size = self.get_zoomed_tile_size() # This is pixels per TILE_WIDTH/TILE_HEIGHT (8x8) unit

        if zoomed_tile_size <= 0: # Defensive check
            return 0, 0

        zoomed_supertile_pixel_width = self.supertile_grid_width * zoomed_tile_size
        zoomed_supertile_pixel_height = self.supertile_grid_height * zoomed_tile_size
        
        # Ensure minimum 1 pixel if dimensions are very small but > 0
        zoomed_supertile_pixel_width = max(1, zoomed_supertile_pixel_width)
        zoomed_supertile_pixel_height = max(1, zoomed_supertile_pixel_height)

        return zoomed_supertile_pixel_width, zoomed_supertile_pixel_height

    def _update_supertile_rotate_button_state(self):
        """
        Updates the state of the supertile rotate button based on whether
        the current supertile dimensions are square.
        """
        if hasattr(self, 'st_rotate_button') and self.st_rotate_button.winfo_exists():
            try:
                if self.supertile_grid_width == self.supertile_grid_height:
                    self.st_rotate_button.config(state=tk.NORMAL)
                else:
                    self.st_rotate_button.config(state=tk.DISABLED)
            except tk.TclError:
                # Widget might be in the process of being destroyed, or not fully ready
                pass
        # else: button doesn't exist yet, will be configured when created

    def _reconfigure_supertile_definition_canvas(self):
        """
        Reconfigures the size of the supertile definition canvas based on the
        current self.supertile_grid_width and self.supertile_grid_height.
        Then redraws its content.
        """
        if hasattr(self, 'supertile_def_canvas') and self.supertile_def_canvas.winfo_exists():
            try:
                # SUPERTILE_DEF_TILE_SIZE is the display size of one mini-tile (e.g., 32)
                new_canvas_w = self.supertile_grid_width * SUPERTILE_DEF_TILE_SIZE
                new_canvas_h = self.supertile_grid_height * SUPERTILE_DEF_TILE_SIZE
                
                # Ensure minimum practical size for the canvas
                new_canvas_w = max(SUPERTILE_DEF_TILE_SIZE, new_canvas_w) # Min width of one mini-tile
                new_canvas_h = max(SUPERTILE_DEF_TILE_SIZE, new_canvas_h) # Min height of one mini-tile

                self.supertile_def_canvas.config(width=new_canvas_w, height=new_canvas_h)
                
                # The scrollregion for this canvas might not be strictly necessary if it's always
                # sized to fit its content perfectly and doesn't scroll.
                # If it were to scroll (e.g., fixed size canvas viewing larger def),
                # then scrollregion would need update: self.supertile_def_canvas.config(scrollregion=(0,0,new_canvas_w, new_canvas_h))

                self.draw_supertile_definition_canvas() # Redraw content after resize
            except tk.TclError:
                _debug("TclError during supertile definition canvas reconfiguration.")
                pass
            except Exception as e:
                _error(f"Error reconfiguring supertile definition canvas: {e}")
                pass
        # else: canvas not yet created or already destroyed.


    def create_map_render_of_supertile(self, supertile_index, target_render_width, target_render_height):
        # Creates a Pillow Image for a supertile, scaled to target_render_width/height.
        # Cache now stores Pillow.Image objects.

        safe_target_render_width = max(1, int(target_render_width))
        safe_target_render_height = max(1, int(target_render_height))

        cache_key = (supertile_index, safe_target_render_width, safe_target_render_height, 
                     self.supertile_grid_width, self.supertile_grid_height)
        
        if cache_key in self.map_render_cache:
            return self.map_render_cache[cache_key]

        # Create a Pillow Image for the entire scaled supertile
        # Use 'RGB' mode. If alpha is needed later, can change to 'RGBA'.
        try:
            # Ensure dimensions are positive for Image.new
            pil_supertile_image = Image.new('RGB', 
                                          (max(1, safe_target_render_width), max(1, safe_target_render_height)), 
                                          INVALID_SUPERTILE_COLOR) # Fill with invalid color initially
        except ValueError as e_img_new: # e.g. negative size if calculations somehow fail
            _error(f"Error creating Pillow image for supertile {supertile_index} (size {safe_target_render_width}x{safe_target_render_height}): {e_img_new}")
            # Return a minimal placeholder Pillow image on error
            placeholder_pil = Image.new('RGB', (1,1), INVALID_SUPERTILE_COLOR)
            self.map_render_cache[cache_key] = placeholder_pil # Cache placeholder to avoid re-erroring
            return placeholder_pil


        if not (0 <= supertile_index < len(supertiles_data)):
            # Already filled with INVALID_SUPERTILE_COLOR
            self.map_render_cache[cache_key] = pil_supertile_image
            return pil_supertile_image

        definition = supertiles_data[supertile_index]
        src_st_tile_grid_w = self.supertile_grid_width
        src_st_tile_grid_h = self.supertile_grid_height

        if src_st_tile_grid_w <= 0 or src_st_tile_grid_h <= 0:
            self.map_render_cache[cache_key] = pil_supertile_image # Already filled with invalid
            return pil_supertile_image
        
        if len(definition) != src_st_tile_grid_h or \
           (src_st_tile_grid_h > 0 and (len(definition[0]) != src_st_tile_grid_w)):
            _debug(f" Supertile {supertile_index} dim mismatch for map render.")
            self.map_render_cache[cache_key] = pil_supertile_image # Already filled with invalid
            return pil_supertile_image

        # Size of one base 8x8 tile when scaled to fit within the target_render_width/height
        scaled_base_tile_w = safe_target_render_width / src_st_tile_grid_w
        scaled_base_tile_h = safe_target_render_height / src_st_tile_grid_h

        # Ensure scaled base tile dimensions are at least 1 pixel for Pillow's resize
        # Pillow's resize to (0,0) or (0,X) or (X,0) might error or produce unexpected results.
        # We round them, then ensure they are at least 1.
        final_scaled_base_tile_w = max(1, round(scaled_base_tile_w))
        final_scaled_base_tile_h = max(1, round(scaled_base_tile_h))


        # Temporary 8x8 Pillow image for rendering individual base tiles
        pil_temp_base_tile = Image.new('RGB', (TILE_WIDTH, TILE_HEIGHT))

        for r_st_def in range(src_st_tile_grid_h): # Row in supertile definition
            for c_st_def in range(src_st_tile_grid_w): # Col in supertile definition
                tile_idx_from_st_def = definition[r_st_def][c_st_def]
                
                pixel_data_for_base_tile = [] # Flat list of (r,g,b) tuples for 8x8 tile
                valid_tile = True

                if not (0 <= tile_idx_from_st_def < len(tileset_patterns)):
                    valid_tile = False
                else:
                    pattern = tileset_patterns[tile_idx_from_st_def]
                    colors = tileset_colors[tile_idx_from_st_def]

                    for y_pixel_in_base in range(TILE_HEIGHT): # 0-7
                        if not (y_pixel_in_base < len(pattern) and y_pixel_in_base < len(colors)):
                            valid_tile = False; break # Malformed tile data
                        
                        fg_idx, bg_idx = colors[y_pixel_in_base]
                        if not (0 <= fg_idx < len(self.active_msx_palette) and \
                                0 <= bg_idx < len(self.active_msx_palette)):
                            fg_color_hex = INVALID_TILE_COLOR; bg_color_hex = INVALID_TILE_COLOR
                        else:
                            fg_color_hex = self.active_msx_palette[fg_idx]
                            bg_color_hex = self.active_msx_palette[bg_idx]

                        row_pattern_data = pattern[y_pixel_in_base]
                        if not (len(row_pattern_data) == TILE_WIDTH):
                            valid_tile = False; break # Malformed tile row

                        for x_pixel_in_base in range(TILE_WIDTH): # 0-7
                            pixel_val = row_pattern_data[x_pixel_in_base]
                            color_hex_to_use = fg_color_hex if pixel_val == 1 else bg_color_hex
                            try:
                                # Pillow needs RGB tuples, not hex strings for putdata
                                r_int = int(color_hex_to_use[1:3], 16)
                                g_int = int(color_hex_to_use[3:5], 16)
                                b_int = int(color_hex_to_use[5:7], 16)
                                pixel_data_for_base_tile.append((r_int, g_int, b_int))
                            except ValueError: # Invalid hex string
                                pixel_data_for_base_tile.append((255,0,255)) # Magenta for error
                    if not valid_tile: break
                
                if not valid_tile or len(pixel_data_for_base_tile) != TILE_WIDTH * TILE_HEIGHT:
                    # Fill this part of supertile with invalid color if base tile is bad
                    # Create a temporary Pillow image for the scaled error tile
                    error_scaled_tile = Image.new('RGB', (final_scaled_base_tile_w, final_scaled_base_tile_h), INVALID_TILE_COLOR)
                    paste_x = round(c_st_def * scaled_base_tile_w)
                    paste_y = round(r_st_def * scaled_base_tile_h)
                    pil_supertile_image.paste(error_scaled_tile, (paste_x, paste_y))
                    continue

                # Populate the 8x8 temporary Pillow image
                pil_temp_base_tile.putdata(pixel_data_for_base_tile)

                # Scale the 8x8 temporary image to its final size within the supertile
                try:
                    pil_scaled_base_tile = pil_temp_base_tile.resize(
                        (final_scaled_base_tile_w, final_scaled_base_tile_h),
                        Image.Resampling.NEAREST
                    )
                except ValueError as e_resize: # e.g. if final_scaled_base_tile_w/h are zero
                    _error(f"Error resizing base tile in supertile {supertile_index}: {e_resize}")
                    pil_scaled_base_tile = Image.new('RGB', (final_scaled_base_tile_w, final_scaled_base_tile_h), INVALID_TILE_COLOR)


                # Calculate paste position (top-left) for this scaled base tile
                # Use floating point scaled_base_tile_w/h for paste position calculation
                # then round for the final integer paste coordinates.
                paste_x = round(c_st_def * scaled_base_tile_w)
                paste_y = round(r_st_def * scaled_base_tile_h)

                pil_supertile_image.paste(pil_scaled_base_tile, (paste_x, paste_y))

        self.map_render_cache[cache_key] = pil_supertile_image
        return pil_supertile_image

    def _handle_map_scroll_event(self, event=None):
        # This method is called by scrollbar interactions.
        # It needs to redraw the main map canvas content and the minimap.
        # A small delay can sometimes help smooth out rapid scrollbar dragging,
        # but let's try direct calls first. If it's choppy, we can add debouncing.
        if self.map_canvas and self.map_canvas.winfo_exists():
            self.draw_map_canvas() # Redraw main map content
            self.draw_minimap()    # Update minimap

    def _perform_debounced_rom_canvas_draw(self):
        # This method is called by the 'after' timer from _on_rom_importer_setting_change (e.g. Configure)
        # and from scrollbar/keypress handlers in the ROM importer.
        
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            _debug(" DebouncedRomDraw: ROM import dialog no longer exists. Aborting.")
            return
        
        dialog = self.rom_import_dialog
        
        # Clear the timer ID if it exists on the dialog object
        if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id is not None:
            dialog.redraw_timer_id = None # Mark timer as having fired/been cleared

        canvas = getattr(dialog, 'canvas', None)
        if not canvas or not canvas.winfo_exists():
            _debug(" DebouncedRomDraw: ROM importer canvas no longer exists. Aborting.")
            return
            
        # Check canvas size again before drawing, as it might still be too small
        # if configure events are rapid or window is being minimized.
        canvas_w = canvas.winfo_width()
        canvas_h = canvas.winfo_height()
        min_draw_size = VIEWER_TILE_SIZE # A sensible minimum, e.g., one tile
        
        if canvas_w < min_draw_size or canvas_h < min_draw_size:
            _debug(f" DebouncedRomDraw: Canvas still too small (W:{canvas_w}, H:{canvas_h}). Rescheduling.")
            # Reschedule the debounced draw if canvas is not yet ready
            if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id is not None:
                 dialog.after_cancel(dialog.redraw_timer_id) # Cancel if somehow another one got set
            dialog.redraw_timer_id = dialog.after(100, self._perform_debounced_rom_canvas_draw) # Try again
            return

        _debug(" DebouncedRomDraw: Conditions met. Calling _draw_rom_importer_canvas.")
        self._draw_rom_importer_canvas() # Call the (now Pillow-optimized) drawing method

    def _on_fine_offset_slider_change(self, slider_value_str=None):
        """Handles the fine_offset slider value change with debouncing and snapping."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog

        # Ensure the slider_redraw_timer_id attribute exists on the dialog object
        if not hasattr(dialog, 'slider_redraw_timer_id'):
            dialog.slider_redraw_timer_id = None

        if slider_value_str is not None:
            try:
                # The value from the slider command is a string representation of a float
                current_float_val = float(slider_value_str)
                rounded_int_val = round(current_float_val) # Round to nearest integer

                # Ensure the rounded value is within the slider's defined range (0-7)
                # This is mostly a safeguard, as 'from_' and 'to' should constrain it.
                clamped_int_val = max(0, min(7, rounded_int_val))

                # Update the IntVar. This will cause the slider to visually snap
                # if its current internal float value was different from the rounded int.
                # Only set if different to avoid potential recursive calls if not careful,
                # though with an IntVar, Tkinter usually handles this well.
                if dialog.fine_offset_var.get() != clamped_int_val:
                    dialog.fine_offset_var.set(clamped_int_val)
                    # No need to call _draw_rom_importer_canvas here directly.
                    # The debouncer will handle it based on the *final* settled value.
                    # If you wanted instant preview of the *snapped* value, you could add it here.

            except ValueError:
                # Handle cases where slider_value_str might not be a valid float string
                # This shouldn't happen with a standard Scale widget but good for robustness.
                pass # Keep current var value if conversion fails

        # Cancel any previously scheduled redraw for the slider
        if dialog.slider_redraw_timer_id is not None:
            dialog.after_cancel(dialog.slider_redraw_timer_id)
        
        # Schedule the actual redraw after a short delay
        # _perform_debounced_slider_redraw will use dialog.fine_offset_var.get()
        dialog.slider_redraw_timer_id = dialog.after(250, self._perform_debounced_slider_redraw)

    def _perform_debounced_slider_redraw(self):
        """Called by the after timer to redraw the ROM importer canvas after slider movement has paused."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return

        dialog = self.rom_import_dialog
        
        # Ensure the slider_redraw_timer_id attribute exists before trying to clear it
        if hasattr(dialog, 'slider_redraw_timer_id'):
            dialog.slider_redraw_timer_id = None # Clear the timer ID

        # Now, call the main drawing function for the ROM importer canvas
        # This function will use the current value of dialog.fine_offset_var.get()
        self._draw_rom_importer_canvas()

    def _update_importer_color_swatches(self):
        """Updates the BG/FG color swatches in the ROM importer dialog."""
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog):
            return
        
        dialog = self.rom_import_dialog
        
        # Ensure swatches and color indices exist on dialog
        if not all(hasattr(dialog, attr) for attr in ['importer_fg_swatch', 'importer_bg_swatch', 
                                                      'current_importer_fg_idx', 'current_importer_bg_idx']):
            return

        try:
            fg_color_hex = self.active_msx_palette[dialog.current_importer_fg_idx]
            bg_color_hex = self.active_msx_palette[dialog.current_importer_bg_idx]

            if dialog.importer_fg_swatch.winfo_exists():
                dialog.importer_fg_swatch.config(bg=fg_color_hex, fg=get_contrast_color(fg_color_hex))
            if dialog.importer_bg_swatch.winfo_exists():
                dialog.importer_bg_swatch.config(bg=bg_color_hex, fg=get_contrast_color(bg_color_hex))
        except IndexError:
            _error("Error updating importer swatches: Palette index out of range.")
        except tk.TclError:
            _error("Error updating importer swatches: TclError (widget likely destroyed).")

    def _pick_importer_color(self, swatch_type):
        if not self.rom_import_dialog or not tk.Toplevel.winfo_exists(self.rom_import_dialog) or \
           not self.active_msx_palette:
            return

        dialog = self.rom_import_dialog
        
        # Create a standard Toplevel window for the picker
        picker_win = tk.Toplevel(dialog)
        picker_win.title(f"Select Importer {'FG' if swatch_type == 'fg' else 'BG'} Color")
        picker_win.transient(dialog) # Make it a "child" of the dialog
        picker_win.grab_set()      # Modal behavior
        picker_win.resizable(False, False)

        # Canvas for color swatches
        picker_canvas_size_w = 4 * (PALETTE_SQUARE_SIZE + 2) + 2
        picker_canvas_size_h = 4 * (PALETTE_SQUARE_SIZE + 2) + 2
        
        picker_canvas = tk.Canvas(picker_win, 
                                  width=picker_canvas_size_w, 
                                  height=picker_canvas_size_h, 
                                  borderwidth=0, highlightthickness=0)
        picker_canvas.pack(padx=5, pady=5)

        selected_palette_index_from_picker = tk.IntVar(value=-1) 

        def on_palette_color_click(event, index_clicked):
            selected_palette_index_from_picker.set(index_clicked)
            picker_win.destroy() # This is the primary way it should close

        # Bind Escape to close the picker window
        picker_win.bind("<Escape>", lambda e: picker_win.destroy())

        # Populate the picker canvas with color swatches
        for i in range(len(self.active_msx_palette)): 
            row, col = divmod(i, 4)
            x1 = col * (PALETTE_SQUARE_SIZE + 2) + 2
            y1 = row * (PALETTE_SQUARE_SIZE + 2) + 2
            x2 = x1 + PALETTE_SQUARE_SIZE
            y2 = y1 + PALETTE_SQUARE_SIZE
            color_hex = self.active_msx_palette[i]
            
            rect_id = picker_canvas.create_rectangle(x1, y1, x2, y2, fill=color_hex, outline="grey", width=1, tags=f"picker_swatch_{i}")
            picker_canvas.tag_bind(rect_id, "<Button-1>", 
                                   lambda e, idx=i: on_palette_color_click(e, idx))
            # Optional: Add hover effects back if desired, but keep it simple first
            # picker_canvas.tag_bind(rect_id, "<Enter>", lambda e, r=rect_id: picker_canvas.itemconfig(r, outline="yellow", width=2))
            # picker_canvas.tag_bind(rect_id, "<Leave>", lambda e, r=rect_id: picker_canvas.itemconfig(r, outline="grey", width=1))
        
        # --- Positioning Logic ---
        picker_win.update_idletasks() # Calculate picker's required size

        clicked_swatch_widget = None
        if swatch_type == 'fg':
            clicked_swatch_widget = getattr(dialog, 'importer_fg_swatch', None)
        elif swatch_type == 'bg':
            clicked_swatch_widget = getattr(dialog, 'importer_bg_swatch', None)

        if clicked_swatch_widget and clicked_swatch_widget.winfo_exists():
            dialog.update_idletasks() # Ensure main dialog geometry is current
            
            swatch_screen_x = clicked_swatch_widget.winfo_rootx()
            swatch_screen_y = clicked_swatch_widget.winfo_rooty()
            swatch_width = clicked_swatch_widget.winfo_width()
            
            target_x_pos = swatch_screen_x + swatch_width + 5 # Position to the right
            target_y_pos = swatch_screen_y                     # Align top edges

            picker_w = picker_win.winfo_width() 
            picker_h = picker_win.winfo_height()
            screen_w = picker_win.winfo_screenwidth()
            screen_h = picker_win.winfo_screenheight()

            # Adjust if off-screen (simplified boundary check)
            if target_x_pos + picker_w > screen_w:
                target_x_pos = swatch_screen_x - picker_w - 5 # Try left
            if target_x_pos < 0: # Still off left, or was initially off left
                 target_x_pos = 5 # Fallback to near left edge of screen
            
            if target_y_pos + picker_h > screen_h:
                target_y_pos = screen_h - picker_h - 5 # Move up from bottom
            if target_y_pos < 0:
                target_y_pos = 5 # Fallback to near top edge of screen
            
            picker_win.geometry(f"+{target_x_pos}+{target_y_pos}")
        else:
            # Fallback: Center on the ROM importer dialog if swatch widget not found or other issue
            _error("_pick_importer_color: Swatch widget not found or error; using fallback centering.")
            picker_win.update_idletasks()
            dialog_x = dialog.winfo_rootx()
            dialog_y = dialog.winfo_rooty()
            dialog_w = dialog.winfo_width()
            picker_w = picker_win.winfo_width()
            x_pos = dialog_x + (dialog_w // 2) - (picker_w // 2)
            y_pos = dialog_y + 50 # Offset slightly from dialog top
            picker_win.geometry(f"+{max(0, x_pos)}+{max(0, y_pos)}") # Ensure on screen
        
        picker_win.focus_set()
        picker_win.wait_window() # This blocks until picker_win is destroyed

        # --- Post-picker logic (after it's closed) ---
        chosen_idx = selected_palette_index_from_picker.get()
        if 0 <= chosen_idx < len(self.active_msx_palette):
            changed_color = False
            if swatch_type == 'fg':
                if dialog.current_importer_fg_idx != chosen_idx:
                    dialog.current_importer_fg_idx = chosen_idx
                    changed_color = True
            elif swatch_type == 'bg':
                if dialog.current_importer_bg_idx != chosen_idx:
                    dialog.current_importer_bg_idx = chosen_idx
                    changed_color = True
            
            if changed_color:
                self._update_importer_color_swatches()
                self._draw_rom_importer_canvas()

    def confirm_quit(self):
        """Checks for unsaved changes and prompts user before quitting. Saves window configs on exit."""
        perform_quit = False
        if self.project_modified:
            project_name_display = "Untitled"
            if self.current_project_base_path:
                project_name_display = os.path.basename(self.current_project_base_path)
            
            response = messagebox.askyesnocancel(
                "Quit MSX Tile Forge",
                f"Save changes to '{project_name_display}' before quitting?",
                parent=self.root
            )

            if response is True:  # Yes, Save
                save_successful = self.save_project()
                if save_successful:
                    perform_quit = True
            elif response is False:  # No, Don't Save
                perform_quit = True
            # If response is None (Cancel), perform_quit remains False
        else:
            # No unsaved changes, can quit directly
            perform_quit = True

        if perform_quit:
            _debug(" confirm_quit: Proceeding with application quit.")
            # Explicitly gather the final state of all windows before saving settings.
            self._gather_open_window_states(final_save=True)
            self._save_app_settings() 
            if hasattr(self.root, 'destroy'): # Check if root still exists
                try:
                    self.root.destroy()
                except tk.TclError:
                    _debug(" TclError during root.destroy() in confirm_quit.")
        else:
            _debug(" confirm_quit: Quit cancelled by user or save process.")

    def _on_resizable_selector_pane_configure(self, event=None):
        # Debounced callback for when ANY resizable selector pane is configured.
        widget_that_was_configured = event.widget
        
        # Store the timer ID on the widget itself to handle multiple instances.
        if hasattr(widget_that_was_configured, '_resize_timer_id') and widget_that_was_configured._resize_timer_id is not None:
            try:
                self.root.after_cancel(widget_that_was_configured._resize_timer_id)
            except tk.TclError:
                pass
        
        # Pass the specific widget to the debounced function.
        widget_that_was_configured._resize_timer_id = self.root.after(
            100, lambda w=widget_that_was_configured: self._redraw_selector_debounced(w)
        )

    def _redraw_selector_debounced(self, selector_container):
        # Redraws the appropriate selector canvas based on the container widget.
        if not selector_container or not selector_container.winfo_exists():
            return

        selector_container._resize_timer_id = None
        
        canvas_to_redraw = None
        highlight_index = -1

        # Identify which canvas to redraw.
        if selector_container == getattr(self, 'map_editor_palette_pane_container', None):
            canvas_to_redraw = getattr(self, 'map_supertile_selector_canvas', None)
            highlight_index = selected_supertile_for_map
        elif selector_container.winfo_name() == "st_editor_selector_frame":
            canvas_to_redraw = getattr(self, 'supertile_selector_canvas', None)
            highlight_index = current_supertile_index

        if canvas_to_redraw and canvas_to_redraw.winfo_exists():
            self.draw_supertile_selector(canvas_to_redraw, highlight_index)

    def _do_check_and_enforce_palette_min_width(self):
        _debug(f"\n --- _do_check_and_enforce_palette_min_width ---")

        map_pane_container = getattr(self, 'map_editor_map_pane_container', None)
        palette_pane_container = getattr(self, 'map_editor_palette_pane_container', None)
        paned_window_widget = getattr(self, 'map_paned_window', None)

        if not paned_window_widget or not paned_window_widget.winfo_exists() or \
           not palette_pane_container or not palette_pane_container.winfo_exists() or \
           not map_pane_container or not map_pane_container.winfo_exists():
            _debug(" DoCheckEnforce: Required paned window/pane widgets missing. Aborting.")
            return

        try:
            paned_window_total_width = paned_window_widget.winfo_width()
            sash_thickness_approx = 8 
            
            if paned_window_total_width < 50: 
                _debug(f" DoCheckEnforce: PanedWindow total width ({paned_window_total_width}) too small. Skipping enforcement.")
                return

            _debug(f" DoCheckEnforce: PanedWindowTotalW={paned_window_total_width}")

            # Min width for Left Pane (Map Area + Controls)
            # Ensure self.map_controls_min_width has a sensible default if not yet calculated
            # The value 400 worked for you.
            min_left_pane_width = getattr(self, 'map_controls_min_width', 400) 
            if min_left_pane_width <= 10: # If it was calculated as something tiny or was default 0
                min_left_pane_width = 400 # Override with your known good fallback
                _debug(f" DoCheckEnforce: Overriding min_left_pane_width to fallback {min_left_pane_width}")
            min_left_pane_width = max(50, min_left_pane_width) # Absolute floor
            _debug(f" DoCheckEnforce: Min Left Pane (Map Controls) Width Required: {min_left_pane_width}")

            # Min width for Right Pane (Palette) Content
            padding_for_palette_content = 1
            frame_padding_palette_approx = 20
            scrollbar_width_approx = 10 
            one_supertile_item_w = (self.supertile_grid_width * TILE_WIDTH)
            min_canvas_content_width_palette = (1 * one_supertile_item_w) + (1 + 1) * padding_for_palette_content 
            min_canvas_content_width_palette = max(32, min_canvas_content_width_palette)
            min_total_right_pane_width = min_canvas_content_width_palette + frame_padding_palette_approx + scrollbar_width_approx
            _debug(f" DoCheckEnforce: Min Total Right Pane (Palette) Width Required: {min_total_right_pane_width}")

            current_sash_0_pos = paned_window_widget.sashpos(0)
            final_target_sash_pos = current_sash_0_pos # Start with current, adjust if needed
            _debug(f" DoCheckEnforce: Initial current_sash_pos(0) = {final_target_sash_pos}")

            # Calculate desired sash position to satisfy right pane's minimum
            sash_for_right_min = paned_window_total_width - min_total_right_pane_width - sash_thickness_approx
            
            # Calculate desired sash position to satisfy left pane's minimum
            sash_for_left_min = min_left_pane_width

            needs_correction = False

            # If left pane is too small
            if current_sash_0_pos < sash_for_left_min:
                _debug(f" DoCheckEnforce: Left pane ({current_sash_0_pos}) is smaller than required ({sash_for_left_min}). Targetting {sash_for_left_min}.")
                final_target_sash_pos = sash_for_left_min
                needs_correction = True
            
            # Now, check if this 'final_target_sash_pos' makes the right pane too small
            effective_right_pane_width = paned_window_total_width - final_target_sash_pos - sash_thickness_approx
            if effective_right_pane_width < min_total_right_pane_width:
                _debug(f" DoCheckEnforce: Giving left pane its min would make right pane ({effective_right_pane_width}) too small (min {min_total_right_pane_width}).")
                # This means we might not be able to satisfy both. Prioritize left pane's minimum.
                # The 'final_target_sash_pos' is already set to satisfy the left pane.
                # If we wanted to prioritize right, we'd set: final_target_sash_pos = sash_for_right_min
                # and then re-check if left became too small.
                # The current logic: if left needs X, set sash to X. If this makes right too small, tough for right.
                # Let's refine: try to satisfy both, but if conflict, choose.
                
                # Can we satisfy both?
                if (sash_for_left_min + sash_thickness_approx + min_total_right_pane_width) <= paned_window_total_width:
                    # Yes, there's enough space for both minimums and the sash.
                    # Ensure left gets its min.
                    final_target_sash_pos = max(final_target_sash_pos, sash_for_left_min)
                    # Ensure right gets its min (adjust sash from left edge).
                    final_target_sash_pos = min(final_target_sash_pos, sash_for_right_min)
                    _debug(f" DoCheckEnforce: Enough space for both. Final target after considering both: {final_target_sash_pos}")

                else: # Not enough space for both minimums
                    _debug(f" DoCheckEnforce: Not enough total width for both minimums. Prioritizing left pane min.")
                    final_target_sash_pos = sash_for_left_min # Prioritize left pane
                needs_correction = True # A correction is likely needed if we entered this complex block

            # Final clamping of the target sash position to valid PanedWindow bounds
            final_target_sash_pos = max(0, final_target_sash_pos)
            # Ensure right pane at least has space for sash thickness if target is too far right
            final_target_sash_pos = min(final_target_sash_pos, paned_window_total_width - sash_thickness_approx) 
                                          
            _debug(f" DoCheckEnforce: OriginalSashPos={current_sash_0_pos}, FinalCalculatedTargetSashPos={final_target_sash_pos}")

            if needs_correction and abs(current_sash_0_pos - final_target_sash_pos) > 2:
                _debug(f" DoCheckEnforce: Applying final sashpos(0) to: {final_target_sash_pos}")
                try:
                    paned_window_widget.sashpos(0, final_target_sash_pos)
                except tk.TclError as e_sash:
                    _debug(f" DoCheckEnforce: TclError setting sashpos: {e_sash}")
            elif needs_correction: # Corrected value is too close to current, no actual sashpos call
                 _debug(f" DoCheckEnforce: Correction calculated but change too small or already correct. Not calling sashpos.")
            else: # No violation detected initially
                _debug(f" DoCheckEnforce: No minimum width violations detected. No change to sash needed.")
        
        except tk.TclError as e:
            _error(f" TclError error in _do_check_and_enforce_palette_min_width: {e}")
        except Exception as e: 
            _error(f" Unexpected error in _do_check_and_enforce_palette_min_width: {e}")
        _debug(f" --- _do_check_and_enforce_palette_min_width END ---")

    def _on_main_window_configure(self, event=None):
        if event and event.widget != self.root:
            return 

        _debug(f" _on_main_window_configure: Main window resized/moved (w={self.root.winfo_width()}, h={self.root.winfo_height()}).")

        if hasattr(self, '_main_window_configure_timer') and self._main_window_configure_timer is not None:
            try:
                self.root.after_cancel(self._main_window_configure_timer)
            except tk.TclError: pass
        
        # Ensure this calls the correctly named method
        self._main_window_configure_timer = self.root.after(300, self._call_enforce_min_width_logic_from_main_resize)

    def _call_enforce_min_width_logic_from_main_resize(self): # Renamed for clarity
        _debug(" --- Main window resize: performing debounced pane minimum check ---")
        if hasattr(self, '_main_window_configure_timer'): 
            self._main_window_configure_timer = None
        
        is_map_tab_active = False
        if self.notebook and self.notebook.winfo_exists():
            try:
                # Check if the currently selected tab's frame widget is the map editor's frame widget
                selected_tab_path = self.notebook.select()
                if selected_tab_path: # Ensure a tab is actually selected
                    selected_tab_widget = self.notebook.nametowidget(selected_tab_path)
                    if selected_tab_widget == self.tab_map_editor:
                        is_map_tab_active = True
            except tk.TclError: 
                _debug(" Main resize check: TclError getting selected tab info.")
        
        if is_map_tab_active:
            # Ensure map_paned_window exists and is mapped (visible) before calling enforce
            if hasattr(self, 'map_paned_window') and \
               self.map_paned_window.winfo_exists() and \
               self.map_paned_window.winfo_ismapped():
                _debug(" Main resize: Map tab active and paned window mapped. Calling _do_check_and_enforce_palette_min_width.")
                self._do_check_and_enforce_palette_min_width() # Call the core logic
            else:
                _debug(" Main resize: Map tab active, but map_paned_window not ready/mapped. Skipping enforcement.")
        else:
            _debug(" Main resize: Map tab not active. Skipping pane minimum enforcement.")

    def _on_map_canvas_configure(self, event=None):
        # Called when the map_canvas itself is resized (e.g., due to sash drag or window resize)
        
        map_canvas_widget = getattr(self, 'map_canvas', None)
        if not map_canvas_widget or not map_canvas_widget.winfo_exists():
            _debug(" _on_map_canvas_configure: Map canvas not available. Skipping redraw.")
            return

        # event.width and event.height should give the new dimensions of self.map_canvas
        # Fallback to winfo_width/height if event attributes are not present (though they should be for <Configure>)
        new_width = getattr(event, 'width', map_canvas_widget.winfo_width())
        new_height = getattr(event, 'height', map_canvas_widget.winfo_height())

        _debug(f" _on_map_canvas_configure: Map canvas configured. New WxH: {new_width}x{new_height}.")

        # We only want to trigger a full redraw if the size has actually changed meaningfully,
        # as <Configure> can also fire for position changes.
        # We can compare with the dimensions of our current Pillow viewport image.
        viewport_changed_width = True # Assume changed unless proven otherwise
        viewport_changed_height = True

        if hasattr(self, 'pil_map_viewport_image') and self.pil_map_viewport_image:
            if self.pil_map_viewport_image.width == new_width:
                viewport_changed_width = False
            if self.pil_map_viewport_image.height == new_height:
                viewport_changed_height = False
        
        # Only redraw if dimensions are valid and have actually changed, or if no viewport image exists yet
        if (new_width > 1 and new_height > 1) and \
           (not hasattr(self, 'pil_map_viewport_image') or self.pil_map_viewport_image is None or viewport_changed_width or viewport_changed_height):
            
            if map_canvas_widget.winfo_ismapped(): # Ensure it's actually visible
                _debug(" _on_map_canvas_configure: Calling draw_map_canvas() due to size change or initial setup.")
                self.draw_map_canvas() 
                self.draw_minimap()    
            else:
                _debug(" _on_map_canvas_configure: Map canvas not mapped, draw call skipped despite size change.")
        else:
            _debug(f" _on_map_canvas_configure: No significant size change or canvas too small/not ready. W={new_width}, H={new_height}, ViewportChangedW={viewport_changed_width}, ViewportChangedH={viewport_changed_height}. Draw call skipped.")


    def _create_add_many_dialog(self, parent, title_text, prompt_text, current_items, max_items_total):
        """
        Helper to create a dialog for 'Add Many...' functionality.
        Returns the number of items to add, or None if cancelled.
        """
        space_available = max_items_total - current_items
        if space_available <= 0:
            messagebox.showinfo(title_text, "The list is already full.", parent=parent)
            return None

        dialog = tk.Toplevel(parent)
        dialog.title(title_text)
        dialog.transient(parent)
        dialog.grab_set()
        dialog.resizable(False, False)

        # Calculate default value for spinbox
        default_val = 8
        if space_available < 8:
            default_val = space_available
        
        # Frame for content
        main_frame = ttk.Frame(dialog, padding="10")
        main_frame.pack(expand=True, fill="both")

        ttk.Label(main_frame, text=prompt_text).pack(pady=(0, 5))

        spinbox_var = tk.IntVar(value=default_val)
        # Spinbox range is 1 to space_available
        spinbox = ttk.Spinbox(
            main_frame, 
            from_=1, 
            to=max(1, space_available), # Ensure 'to' is at least 1 if space_available is 1
            textvariable=spinbox_var, 
            width=5,
            wrap=False # Do not wrap around
        )
        spinbox.pack(pady=5)
        spinbox.focus_set()
        spinbox.selection_range(0, tk.END) # Select current text for easy overwrite

        # Frame for buttons
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=(10, 0))

        result = {"value": None} # Use a dictionary to pass result back

        def on_ok():
            try:
                val = spinbox_var.get()
                if 1 <= val <= space_available:
                    result["value"] = val
                    dialog.destroy()
                else:
                    messagebox.showerror("Invalid Input", f"Please enter a number between 1 and {space_available}.", parent=dialog)
            except tk.TclError: # Handles non-integer input if user types garbage
                messagebox.showerror("Invalid Input", "Please enter a valid whole number.", parent=dialog)


        def on_cancel():
            dialog.destroy() # result["value"] remains None

        ok_button = ttk.Button(button_frame, text="OK", command=on_ok, width=8)
        ok_button.pack(side=tk.LEFT, padx=5)
        cancel_button = ttk.Button(button_frame, text="Cancel", command=on_cancel, width=8)
        cancel_button.pack(side=tk.LEFT, padx=5)

        dialog.bind("<Return>", lambda e: on_ok())
        dialog.bind("<Escape>", lambda e: on_cancel())
        
        # Center dialog on parent
        parent.update_idletasks() # Ensure parent geometry is up to date
        dialog.update_idletasks() # Ensure dialog knows its requested size
        
        parent_x = parent.winfo_rootx()
        parent_y = parent.winfo_rooty()
        parent_w = parent.winfo_width()
        parent_h = parent.winfo_height()
        
        dialog_w = dialog.winfo_reqwidth()
        dialog_h = dialog.winfo_reqheight()
        
        x_pos = parent_x + (parent_w // 2) - (dialog_w // 2)
        y_pos = parent_y + (parent_h // 2) - (dialog_h // 2)
        
        dialog.geometry(f"+{x_pos}+{y_pos}")

        dialog.wait_window()
        return result["value"]

    def handle_add_many_tiles(self):
        global current_tile_index
        if len(tileset_patterns) >= self.project_tile_limit:
            messagebox.showinfo("Add Many Tiles", f"Tileset is at its limit of {self.project_tile_limit}.", parent=self.root)
            return
        space_available = self.project_tile_limit - len(tileset_patterns)

        num_to_add = self._create_add_many_dialog(
            parent=self.root, 
            title_text="Add Many Tiles",
            prompt_text=f"How many tiles to add? (1-{space_available})",
            current_items=len(tileset_patterns),
            max_items_total=self.project_tile_limit
        )
        if num_to_add is None or num_to_add <= 0: return

        if self._clear_marked_unused(trigger_redraw=False): pass
        
        first_new_tile_idx = len(tileset_patterns)
        commands = []
        for i in range(num_to_add):
            new_idx = len(tileset_patterns) + i
            blank_pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
            blank_colors = [(WHITE_IDX, BLACK_IDX) for _ in range(TILE_HEIGHT)]
            commands.append(ModifyListCommand("Add Tile", tileset_patterns, new_idx, blank_pattern, is_insert=True))
            commands.append(ModifyListCommand("Add Tile", tileset_colors, new_idx, blank_colors, is_insert=True))

        old_state = (len(tileset_patterns), current_tile_index)
        new_state = (len(tileset_patterns) + num_to_add, first_new_tile_idx)
        def state_setter(state_tuple):
            global current_tile_index
            current_tile_index = state_tuple[1]
        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)
        commands.append(state_command)

        def post_add_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self._update_editor_button_states()
            self._request_color_usage_refresh()
            self.scroll_viewers_to_tile(current_tile_index)

        composite = CompositeCommand(f"Add {num_to_add} Tiles", commands, app_ref=self, post_hooks=[post_add_hooks])
        self.undo_manager.execute(composite)
        _debug(f"Added {num_to_add} new tiles.")

    def handle_add_many_supertiles(self):
        global current_supertile_index
        _debug(f"\n[HANDLE ADD MANY] START. len(supertiles_data)={len(supertiles_data)}, len(supertiles_data)={len(supertiles_data)}")
        if len(supertiles_data) >= self.project_supertile_limit:
            messagebox.showinfo("Add Many Supertiles", f"Supertile set is at its limit of {self.project_supertile_limit}.", parent=self.root)
            return
        space_available = self.project_supertile_limit - len(supertiles_data)
        num_to_add = self._create_add_many_dialog(self.root, "Add Many Supertiles", f"How many supertiles to add? (1-{space_available})", len(supertiles_data), self.project_supertile_limit)
        if num_to_add is None or num_to_add <= 0: return

        if self._clear_marked_unused(trigger_redraw=False): pass
        
        first_new_st_idx = len(supertiles_data)
        commands = []
        for i in range(num_to_add):
            new_idx = len(supertiles_data) + i
            blank_st_definition = [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
            commands.append(ModifyListCommand("Add Supertile", supertiles_data, new_idx, blank_st_definition, is_insert=True))
            _debug(f"[HANDLE ADD MANY] Created ModifyListCommand to insert at index {new_idx}")

        old_state = (current_supertile_index,)
        new_state = (first_new_st_idx,)
        _debug(f"[HANDLE ADD MANY] Created state command. Old state={old_state}, New state={new_state}")
        def state_setter(state_tuple):
            global current_supertile_index
            _debug(f"  [state_setter] Called. Setting state to {state_tuple}.")
            current_supertile_index = state_tuple[0]
        state_command = SetDataCommand("Update App State", self, state_setter, new_state, old_state)
        commands.append(state_command)

        def post_add_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self._update_editor_button_states()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()
            self.scroll_selectors_to_supertile(current_supertile_index)
            _debug("[post_hooks] Executed.")

        composite = CompositeCommand(f"Add {num_to_add} Supertiles", commands, app_ref=self, post_hooks=[post_add_hooks])
        self.undo_manager.execute(composite)
        _debug(f"[HANDLE ADD MANY] FINISHED. len(supertiles_data)={len(supertiles_data)}, len(supertiles_data)={len(supertiles_data)}")

    def _confirm_supertile_import_with_broken_refs(self, parent_dialog, supertile_def_to_render, original_st_index_in_file, num_tiles_actually_staged, original_starting_tile_idx_in_project):
        """
        Placeholder for a dialog that shows a supertile with broken refs and asks for confirmation.
        For now, uses a simpler messagebox.askyesnocancel.
        A proper implementation would render the supertile visually with error masks.

        Args:
            parent_dialog: The parent window for this dialog (e.g., self.root).
            supertile_def_to_render: The 2D list of remapped tile indices (where broken ones are already 0).
            original_st_index_in_file: The index of this supertile in the source file (for user message).
            num_tiles_actually_staged: How many tiles were successfully read from the linked .SC4Tiles.
            original_starting_tile_idx_in_project: The project index where tiles from the pack started.

        Returns:
            str: "import", "skip", or "cancel_all"
        """
        _debug(f" Confirming ST import: Original ST index {original_st_index_in_file} from file.")
        # In a full implementation, render supertile_def_to_render here,
        # highlighting cells that were remapped to 0 due to original index T_orig >= num_tiles_actually_staged.

        title = "Supertile Import Confirmation"
        message = (
            f"Supertile {original_st_index_in_file} (from file) references tiles that could not be fully imported "
            f"from its associated tileset (due to project tileset limits).\n\n"
            f"These broken tile references within this supertile have been set to use Project Tile 0.\n\n"
            f"Do you want to import this supertile with these adjustments?"
        )
        
        # Using a custom dialog setup for three distinct return values
        dialog = tk.Toplevel(parent_dialog)
        dialog.title(title)
        dialog.transient(parent_dialog)
        dialog.grab_set()
        dialog.resizable(False, False)

        result = {"action": "cancel_all"} # Default to cancel if window closed

        label = ttk.Label(dialog, text=message, wraplength=400, justify=tk.LEFT)
        label.pack(padx=20, pady=10)

        # TODO: Add visual rendering of the supertile_def_to_render here
        # For now, it's just a text confirmation.
        # Example:
        # preview_canvas = tk.Canvas(dialog, width=self.supertile_grid_width*32, height=self.supertile_grid_height*32, bg="lightgrey")
        # preview_canvas.pack(pady=5)
        # ... logic to draw the supertile_def_to_render onto preview_canvas ...
        # You would need to pass self.supertile_grid_width/height or get them
        # And use logic similar to create_supertile_image, but also indicate broken refs.

        button_frame = ttk.Frame(dialog)
        button_frame.pack(pady=10, padx=10, fill=tk.X)
        button_frame.grid_columnconfigure(0, weight=1) # For centering buttons
        button_frame.grid_columnconfigure(1, weight=1)
        button_frame.grid_columnconfigure(2, weight=1)


        def set_action(action_val):
            result["action"] = action_val
            dialog.destroy()

        import_button = ttk.Button(button_frame, text="Import This Supertile", command=lambda: set_action("import"))
        import_button.grid(row=0, column=0, padx=5, sticky="ew")

        skip_button = ttk.Button(button_frame, text="Skip This Supertile", command=lambda: set_action("skip"))
        skip_button.grid(row=0, column=1, padx=5, sticky="ew")
        
        cancel_all_button = ttk.Button(button_frame, text="Cancel All Appending", command=lambda: set_action("cancel_all"))
        cancel_all_button.grid(row=0, column=2, padx=5, sticky="ew")

        dialog.bind("<Escape>", lambda e: set_action("cancel_all")) # Escape cancels all

        # Center dialog
        parent_dialog.update_idletasks()
        dialog.update_idletasks()
        px, py, pw, ph = parent_dialog.winfo_rootx(), parent_dialog.winfo_rooty(), parent_dialog.winfo_width(), parent_dialog.winfo_height()
        dw, dh = dialog.winfo_reqwidth(), dialog.winfo_reqheight()
        dialog.geometry(f"{dw}x{dh}+{px + (pw - dw)//2}+{py + (ph - dh)//2}")


        dialog.wait_window()
        return result["action"]

    def append_supertiles_from_file(self):
        global supertiles_data, tileset_patterns, tileset_colors
        global current_supertile_index, current_tile_index 

        st_load_path = filedialog.askopenfilename(
            master=self.root,
            filetypes=[("MSX Supertiles", "*.SC4Super"), ("All Files", "*.*")],
            title="Select Supertile File to Append",
        )
        if not st_load_path:
            return 

        st_dir, st_filename = os.path.split(st_load_path)
        st_basename, _ = os.path.splitext(st_filename)
        tile_load_path = os.path.join(st_dir, f"{st_basename}.SC4Tiles")

        if not os.path.exists(tile_load_path):
            messagebox.showerror("Append Error", 
                                 f"Associated tileset file '{os.path.basename(tile_load_path)}' not found in the same directory. "
                                 "This operation requires it to append supertiles and their referenced tiles together.",
                                 parent=self.root)
            return

        file_st_grid_w, file_st_grid_h, file_st_count = 0,0,0
        file_tile_count = 0

        try: 
            with open(st_load_path, "rb") as f_st:
                first_count_byte = f_st.read(1)
                if not first_count_byte: raise ValueError("Supertile file empty.")
                indicator = struct.unpack("B", first_count_byte)[0]
                header_size_st_count = 1
                if indicator == 0:
                    count_short_bytes = f_st.read(2)
                    if len(count_short_bytes) < 2: raise EOFError("EOF for ST count.")
                    file_st_count = struct.unpack("<H", count_short_bytes)[0]
                    header_size_st_count = 3
                else:
                    file_st_count = indicator
                
                dim_w_byte, dim_h_byte = f_st.read(1), f_st.read(1)
                if not dim_w_byte or not dim_h_byte: raise EOFError("EOF for ST dimensions.")
                file_st_grid_w = struct.unpack("B", dim_w_byte)[0]
                file_st_grid_h = struct.unpack("B", dim_h_byte)[0]
            
            with open(tile_load_path, "rb") as f_tile:
                header_byte = f_tile.read(1)
                if not header_byte: raise ValueError("Tileset file empty.")
                val = struct.unpack("B", header_byte)[0]
                file_tile_count = 256 if val == 0 else val

        except Exception as e:
            messagebox.showerror("Append Error", f"Error reading file headers:\n{e}", parent=self.root)
            return

        if file_st_grid_w != self.supertile_grid_width or file_st_grid_h != self.supertile_grid_height:
            messagebox.showerror("Append Error",
                                 f"Cannot append. Supertile dimensions in file ({file_st_grid_w}x{file_st_grid_h}) "
                                 f"do not match current project's dimensions ({self.supertile_grid_width}x{self.supertile_grid_height}).",
                                 parent=self.root)
            return
        
        if file_st_count == 0:
             messagebox.showinfo("Append Supertiles", "The selected supertile file contains no supertile definitions to append.", parent=self.root)
             return

        st_space_available = self.project_supertile_limit - len(supertiles_data)
        tile_space_available = self.project_tile_limit - len(tileset_patterns)

        if st_space_available <= 0:
            messagebox.showinfo("Append Supertiles", f"Current project supertile set is at its limit of {self.project_supertile_limit}. Cannot append.", parent=self.root)
            return
        # Allow appending STs even if tile space is full, if file_tile_count is 0 or refs are handled
        # The main check is if associated tiles *needed* from file can fit.

        num_st_to_attempt_append = min(file_st_count, st_space_available)
        num_tiles_to_attempt_append_from_file = 0
        if file_tile_count > 0 : # Only consider appending tiles if the file has them
            num_tiles_to_attempt_append_from_file = min(file_tile_count, tile_space_available)


        if num_st_to_attempt_append < file_st_count or (file_tile_count > 0 and num_tiles_to_attempt_append_from_file < file_tile_count):
            warn_msg = "Warning: Project limits might be reached.\n\n"
            if file_tile_count > 0 and num_tiles_to_attempt_append_from_file < file_tile_count:
                warn_msg += f"Tiles: Will attempt to append {num_tiles_to_attempt_append_from_file} of {file_tile_count} from '{os.path.basename(tile_load_path)}'.\n"
            if num_st_to_attempt_append < file_st_count:
                warn_msg += f"Supertiles: Will attempt to append {num_st_to_attempt_append} of {file_st_count} from '{os.path.basename(st_filename)}'.\n"
            warn_msg += "\nPartial tile appending may lead to broken references in some supertiles (you will be asked to confirm these individually).\n\nProceed with appending?"
            if not messagebox.askyesno("Confirm Partial Append", warn_msg, icon="warning", parent=self.root):
                _debug("User cancelled overall partial append.")
                return
        
        if num_st_to_attempt_append == 0 : 
            messagebox.showinfo("Append Supertiles", "No supertiles to append after considering limits.", parent=self.root)
            return
        
        temp_appended_tile_patterns = []
        temp_appended_tile_colors = []
        original_starting_tile_index_in_project = len(tileset_patterns) 
        num_tiles_actually_staged_from_file = 0

        if file_tile_count > 0 and num_tiles_to_attempt_append_from_file > 0:
            try:
                with open(tile_load_path, "rb") as f_tile:
                    _ = f_tile.read(1) 
                    _ = f_tile.read(RESERVED_BYTES_COUNT) 

                    bytes_per_tile_pattern = TILE_HEIGHT
                    all_pattern_bytes = f_tile.read(file_tile_count * bytes_per_tile_pattern)
                    
                    bytes_per_tile_colors = TILE_HEIGHT
                    all_color_bytes = f_tile.read(file_tile_count * bytes_per_tile_colors)

                    if len(all_pattern_bytes) < file_tile_count * bytes_per_tile_pattern or \
                       len(all_color_bytes) < file_tile_count * bytes_per_tile_colors:
                        raise EOFError("Could not read all tile data from linked tileset file.")

                    pat_offset, col_offset = 0,0
                    for i_tile_file in range(file_tile_count): # Iterate all tiles in file
                        if i_tile_file >= num_tiles_to_attempt_append_from_file: # Only stage up to allowed amount
                            break
                        
                        tile_pat = [[0]*TILE_WIDTH for _ in range(TILE_HEIGHT)]
                        tile_col = [(WHITE_IDX,BLACK_IDX)]*TILE_HEIGHT
                        
                        tile_pattern_bytes_slice = all_pattern_bytes[pat_offset : pat_offset + bytes_per_tile_pattern]
                        for r in range(TILE_HEIGHT):
                            byte_val = tile_pattern_bytes_slice[r]
                            for c in range(TILE_WIDTH): tile_pat[r][c] = (byte_val >> (7-c)) & 1
                        temp_appended_tile_patterns.append(tile_pat)
                        pat_offset += bytes_per_tile_pattern

                        tile_color_bytes_slice = all_color_bytes[col_offset : col_offset + bytes_per_tile_colors]
                        for r in range(TILE_HEIGHT):
                            byte_val = tile_color_bytes_slice[r]
                            fg,bg = (byte_val >> 4)&0xF, byte_val&0xF
                            tile_col[r] = (fg if 0<=fg<16 else WHITE_IDX, bg if 0<=bg<16 else BLACK_IDX)
                        temp_appended_tile_colors.append(tile_col)
                        col_offset += bytes_per_tile_colors
                        num_tiles_actually_staged_from_file +=1
            except Exception as e:
                messagebox.showerror("Append Error", f"Error reading data from linked tileset file '{os.path.basename(tile_load_path)}':\n{e}", parent=self.root)
                return
        _debug(f"Staged {num_tiles_actually_staged_from_file} tiles for appending.")

        temp_appended_supertile_definitions = []
        supertiles_skipped_count = 0
        operation_fully_cancelled = False
        st_data_changed_flag = False 

        try:
            with open(st_load_path, "rb") as f_st:
                # Re-read header to position file pointer correctly
                _ = f_st.read(1) 
                if indicator == 0: _ = f_st.read(2) 
                _ = f_st.read(1) # dim_w
                _ = f_st.read(1) # dim_h
                _ = f_st.read(RESERVED_BYTES_COUNT) 

                tiles_in_one_def = self.supertile_grid_width * self.supertile_grid_height
                bytes_per_def = tiles_in_one_def 

                for st_file_idx in range(file_st_count): 
                    st_def_bytes = f_st.read(bytes_per_def)
                    if len(st_def_bytes) < bytes_per_def:
                        # This might happen if file_st_count was larger than actual defs in file
                        _warning(f"EOF reading definition for ST index {st_file_idx} from file. Expected more data.")
                        break 
                    
                    if st_file_idx >= num_st_to_attempt_append: 
                        _debug(f"Reached limit of STs to append ({num_st_to_attempt_append}). Stopping ST processing.")
                        break 

                    current_st_def_remapped = [[0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)]
                    has_broken_refs = False
                    byte_ptr = 0
                    for r_st_def in range(self.supertile_grid_height):
                        for c_st_def in range(self.supertile_grid_width):
                            t_orig_from_file = st_def_bytes[byte_ptr] # Tile index from the .SC4Super file
                            byte_ptr += 1
                            t_new_project_idx = 0 # Default if broken
                            if t_orig_from_file >= num_tiles_actually_staged_from_file: 
                                has_broken_refs = True
                                t_new_project_idx = 0 
                            else:
                                # Map file's tile index to its new index in the project
                                t_new_project_idx = t_orig_from_file + original_starting_tile_index_in_project
                            current_st_def_remapped[r_st_def][c_st_def] = t_new_project_idx
                    
                    if has_broken_refs:
                        user_choice = self._confirm_supertile_import_with_broken_refs(
                            self.root, current_st_def_remapped, st_file_idx, 
                            num_tiles_actually_staged_from_file, original_starting_tile_index_in_project
                        )
                        if user_choice == "import":
                            temp_appended_supertile_definitions.append(current_st_def_remapped)
                            st_data_changed_flag = True
                        elif user_choice == "skip":
                            supertiles_skipped_count += 1
                        elif user_choice == "cancel_all":
                            operation_fully_cancelled = True
                            break 
                    else: 
                        temp_appended_supertile_definitions.append(current_st_def_remapped)
                        st_data_changed_flag = True
            
            if operation_fully_cancelled:
                _debug("Append supertiles operation cancelled by user during ST confirmation.")
                messagebox.showinfo("Append Cancelled", "Append operation cancelled.", parent=self.root)
                return

        except Exception as e:
            messagebox.showerror("Append Error", f"Error processing supertile file '{os.path.basename(st_load_path)}':\n{e}", parent=self.root)
            return

        if not temp_appended_tile_patterns and not temp_appended_supertile_definitions:
            messagebox.showinfo("Append Supertiles", "No new tiles or supertiles were ultimately appended.", parent=self.root)
            return

        if self._clear_marked_unused(trigger_redraw=False): pass
        self._mark_project_modified()

        appended_tiles_actual_count = 0
        if num_tiles_actually_staged_from_file > 0:
            for i_append_tile in range(num_tiles_actually_staged_from_file): # Iterate only staged tiles
                if len(tileset_patterns) < MAX_TILES:
                    tileset_patterns[len(tileset_patterns)] = temp_appended_tile_patterns[i_append_tile]
                    tileset_colors[len(tileset_patterns)] = temp_appended_tile_colors[i_append_tile]
                    appended_tiles_actual_count +=1
                else: break
        
        appended_st_actual_count = 0
        if temp_appended_supertile_definitions:
            first_new_st_idx_project = len(supertiles_data)
            for st_def_to_add in temp_appended_supertile_definitions: # Iterate only STs confirmed for import
                if len(supertiles_data) < self.project_supertile_limit:
                    supertiles_data.append(st_def_to_add)
                    appended_st_actual_count += 1
                else:
                    break
            if appended_st_actual_count > 0:
                current_supertile_index = first_new_st_idx_project

        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        self.update_all_displays(changed_level="all")
        if appended_tiles_actual_count > 0 : self.scroll_viewers_to_tile(current_tile_index)
        if appended_st_actual_count > 0 : self.scroll_selectors_to_supertile(current_supertile_index)
        self._update_editor_button_states()
        
        if appended_tiles_actual_count > 0 or appended_st_actual_count > 0:
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

        summary_msg = f"Successfully appended {appended_tiles_actual_count} tile(s) and {appended_st_actual_count} supertile(s)."
        if supertiles_skipped_count > 0:
            summary_msg += f"\n{supertiles_skipped_count} supertile(s) from the file were skipped by user."
        if num_st_to_attempt_append < file_st_count and appended_st_actual_count < num_st_to_attempt_append :
             summary_msg += f"\nNote: Supertile limit may have prevented appending all desired supertiles."
        if file_tile_count > 0 and num_tiles_to_attempt_append_from_file < file_tile_count and appended_tiles_actual_count < num_tiles_to_attempt_append_from_file:
             summary_msg += f"\nNote: Tileset limit may have prevented appending all desired tiles."

        messagebox.showinfo("Append Successful", summary_msg, parent=self.root)


    def _on_mousewheel_scroll(self, event):
        # Generic handler for mousewheel vertical scrolling on canvases.
        canvas = event.widget
        if not canvas.winfo_exists():
            return

        scroll_units = 0
        if event.num == 5 or event.delta < 0:  # Scroll Down
            scroll_units = self.scroll_speed_units
        elif event.num == 4 or event.delta > 0: # Scroll Up
            scroll_units = -self.scroll_speed_units

        if scroll_units != 0:
            try:
                current_view_before_scroll = canvas.yview() # Get view before scroll
                canvas.yview_scroll(scroll_units, "units")
                current_view_after_scroll = canvas.yview()  # Get view after scroll

                # Only redraw if the view actually changed.
                if current_view_before_scroll != current_view_after_scroll:
                    # Identify the canvas and call its specific redraw method
                    if canvas == self.tileset_canvas:
                        self.draw_tileset_viewer(self.tileset_canvas, current_tile_index)
                    elif canvas == self.st_tileset_canvas:
                        self.draw_tileset_viewer(self.st_tileset_canvas, selected_tile_for_supertile)
                    elif canvas == self.supertile_selector_canvas:
                        self.draw_supertile_selector(self.supertile_selector_canvas, current_supertile_index)
                    elif canvas == self.map_canvas:
                        if not (event.state & 0x0004): # If Ctrl key is NOT pressed (mask for Control is 4)
                            self.draw_map_canvas()
                            self.draw_minimap() 
                    elif canvas == self.map_supertile_selector_canvas:
                        self.draw_supertile_selector(self.map_supertile_selector_canvas, selected_supertile_for_map)
                    elif hasattr(self, 'rom_import_dialog') and \
                         self.rom_import_dialog and \
                         tk.Toplevel.winfo_exists(self.rom_import_dialog) and \
                         canvas == getattr(self.rom_import_dialog, 'canvas', None):
                        _debug(" Mousewheel scroll on ROM importer, scheduling direct redraw.")
                        self._schedule_debounced_draw_from_scroll_rom_direct()
                else:
                    _debug(f" Scroll attempted on {canvas} but view did not change (likely at limit). No redraw triggered.")

            except tk.TclError as e:
                _error(f" TclError during yview_scroll/redraw: {e}")
            except Exception as e:
                _error(f" Unexpected error during yview_scroll/redraw: {e}")
        return "break"

    def _schedule_debounced_draw_from_scroll_rom_direct(self):
        # Helper to schedule the debounced draw for the ROM importer canvas.
        current_dialog = getattr(self, 'rom_import_dialog', None)
        if not current_dialog or not tk.Toplevel.winfo_exists(current_dialog): return
        if not hasattr(current_dialog, 'redraw_timer_id'): current_dialog.redraw_timer_id = None

        if current_dialog.redraw_timer_id is not None:
            try:
                current_dialog.after_cancel(current_dialog.redraw_timer_id)
            except tk.TclError:
                pass # Timer might have already fired
        current_dialog.redraw_timer_id = current_dialog.after(30, self._perform_debounced_rom_canvas_draw)

    def _calculate_color_usage_data(self):
        # Calculates usage counts for each of the 16 active palette slots.
        # It calls the granular _calculate_single_color_usage for each slot.
        results = []
        if not self.active_msx_palette or len(self.active_msx_palette) != 16:
            _debug(" _calculate_color_usage_data: Active MSX palette is not ready.")
            # Return placeholder data if palette is invalid
            for i in range(16):
                results.append({
                    'slot_index': i,
                    'current_color_hex': "#FF00FF",
                    'pixel_uses_count': 0,
                    'line_refs_count': 0,
                    'tile_refs_count': 0
                })
            return results

        for p_idx in range(16): # For each of the 16 palette slots
            current_color_hex = self.active_msx_palette[p_idx]
            
            # Use the new helper to get all usage stats for this slot
            pixel_uses, line_refs, tile_refs = self._calculate_single_color_usage(p_idx)

            results.append({
                'slot_index': p_idx,
                'current_color_hex': current_color_hex,
                'pixel_uses_count': pixel_uses,
                'line_refs_count': line_refs,
                'tile_refs_count': tile_refs
            })
            
        return results

    def toggle_color_usage_window(self):
        # Toggles the visibility of the Color Usage window.
        if self.color_usage_window is None or not tk.Toplevel.winfo_exists(self.color_usage_window):
            _debug(" Creating new Color Usage window.")
            self.color_usage_window = ColorUsageWindow(self) # Pass self (the app instance)
        else:
            _debug(" Lifting existing Color Usage window.")
            self.color_usage_window.lift()
            self.color_usage_window.focus_set()
            if hasattr(self.color_usage_window, 'refresh_data'): # If it has a refresh method
                self.color_usage_window.refresh_data() # Refresh when brought to front

    def synchronize_selection_from_usage_window(self, item_type, index):
        _debug(f"\n Synchronizing from USAGE WINDOW: type='{item_type}', index={index}")
        global selected_color_index, current_tile_index, selected_tile_for_supertile 
        global current_supertile_index, selected_supertile_for_map 

        if item_type == "color":
            if not (0 <= index <= 15):
                _debug(f"   Invalid color slot index {index}. Sync aborted.")
                return

            try:
                self.selected_palette_slot = index
                selected_color_index = index

                def do_final_color_updates():
                    self.update_all_displays(changed_level="all") 
                    self.root.lift()
                    _debug(f"   Color sync: Finished.")

                needs_switch = False
                if self.notebook.winfo_exists():
                    current_tab_widget = self.notebook.nametowidget(self.notebook.select())
                    if current_tab_widget != self.tab_tile_editor:
                        needs_switch = True
                
                if needs_switch:
                    _debug(f"   Color sync: Current tab is not Tile Editor. Switching to Palette Editor.")
                    if self.tab_palette_editor.winfo_exists():
                        self.notebook.select(self.tab_palette_editor)
                        self.root.after(10, do_final_color_updates)
                    else:
                        _debug("   Sync: Palette editor tab not available for switch.")
                else:
                    do_final_color_updates()

            except tk.TclError as e:
                _error(f"   TclError during color selection synchronization: {e}")
            except Exception as e:
                _error(f"   Unexpected error during color selection synchronization: {e}")

        elif item_type == "tile":
            if not (0 <= index < len(tileset_patterns)): 
                _error(f"   Invalid tile index {index} (len(tileset_patterns): {len(tileset_patterns)}). Sync aborted.")
                return
            
            try:
                active_tab_widget = self.notebook.nametowidget(self.notebook.select())
                
                current_tile_index = index
                if active_tab_widget == self.tab_supertile_editor:
                    selected_tile_for_supertile = index

                def do_final_tile_updates():
                    self.update_all_displays(changed_level="all") 
                    self.scroll_viewers_to_tile(index) 
                    self.root.lift() 
                    _debug(f"   Tile sync: Finished.")

                needs_switch = False
                if active_tab_widget not in [self.tab_tile_editor, self.tab_supertile_editor]:
                    needs_switch = True

                if needs_switch:
                    _debug(f"   Tile sync: Current tab is not Tile/Supertile Editor. Switching to Tile Editor.")
                    if self.tab_tile_editor.winfo_exists():
                        self.notebook.select(self.tab_tile_editor)
                        self.root.after(10, do_final_tile_updates)
                    else:
                        _debug("   Sync: Tile editor tab not available for switch.")
                else:
                    do_final_tile_updates()

            except tk.TclError as e:
                _error(f"   TclError during tile selection synchronization: {e}")
            except Exception as e:
                _error(f"   Unexpected error during tile selection synchronization: {e}")

        elif item_type == "supertile":
            if not (0 <= index < len(supertiles_data)):
                _error(f"   Invalid supertile index {index} (len(supertiles_data): {len(supertiles_data)}). Sync aborted.")
                return
            
            try:
                _debug(f"   ST Sync: Starting for index {index}.")
                current_supertile_index = index
                selected_supertile_for_map = index

                def do_final_st_updates():
                    self.update_all_displays(changed_level="all")
                    self.scroll_selectors_to_supertile(index)
                    self.root.after_idle(lambda: self._redraw_active_st_selector(index)) # Final redraw after scroll
                    self.root.lift()
                    _debug(f"   ST Sync: Finished for index {index}.")

                # Determine which tab should be active after the sync
                active_tab_widget_before_switch = self.notebook.nametowidget(self.notebook.select())
                
                target_tab_to_ensure_visible = self.tab_supertile_editor
                # If user is on the map, keep them there
                if active_tab_widget_before_switch == self.tab_map_editor:
                    target_tab_to_ensure_visible = self.tab_map_editor
                
                # If we need to switch tabs
                if active_tab_widget_before_switch != target_tab_to_ensure_visible:
                    if target_tab_to_ensure_visible.winfo_exists():
                        self.notebook.select(target_tab_to_ensure_visible)
                        self.root.after(10, do_final_st_updates) # Delay to allow tab switch
                    else:
                        _debug(f"   ST Sync: Target tab not available for switch.")
                else: # No tab switch needed, just update
                    do_final_st_updates()
            except tk.TclError as e:
                _error(f"   TclError during supertile selection synchronization: {e}")
            except Exception as e:
                _error(f"   Unexpected error during supertile selection synchronization: {e}")
        else:
            _error(f"   Unknown item_type '{item_type}' for synchronization.")

    def _request_color_usage_refresh(self):
        # Helper to request a refresh of the color usage window if it's open.
        if self.color_usage_window and \
           tk.Toplevel.winfo_exists(self.color_usage_window) and \
           self.color_usage_window.winfo_ismapped(): # Check if mapped (visible)
            if hasattr(self.color_usage_window, 'request_refresh'):
                self.color_usage_window.request_refresh()
            else:
                _debug(" ColorUsageWindow does not have request_refresh method.")
        # else: window doesn't exist or isn't visible, no action.

    def _handle_editor_paint_release(self, event):
        global last_drawn_pixel
        
        if self.pending_command_list:
            # Group all the individual pixel changes into a single undoable action
            composite = CompositeCommand("Paint Stroke", self.pending_command_list[:], self)
            self.undo_manager.register(composite) # Use register for pre-executed commands
            self.pending_command_list.clear()

        if self.is_currently_painting_tile:
            # Refresh all usage windows once at the end of the drawing action.
            self._request_color_usage_refresh()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()
            self.is_currently_painting_tile = False
            
        last_drawn_pixel = None

    def _calculate_tile_usage_data(self):
        # Calculates usage counts for each tile in the current tileset by
        # calling the new, granular _calculate_single_tile_usage method.
        results = []
        # Iterate only up to the current number of active tiles
        for t_idx in range(len(tileset_patterns)):
            # Call the new helper to get the counts for this specific tile
            total_uses, unique_sts = self._calculate_single_tile_usage(t_idx)
            
            # Append the results in the dictionary format expected by the TileUsageWindow
            results.append({
                'tile_index': t_idx,
                'total_uses_count': total_uses,
                'used_by_sts_count': unique_sts
            })
        return results

    def toggle_tile_usage_window(self):
        # Toggles the visibility of the Tile Usage window.
        if self.tile_usage_window is None or not tk.Toplevel.winfo_exists(self.tile_usage_window):
            _debug(" Creating new Tile Usage window.")
            self.tile_usage_window = TileUsageWindow(self) # Pass self (the app instance)
        else:
            # Window exists, lift and focus it.
            _debug(" Lifting existing Tile Usage window.")
            self.tile_usage_window.lift()
            self.tile_usage_window.focus_set()

    def _request_tile_usage_refresh(self):
        # Helper to request a refresh of the tile usage window if it's open and visible.
        if self.tile_usage_window and \
           tk.Toplevel.winfo_exists(self.tile_usage_window) and \
           self.tile_usage_window.winfo_ismapped(): # Check if mapped (visible)
            if hasattr(self.tile_usage_window, 'request_refresh'):
                self.tile_usage_window.request_refresh()
            else:
                _debug(" TileUsageWindow does not have request_refresh method.")

    def toggle_supertile_usage_window(self):
        if self.supertile_usage_window is None or not tk.Toplevel.winfo_exists(self.supertile_usage_window):
            _debug(" Creating new Supertile Usage window.")
            self.supertile_usage_window = SupertileUsageWindow(self)
        else:
            _debug(" Lifting existing Supertile Usage window.")
            self.supertile_usage_window.lift()
            self.supertile_usage_window.focus_set()

    def _calculate_supertile_usage_data(self):
        results = []
        for st_idx in range(len(supertiles_data)):
            map_usage, _ = self._get_info_for_single_supertile(st_idx)
            
            results.append({
                'st_index': st_idx,
                'uses_on_map_count': map_usage
            })
        return results

    def _request_supertile_usage_refresh(self):
        # Helper to request a refresh of the supertile usage window if it's open and visible.
        if self.supertile_usage_window and \
           tk.Toplevel.winfo_exists(self.supertile_usage_window) and \
           self.supertile_usage_window.winfo_ismapped(): # Check if mapped (visible)
            if hasattr(self.supertile_usage_window, 'request_refresh'):
                self.supertile_usage_window.request_refresh()
            else:
                _debug(" SupertileUsageWindow does not have request_refresh method.")
        # else: window doesn't exist or isn't visible, no action.

    def create_cropped_supertile_preview_for_usage_window(self, supertile_index, 
                                                          # target_image_content_area_width is the available space in col #0
                                                          target_image_content_area_width_in_col0, 
                                                          final_photo_target_height): 
        # --- Part 1: Calculate actual scaled dimensions of the supertile content ---
        actual_content_msx_w = self.supertile_grid_width * TILE_WIDTH
        actual_content_msx_h = self.supertile_grid_height * TILE_HEIGHT

        temp_full_photo_w = actual_content_msx_w * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL
        temp_full_photo_h = actual_content_msx_h * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL
        
        temp_full_photo_w = max(1, int(temp_full_photo_w))
        temp_full_photo_h = max(1, int(temp_full_photo_h))

        # --- Part 2: Create temp_full_photo with actual scaled content dimensions ---
        try:
            temp_full_photo = tk.PhotoImage(width=temp_full_photo_w, height=temp_full_photo_h)
        except tk.TclError as e:
            _error(f" Error creating temp_full_photo ({temp_full_photo_w}x{temp_full_photo_h}): {e}")
            # Fallback placeholder if temp_full_photo creation fails
            placeholder_w = max(1, int(target_image_content_area_width_in_col0))
            placeholder_h = max(1, int(final_photo_target_height))
            ph_photo = tk.PhotoImage(width=placeholder_w, height=placeholder_h)
            try:
                ph_photo.put(INVALID_SUPERTILE_COLOR, to=(0, 0, placeholder_w, placeholder_h))
            except tk.TclError: pass
            return ph_photo

        # --- Part 3: Render supertile content onto temp_full_photo ---
        if not (0 <= supertile_index < len(supertiles_data)):
            temp_full_photo.put(INVALID_SUPERTILE_COLOR, to=(0,0, temp_full_photo_w, temp_full_photo_h))
        else:
            definition = supertiles_data[supertile_index]
            if not (definition and 
                    len(definition) == self.supertile_grid_height and
                    (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0)):
                temp_full_photo.put(INVALID_SUPERTILE_COLOR, to=(0,0, temp_full_photo_w, temp_full_photo_h))
            else:
                # No initial green fill here; temp_full_photo should be fully covered by actual content or error colors
                px_per_base_tile_w_on_temp = TILE_WIDTH * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL
                px_per_base_tile_h_on_temp = TILE_HEIGHT * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL

                for r_st_def in range(self.supertile_grid_height):
                    for c_st_def in range(self.supertile_grid_width):
                        tile_idx_val = definition[r_st_def][c_st_def]
                        base_tile_draw_x = int(c_st_def * px_per_base_tile_w_on_temp)
                        base_tile_draw_y = int(r_st_def * px_per_base_tile_h_on_temp)

                        if not (0 <= tile_idx_val < len(tileset_patterns)):
                            for y_fill_inv in range(int(px_per_base_tile_h_on_temp)):
                                for x_fill_inv in range(int(px_per_base_tile_w_on_temp)):
                                    dest_x_inv = base_tile_draw_x + x_fill_inv
                                    dest_y_inv = base_tile_draw_y + y_fill_inv
                                    if dest_x_inv < temp_full_photo_w and dest_y_inv < temp_full_photo_h:
                                        temp_full_photo.put(INVALID_TILE_COLOR, to=(dest_x_inv, dest_y_inv))
                            continue
                        pattern = tileset_patterns[tile_idx_val]
                        colors = tileset_colors[tile_idx_val]
                        for r_msx in range(TILE_HEIGHT): 
                            fg_idx, bg_idx = WHITE_IDX, BLACK_IDX 
                            if r_msx < len(colors): fg_idx, bg_idx = colors[r_msx]
                            safe_fg_idx = fg_idx if 0 <= fg_idx < 16 else WHITE_IDX
                            safe_bg_idx = bg_idx if 0 <= bg_idx < 16 else BLACK_IDX
                            fg_color_hex = self.active_msx_palette[safe_fg_idx]
                            bg_color_hex = self.active_msx_palette[safe_bg_idx]
                            row_pattern_data_list = []
                            if r_msx < len(pattern): row_pattern_data_list = pattern[r_msx]
                            for c_msx in range(TILE_WIDTH):
                                pixel_pattern_bit = 0
                                if c_msx < len(row_pattern_data_list): pixel_pattern_bit = row_pattern_data_list[c_msx]
                                color_to_draw_hex = fg_color_hex if pixel_pattern_bit == 1 else bg_color_hex
                                for y_offset_in_block in range(SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL):
                                    for x_offset_in_block in range(SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL):
                                        dest_screen_x = base_tile_draw_x + (c_msx * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL) + x_offset_in_block
                                        dest_screen_y = base_tile_draw_y + (r_msx * SUPERTILE_USAGE_SCREEN_PIXELS_PER_MSX_PIXEL) + y_offset_in_block
                                        if dest_screen_x < temp_full_photo_w and dest_screen_y < temp_full_photo_h:
                                            try:
                                                temp_full_photo.put(color_to_draw_hex, to=(dest_screen_x, dest_screen_y))
                                            except tk.TclError: break 
                                    else: continue
                                    break 

        # --- Part 4: Determine final_photo_width and create final_photo ---
        # final_photo_width is the minimum of the actual scaled content width and the available column area
        calculated_final_photo_width = min(temp_full_photo_w, max(1, int(target_image_content_area_width_in_col0)))
        
        # final_photo_height is the target row height for the Treeview cell
        final_photo_height = max(1, int(final_photo_target_height)) 
        
        final_photo = tk.PhotoImage(width=calculated_final_photo_width, height=final_photo_height)
        
        if supertile_index == 0: # Debug
             _debug(f"[STP DEBUG {supertile_index}] temp_full_photo WxH: {temp_full_photo_w}x{temp_full_photo_h}")
             _debug(f"[STP DEBUG {supertile_index}] target_image_content_area_width_in_col0: {target_image_content_area_width_in_col0}")
             _debug(f"[STP DEBUG {supertile_index}] final_photo will be WxH: {calculated_final_photo_width}x{final_photo_height}")

        # --- Part 5: Fill final_photo with background ---
        hex_bg_color_final = "#F0F0F0" 
        try:
            system_bg_name = "SystemButtonFace" 
            rgb_tuple = self.root.winfo_rgb(system_bg_name) 
            r_8bit, g_8bit, b_8bit = rgb_tuple[0]//256, rgb_tuple[1]//256, rgb_tuple[2]//256
            hex_bg_color_final = f"#{r_8bit:02x}{g_8bit:02x}{b_8bit:02x}"
        except tk.TclError: pass 
        final_photo.put(hex_bg_color_final, to=(0,0, calculated_final_photo_width, final_photo_height))

        # --- Part 6: Copy/Crop from temp_full_photo to final_photo, vertically centering ---
        # Width to copy from source is limited by final_photo's (potentially cropped) width
        width_to_copy_from_source = calculated_final_photo_width 
        # Height to copy from source is the actual content height from temp_full_photo
        height_to_copy_from_source = temp_full_photo_h 

        if width_to_copy_from_source > 0 and height_to_copy_from_source > 0:
            y_offset_for_centering = 0
            if final_photo.height() > temp_full_photo.height(): # If row is taller than content
                y_offset_for_centering = (final_photo.height() - temp_full_photo.height()) // 2
            y_offset_for_centering = max(0, y_offset_for_centering)

            try:
                # Copy from temp_full_photo (0,0) up to (width_to_copy_from_source, height_to_copy_from_source)
                # To final_photo at (0, y_offset_for_centering)
                final_photo.tk.call(final_photo, 'copy', temp_full_photo,
                                    '-from', 0, 0, width_to_copy_from_source, height_to_copy_from_source,
                                    '-to', 0, y_offset_for_centering)
                if supertile_index == 0: _debug(f"[STP DEBUG {supertile_index}] Copied {width_to_copy_from_source}x{height_to_copy_from_source} from temp to final at y_offset {y_offset_for_centering}")
            except tk.TclError as e:
                _error(f" Error during PhotoImage copy for ST preview: {e}")
        
        return final_photo

    # --- Usage Window Config Management Helpers (NEW) ---
    def _get_config_filepath(self):
        """Constructs the path to the usage windows configuration file."""
        try:
            # Use appauthor=False to avoid creating an extra subdirectory for the author.
            # The directory structure will be like: .../AppConfigDir/MSXTileForge/
            config_dir = platformdirs.user_config_dir(self.config_app_name, appauthor=False,ensure_exists=True)
            return os.path.join(config_dir, self.config_file_name)
        except Exception as e:
            _error(f"Could not determine or create config directory using platformdirs: {e}")
            # Fallback to alongside the executable/script if platformdirs fails or is unavailable
            # This requires msxtileforge.py to be in a writable location if packaged.
            try:
                base_path = os.path.dirname(os.path.abspath(__file__))
                return os.path.join(base_path, self.config_file_name)
            except NameError: # __file__ is not defined (e.g. interactive, or frozen app without proper setup)
                 _error(f"__file__ not defined, falling back to CWD for config: {self.config_file_name}")
                 return self.config_file_name


    def _load_app_settings(self):
        # Loads usage window configurations from the JSON file into self.app_settings.
        filepath = self._get_config_filepath()
        
        # Start with empty defaults
        self.app_settings = {'recent_files': {'projects': [], 'modules': []}}

        try:
            if os.path.exists(filepath) and os.path.getsize(filepath) > 0:
                with open(filepath, 'r') as f:
                    loaded_data = json.load(f)
                    if isinstance(loaded_data, dict):
                        # Load all other settings directly
                        self.app_settings.update(loaded_data)
                        _debug(" _load_app_settings: Settings loaded from file.")
                    else:
                        _error(f"_load_app_settings: Config file did not contain a valid JSON object. Using defaults.")
            else:
                _info(f" _load_app_settings: Window configuration file not found or empty. Using defaults.")
        
        except (json.JSONDecodeError, IOError, OSError) as e:
            _error(f" _load_app_settings: Failed to load configurations from {filepath}: {e}")
        except Exception as e_generic:
            _error(f" _load_app_settings: Unexpected error loading configurations: {e_generic}")

        # --- Sanitize Recent Files List After Loading ---
        # Get the raw lists that were loaded from the JSON file.
        raw_projects = self.app_settings.get('recent_files', {}).get('projects', [])
        raw_modules = self.app_settings.get('recent_files', {}).get('modules', [])

        # Clear the lists in memory before rebuilding them.
        self.app_settings['recent_files']['projects'] = []
        self.app_settings['recent_files']['modules'] = []
        
        # Rebuild the lists by passing each item through the robust add function.
        # This sanitizes, deduplicates, and normalizes the paths.
        # We iterate in reverse to maintain the original order (since each add prepends).
        _debug(f" Sanitizing loaded recent projects list: {raw_projects}")
        for path in reversed(raw_projects):
            self._add_to_recent_list('projects', path)
        
        _debug(f" Sanitizing loaded recent modules list: {raw_modules}")
        for path in reversed(raw_modules):
            self._add_to_recent_list('modules', path)
        
        _debug(f" Final sanitized recent projects: {self.app_settings['recent_files']['projects']}")

    def _save_app_settings(self):
        # Gathers current states of windows and saves the entire settings dictionary.
        filepath = self._get_config_filepath()
        try:
            _debug(f" Preparing to save application settings to: {filepath}")

            # Capture final main window geometry and sash positions just before saving
            if self.root.winfo_exists():
                self.app_settings['main_window_geometry'] = self.root.winfo_geometry()
            if hasattr(self, 'map_paned_window') and self.map_paned_window.winfo_exists():
                try:
                    self.app_settings['map_editor_sash_pos'] = self.map_paned_window.sashpos(0)
                except tk.TclError:
                    pass # Ignore if sash doesn't exist
            
            # Note: The supertile editor paned window doesn't have a direct reference.
            # We will handle its saving via its configure/release bindings.

            self.app_settings['last_opened_project'] = self.current_project_base_path
            
            all_known_window_types = ["ColorUsageWindow", "TileUsageWindow", "SupertileUsageWindow"]
            for window_name in all_known_window_types:
                if window_name not in self.app_settings:
                    self.app_settings[window_name] = {'is_open': False}
                elif 'is_open' not in self.app_settings[window_name]:
                    instance_was_found_open = False
                    if window_name == "ColorUsageWindow" and getattr(self, 'color_usage_window', None) and tk.Toplevel.winfo_exists(self.color_usage_window):
                        instance_was_found_open = True
                    elif window_name == "TileUsageWindow" and getattr(self, 'tile_usage_window', None) and tk.Toplevel.winfo_exists(self.tile_usage_window):
                        instance_was_found_open = True
                    elif window_name == "SupertileUsageWindow" and getattr(self, 'supertile_usage_window', None) and tk.Toplevel.winfo_exists(self.supertile_usage_window):
                        instance_was_found_open = True
                    
                    if not instance_was_found_open:
                         self.app_settings[window_name]['is_open'] = False

            with open(filepath, 'w') as f:
                json.dump(self.app_settings, f, indent=4, sort_keys=True)
            _debug(" Successfully saved all application settings.")

        except (IOError, OSError, tk.TclError) as e:
            _error(f" Failed to save application settings to {filepath}: {e}")
        except Exception as e_generic:
            _error(f" Unexpected error saving application settings: {e_generic}")

    def get_window_config(self, window_class_name):
        """
        Returns the saved configuration dictionary for a specific window class name.
        Returns an empty dictionary if no configuration is found.
        """
        # Ensure self.app_settings is initialized if called before full app init
        if not hasattr(self, 'app_settings'):
            self.app_settings = {}
            self._load_app_settings() # Attempt to load if not already loaded

        return self.app_settings.get(window_class_name, {}).copy() # Return a copy


    def update_window_config(self, window_class_name, geometry=None, tree_config=None, is_open=None):
        """
        Updates the in-memory configuration (self.app_settings) for a specific window.
        This does NOT write to disk.
        tree_config should be a dict: {'sort_column_id': '...', 'sort_asc': True/False, 'column_widths': {'col_id': width, ...}}
        """
        if not hasattr(self, 'app_settings'): # Should have been initialized
            self.app_settings = {}
        
        if window_class_name not in self.app_settings:
            self.app_settings[window_class_name] = {}

        config_entry = self.app_settings[window_class_name]

        if geometry is not None:
            config_entry['geometry'] = geometry
        if tree_config is not None:
            if 'sort_column_id' in tree_config:
                config_entry['sort_column_id'] = tree_config['sort_column_id']
            if 'sort_asc' in tree_config:
                config_entry['sort_asc'] = tree_config['sort_asc']
            if 'column_widths' in tree_config:
                # Ensure column_widths is a dict before trying to update it
                if 'column_widths' not in config_entry or not isinstance(config_entry.get('column_widths'), dict):
                    config_entry['column_widths'] = {}
                config_entry['column_widths'].update(tree_config['column_widths']) # Merge/update widths
        if is_open is not None:
            config_entry['is_open'] = is_open
        
        _debug(f" In-memory config updated for {window_class_name}. IsOpen: {config_entry.get('is_open')}, Geo: {config_entry.get('geometry')}")

    def _gather_open_window_states(self, final_save=False):
        # Updates self.app_settings with the current state of any instantiated and visible usage windows.
        _debug(f" _gather_open_window_states: Method entered (final_save={final_save}).")

        window_details = [
            ("ColorUsageWindow", getattr(self, 'color_usage_window', None)),
            ("TileUsageWindow", getattr(self, 'tile_usage_window', None)),
            ("SupertileUsageWindow", getattr(self, 'supertile_usage_window', None))
        ]

        for name, instance in window_details:
            if instance and tk.Toplevel.winfo_exists(instance):
                current_geometry = ""
                tree_config_data = {}
                try:
                    current_geometry = instance.winfo_geometry()
                    if hasattr(instance, '_get_current_tree_config'):
                        tree_config_data = instance._get_current_tree_config()
                    
                    self.update_window_config(
                        name,
                        geometry=current_geometry,
                        tree_config=tree_config_data,
                        is_open=True
                    )
                    _debug(f" _gather_open_window_states: Gathered state for OPEN window {name}.")
                except tk.TclError as e:
                    _error(f" _gather_open_window_states: TclError gathering state for {name}: {e}")
                    if final_save:
                         self.update_window_config(name, is_open=False)

            elif final_save:
                self.update_window_config(name, is_open=False)
                _debug(f" _gather_open_window_states: Marked {name} as closed for final save.")
        _debug(f" _gather_open_window_states: Method finished. Current app_settings: {self.app_settings}")

    def _restore_window_states(self):
        # Opens usage windows after application start or project load.
        _debug(" _restore_window_states: Method entered. Preparing to restore windows.")
        _debug(f" _restore_window_states: Reading from this app_settings: {self.app_settings}")
        
        window_toggle_map = {
            "ColorUsageWindow": self.toggle_color_usage_window,
            "TileUsageWindow": self.toggle_tile_usage_window,
            "SupertileUsageWindow": self.toggle_supertile_usage_window
        }

        for window_name, toggle_function in window_toggle_map.items():
            config = self.app_settings.get(window_name, {})
            should_be_open = config.get('is_open', False)

            current_instance = None
            if window_name == "ColorUsageWindow": current_instance = self.color_usage_window
            elif window_name == "TileUsageWindow": current_instance = self.tile_usage_window
            elif window_name == "SupertileUsageWindow": current_instance = self.supertile_usage_window

            is_currently_open = current_instance is not None and tk.Toplevel.winfo_exists(current_instance)

            _debug(f"   _restore_window_states: Checking {window_name}: should_be_open={should_be_open}, is_currently_open={is_currently_open}")

            if should_be_open and not is_currently_open:
                _debug(f"     _restore_window_states: --> Calling toggle function for {window_name}.")
                toggle_function()
        _debug(" _restore_window_states: Method finished.")

    def _calculate_tile_usage_in_single_supertile(self, tile_index, supertile_index):
        if not (0 <= tile_index < len(tileset_patterns) and 0 <= supertile_index < len(supertiles_data)):
            return 0

        count = 0
        st_definition = supertiles_data[supertile_index]

        if not st_definition or len(st_definition) != self.supertile_grid_height or \
           (self.supertile_grid_height > 0 and len(st_definition[0]) != self.supertile_grid_width):
            return 0

        for r in range(self.supertile_grid_height):
            for c in range(self.supertile_grid_width):
                if st_definition[r][c] == tile_index:
                    count += 1
        return count

    def _calculate_single_tile_usage(self, tile_index_to_check):
        total_placements = 0
        unique_supertiles_that_use_it = set()

        if not (0 <= tile_index_to_check < len(tileset_patterns)):
            return 0, 0

        for st_idx in range(len(supertiles_data)):
            local_count = self._calculate_tile_usage_in_single_supertile(tile_index_to_check, st_idx)

            if local_count > 0:
                total_placements += local_count
                unique_supertiles_that_use_it.add(st_idx)
        
        return total_placements, len(unique_supertiles_that_use_it)

    def _update_selected_tile_info_panel(self, update_usage_counts=True):
        """Updates the new selected tile info panel with the image and usage counts."""
        if not hasattr(self, 'selected_tile_preview_canvas'):
            return # Panel not yet created, do nothing

        # Update the tile number label
        self.selected_tile_info_label.config(text=f"Tile: {current_tile_index}")
        
        # Update the live preview image on the canvas
        preview_size = 48 # Use the fixed size defined during widget creation
        img = self.create_tile_image(current_tile_index, preview_size)
        self.selected_tile_preview_image_ref = img # Keep a reference to prevent garbage collection
        self.selected_tile_preview_canvas.delete("all")
        self.selected_tile_preview_canvas.create_image(0, 0, image=img, anchor=tk.NW)

        # Conditionally update usage counts for better performance during live drawing
        if update_usage_counts:
            placements, unique_sts = self._calculate_single_tile_usage(current_tile_index)
            self.selected_tile_usage_label.config(text=f"Used {placements} times in {unique_sts} supertiles.")

            # Conditionally style the label using shared font objects
            if unique_sts > 0:
                self.selected_tile_usage_label.config(
                    fg="blue", 
                    font=self.link_font, # Use shared font
                    cursor="hand2"
                )
            else:
                default_fg = self.selected_tile_info_label.cget("foreground")
                if not default_fg:
                    default_fg = "#000000" # Fallback color
                self.selected_tile_usage_label.config(
                    fg=default_fg,
                    font=self.normal_font, # Use shared font
                    cursor=""
                )

    def _calculate_single_color_usage(self, slot_index, return_set=False):
        """Calculates pixel, line, and unique tile usage for a single palette slot index."""
        pixel_uses = 0
        line_references = 0
        tile_references_set = set()

        if not (0 <= slot_index < 16):
            if return_set:
                return 0, 0, set()
            return 0, 0, 0 

        for tile_idx in range(len(tileset_patterns)):
            tile_uses_this_slot = False
            if tile_idx >= len(tileset_colors): continue

            for row_idx in range(TILE_HEIGHT):
                if row_idx >= len(tileset_colors[tile_idx]): continue
                
                fg_slot, bg_slot = tileset_colors[tile_idx][row_idx]
                line_uses_this_slot_this_row = False

                if fg_slot == slot_index:
                    line_references += 1
                    tile_uses_this_slot = True
                    line_uses_this_slot_this_row = True
                
                if bg_slot == slot_index and fg_slot != slot_index:
                    line_references += 1
                    tile_uses_this_slot = True
                    line_uses_this_slot_this_row = True
                elif bg_slot == slot_index and fg_slot == slot_index:
                    tile_uses_this_slot = True

                if line_uses_this_slot_this_row:
                    if tile_idx >= len(tileset_patterns) or row_idx >= len(tileset_patterns[tile_idx]): continue
                    
                    for col_idx in range(TILE_WIDTH):
                        if col_idx >= len(tileset_patterns[tile_idx][row_idx]): continue
                        
                        pixel_val = tileset_patterns[tile_idx][row_idx][col_idx]
                        if pixel_val == 1 and fg_slot == slot_index:
                            pixel_uses += 1
                        elif pixel_val == 0 and bg_slot == slot_index:
                            pixel_uses += 1
            
            if tile_uses_this_slot:
                tile_references_set.add(tile_idx)

        if return_set:
            return pixel_uses, line_references, tile_references_set
        else:
            return pixel_uses, line_references, len(tile_references_set)

    def _get_info_for_single_supertile(self, supertile_index):
        map_usage_count = 0
        if 0 <= supertile_index < len(supertiles_data):
            for r in range(map_height):
                for c in range(map_width):
                    if 0 <= r < len(map_data) and 0 <= c < len(map_data[r]):
                        if map_data[r][c] == supertile_index:
                            map_usage_count += 1
                    else:
                        _debug(f" Map data access out of bounds for ({r},{c}) in _get_info_for_single_supertile")

        unique_tile_count = 0
        if 0 <= supertile_index < len(supertiles_data):
            unique_tiles = set()
            st_definition = supertiles_data[supertile_index]
            if st_definition and len(st_definition) == self.supertile_grid_height and \
               (self.supertile_grid_height == 0 or (self.supertile_grid_width > 0 and len(st_definition[0]) == self.supertile_grid_width) or self.supertile_grid_width == 0):
                for r_st in range(self.supertile_grid_height):
                    for c_st in range(self.supertile_grid_width):
                        unique_tiles.add(st_definition[r_st][c_st])
                unique_tile_count = len(unique_tiles)
            else:
                _warning(f"Cannot calculate composition for malformed supertile {supertile_index}")

        return map_usage_count, unique_tile_count

    def create_supertile_preview_image(self, supertile_index, box_width, box_height):
        final_photo = tk.PhotoImage(width=box_width, height=box_height)
        try:
            bg_color = self.root.cget("bg")
            final_photo.put(bg_color, to=(0, 0, box_width, box_height))
        except (tk.TclError, AttributeError):
            final_photo.put("#F0F0F0", to=(0, 0, box_width, box_height))

        st_width_msx = self.supertile_grid_width * TILE_WIDTH
        st_height_msx = self.supertile_grid_height * TILE_HEIGHT

        if st_width_msx <= 0 or st_height_msx <= 0:
             return final_photo

        pil_supertile_native = self.create_map_render_of_supertile(
            supertile_index,
            st_width_msx,
            st_height_msx
        )

        if not pil_supertile_native:
            return final_photo

        scale_x = box_width / st_width_msx
        scale_y = box_height / st_height_msx
        scale = min(scale_x, scale_y)

        scaled_width = int(st_width_msx * scale)
        scaled_height = int(st_height_msx * scale)

        if scaled_width < 1 or scaled_height < 1:
            return final_photo

        pil_supertile_scaled = pil_supertile_native.resize(
            (scaled_width, scaled_height),
            Image.Resampling.NEAREST
        )

        temp_photo = ImageTk.PhotoImage(pil_supertile_scaled)

        paste_x = (box_width - scaled_width) // 2
        paste_y = (box_height - scaled_height) // 2

        final_photo.tk.call(final_photo, 'copy', temp_photo, '-from', 0, 0, scaled_width, scaled_height, '-to', paste_x, paste_y)

        return final_photo

    def _update_selected_supertile_info_panel(self):
        if not hasattr(self, 'selected_supertile_preview_canvas') or \
           not self.selected_supertile_preview_canvas.winfo_exists():
            return

        self.selected_supertile_info_label.config(text=f"Supertile: {current_supertile_index}")

        preview_size = 64
        img = self.create_supertile_preview_image(current_supertile_index, preview_size, preview_size)
        self.selected_supertile_preview_image_ref = img
        self.selected_supertile_preview_canvas.delete("all")
        self.selected_supertile_preview_canvas.create_image(0, 0, image=img, anchor=tk.NW)

        map_usage_count, unique_tile_count = self._get_info_for_single_supertile(current_supertile_index)

        self.selected_supertile_composition_label.config(text=f"Contains {unique_tile_count} unique tiles.")
        
        self.selected_supertile_usage_label.config(text=f"Used {map_usage_count} times on map.")
        
        # Conditionally style the label based on usage count
        if map_usage_count > 0:
            self.selected_supertile_usage_label.config(
                fg="blue", 
                font=self.link_font, # Use shared font
                cursor="hand2"
            )
        else:
            # Get default text color from a sibling widget for theme compatibility
            default_fg = self.selected_supertile_info_label.cget("foreground")
            if not default_fg:
                default_fg = "#000000" # Fallback color
            self.selected_supertile_usage_label.config(
                fg=default_fg,
                font=self.normal_font, # Use shared font
                cursor=""
            )

    def _update_st_tab_selected_tile_info_panel(self):
        if not hasattr(self, 'st_tab_selected_tile_preview_canvas') or \
           not self.st_tab_selected_tile_preview_canvas.winfo_exists():
            return

        tile_to_show = selected_tile_for_supertile

        self.st_tab_selected_tile_info_label.config(text=f"Tile: {tile_to_show}")

        preview_size = 64
        img = self.create_tile_image(tile_to_show, preview_size)
        self.st_tab_selected_tile_preview_image_ref = img
        self.st_tab_selected_tile_preview_canvas.delete("all")
        self.st_tab_selected_tile_preview_canvas.create_image(0, 0, image=img, anchor=tk.NW)

        local_usage = self._calculate_tile_usage_in_single_supertile(tile_to_show, current_supertile_index)
        self.st_tab_local_usage_label.config(text=f"Used {local_usage} times in the current supertile.")

        global_placements, global_unique_sts = self._calculate_single_tile_usage(tile_to_show)
        
        self.st_tab_global_usage_label.config(text=f"Used {global_placements} times in {global_unique_sts} supertiles.")
        
        # Conditionally style the global usage label
        if global_unique_sts > 0:
            self.st_tab_global_usage_label.config(
                fg="blue", 
                font=self.link_font,
                cursor="hand2"
            )
        else:
            default_fg = self.st_tab_selected_tile_info_label.cget("foreground")
            if not default_fg:
                default_fg = "#000000" # Fallback color
            self.st_tab_global_usage_label.config(
                fg=default_fg,
                font=self.normal_font,
                cursor=""
            )

    def _add_to_recent_list(self, list_type, path):
        """Adds a path to the specified recent list, sanitizing the whole list to ensure no duplicates."""
        if not path:
            return

        # Normalize the incoming path to a consistent, comparable format.
        normalized_path_to_add = os.path.normcase(os.path.normpath(path))

        if 'recent_files' not in self.app_settings:
            self.app_settings['recent_files'] = {'projects': [], 'modules': []}

        # Get the current list from settings.
        original_list = self.app_settings['recent_files'].get(list_type, [])
        
        # 1. Sanitize the existing list to remove any historical duplicates, preserving order.
        seen_paths = set()
        sanitized_list = []
        for p in original_list:
            normalized_p = os.path.normcase(os.path.normpath(p))
            if normalized_p not in seen_paths:
                seen_paths.add(normalized_p)
                sanitized_list.append(normalized_p)

        # 2. Remove the item we are about to add from the sanitized list, if it exists.
        final_list = [p for p in sanitized_list if p != normalized_path_to_add]

        # 3. Prepend the new/moved item to the very beginning of the list.
        final_list.insert(0, normalized_path_to_add)

        # Store the cleaned and updated list, truncated to the max length.
        self.app_settings['recent_files'][list_type] = final_list[:MAX_RECENT_FILES]

        self._update_recent_files_menu()

    def _update_recent_files_menu(self):
        # Clears and repopulates the 'Recent' menu from the config data.
        if not self.recent_projects_menu or not tk.Menu.winfo_exists(self.recent_projects_menu) or \
           not self.recent_modules_menu or not tk.Menu.winfo_exists(self.recent_modules_menu):
            return

        projects_list = self.app_settings.get('recent_files', {}).get('projects', [])
        modules_list = self.app_settings.get('recent_files', {}).get('modules', [])

        self.recent_projects_menu.delete(0, tk.END)
        self.recent_modules_menu.delete(0, tk.END)

        # Populate Recent Projects menu
        if not projects_list:
            self.recent_projects_menu.add_command(label="(Empty)", state=tk.DISABLED)
        else:
            for i, path in enumerate(projects_list):
                accelerator_text = ""
                if i < 9: # Items 1-9
                    accelerator_text = f"Ctrl+{i+1}"
                elif i == 9: # 10th item
                    accelerator_text = "Ctrl+0"
                
                # For projects, the path is the base path, so basename is correct.
                display_name = os.path.basename(path)
                
                self.recent_projects_menu.add_command(
                    label=display_name,
                    command=lambda p=path: self._handle_open_project_action(filepath=p, open_mode=OPEN_MODE_RECENT),
                    accelerator=accelerator_text
                )
        self.recent_projects_menu.add_separator()
        self.recent_projects_menu.add_command(label="Clear List", command=lambda: self._clear_recent_list('projects'))

        # Populate Recent Modules menu
        if not modules_list:
            self.recent_modules_menu.add_command(label="(Empty)", state=tk.DISABLED)
        else:
            for i, path in enumerate(modules_list):
                accelerator_text = ""
                if i < 9: # Items 1-9
                    accelerator_text = f"Alt+{i+1}"
                elif i == 9: # 10th item
                    accelerator_text = "Alt+0"
                
                # For modules, show the full filename including the extension.
                display_name = os.path.basename(path)

                self.recent_modules_menu.add_command(
                    label=display_name,
                    command=lambda p=path: self._open_recent_module(p),
                    accelerator=accelerator_text
                )
        self.recent_modules_menu.add_separator()
        self.recent_modules_menu.add_command(label="Clear List", command=lambda: self._clear_recent_list('modules'))

    def _clear_recent_list(self, list_type):
        """Clears a specified recent files list and updates the menu."""
        if messagebox.askokcancel("Confirm Clear", f"Are you sure you want to clear the recent {list_type} list?"):
            if 'recent_files' in self.app_settings:
                self.app_settings['recent_files'][list_type] = []
            self._update_recent_files_menu()

    def _open_recent_module(self, path):
        """Dispatcher to open a module based on its file extension."""
        if not os.path.exists(path):
            self._handle_missing_recent_file('modules', path)
            return

        _, ext = os.path.splitext(path)
        ext = ext.lower()

        if ext in [".sc4pal", ".msxpal"]:
            self.open_palette(filepath=path, is_standalone_operation=True)
        elif ext == ".sc4tiles":
            self.open_tileset(filepath=path, is_standalone_operation=True)
        elif ext == ".sc4super":
            self.open_supertiles(filepath=path, is_standalone_operation=True)
        elif ext == ".sc4map":
            self.open_map(filepath=path, is_standalone_operation=True)
        else:
            messagebox.showerror("Open Error", f"Unknown module file type: {ext}")

    def _handle_missing_recent_file(self, list_type, path):
        """Informs the user that a recent file is missing and offers to remove it."""
        if messagebox.askyesno(
            "File Not Found",
            f"The file '{os.path.basename(path)}' could not be found.\n\nDo you want to remove it from the recent list?"
        ):
            if 'recent_files' in self.app_settings:
                recent_list = self.app_settings['recent_files'].get(list_type, [])
                if path in recent_list:
                    recent_list.remove(path)
                self._update_recent_files_menu()

    def show_tiles_using_color(self, palette_slot_index):
        """
        Finds all tiles using a specific palette color, highlights them in the
        viewer, and switches to the Tile Editor tab if necessary.
        """
        global selected_color_index # Ensure we can modify the global selection

        _debug(f"---  APP: show_tiles_using_color called for slot {palette_slot_index}")

        _, _, tile_references_set = self._calculate_single_color_usage(palette_slot_index, return_set=True)
        tiles_to_highlight = tile_references_set
        
        _debug(f"---  APP: Found tiles to highlight: {tiles_to_highlight}")

        if not tiles_to_highlight:
            messagebox.showinfo("Color Usage", "No tiles in the current set use this color.", parent=self.root)
            return

        # Select the color that was queried
        if 0 <= palette_slot_index < 16:
            selected_color_index = palette_slot_index

        self.is_setting_programmatic_highlight = True # Set the flag
        self._clear_marked_unused(trigger_redraw=False)
        self.marked_unused_tiles = tiles_to_highlight
        _debug(f"---  APP: Set self.marked_unused_tiles to: {self.marked_unused_tiles}")
        
        def do_final_updates():
            _debug("---  APP: Running deferred 'do_final_updates'")
            self.update_all_displays(changed_level="all")
            self.root.lift()
            self.is_setting_programmatic_highlight = False # Unset the flag
            
        needs_switch = False
        if hasattr(self, 'notebook') and self.notebook.winfo_exists():
            try:
                selected_tab_widget = self.notebook.nametowidget(self.notebook.select())
                # If we are on any tab other than the Tile or Supertile editor, we need to switch.
                # Supertile editor is included because it also has a tileset viewer.
                if selected_tab_widget not in [self.tab_tile_editor, self.tab_supertile_editor]:
                    needs_switch = True
            except tk.TclError:
                needs_switch = True # Assume switch needed if tab state is uncertain
        
        if needs_switch:
            _debug("---  APP: Tab switch is needed. Selecting Tile Editor tab.")
            self.notebook.select(self.tab_tile_editor)
            self.root.after(50, do_final_updates)
        else:
            _debug("---  APP: No tab switch needed. Calling final updates directly.")
            do_final_updates()

    def handle_editor_escape(self, event=None):
        """Handles the Escape key on the Tile or Supertile editor tabs to clear highlights."""
        _debug(" Editor Escape key pressed.")
        # This now needs to check for map highlights as well, in case they were set
        # and the user switched tabs without clearing them.
        if self.marked_unused_tiles or self.marked_unused_supertiles or self.highlighted_map_cells:
            _debug("   Found active marks, clearing them.")
            self._clear_marked_unused(trigger_redraw=True)
            return "break" # Prevent any other Escape bindings
        return "break"

    def _redraw_active_st_selector(self, highlighted_index):
        """Helper to redraw the supertile selector on the currently active tab."""
        if not self.notebook.winfo_exists(): return
        
        active_tab = self.notebook.nametowidget(self.notebook.select())
        
        if active_tab == self.tab_supertile_editor:
            if hasattr(self, 'supertile_selector_canvas') and self.supertile_selector_canvas.winfo_exists():
                self.draw_supertile_selector(self.supertile_selector_canvas, highlighted_index)
        elif active_tab == self.tab_map_editor:
            if hasattr(self, 'map_supertile_selector_canvas') and self.map_supertile_selector_canvas.winfo_exists():
                self.draw_supertile_selector(self.map_supertile_selector_canvas, highlighted_index)

    def _handle_usage_label_click(self, event=None):
        """Called when the usage label in the Palette Editor is clicked."""
        slot = self.selected_palette_slot
        if not (0 <= slot < 16):
            return

        # Check if the color is actually used in any tiles before proceeding
        _, _, tile_refs_count = self._calculate_single_color_usage(slot)
        
        if tile_refs_count > 0:
            # If it's used, call the existing function to show the tiles
            self.show_tiles_using_color(slot)

    def _handle_tile_usage_label_click(self, event=None):
        """Called when the usage label in the Tile Editor is clicked."""
        if not (0 <= current_tile_index < len(tileset_patterns)):
            return

        # Check if the tile is actually used in any supertiles before proceeding
        _, unique_sts = self._calculate_single_tile_usage(current_tile_index)
        
        if unique_sts > 0:
            # If it's used, call the existing function to show the supertiles
            self.show_supertiles_using_tile(current_tile_index)

    def show_supertiles_using_tile(self, tile_index):
        """
        Finds all supertiles using a specific tile, highlights them in the
        appropriate viewer, and switches to the supertile editor if necessary.
        Also selects the queried tile and scrolls the supertile list to the first result.
        """
        global current_tile_index, selected_tile_for_supertile

        _debug(f" APP: show_supertiles_using_tile called for tile {tile_index}")
        
        supertiles_to_highlight = self._check_tile_usage(tile_index)
        
        _debug(f" APP: Found supertiles to highlight: {supertiles_to_highlight}")

        if not supertiles_to_highlight:
            messagebox.showinfo("Tile Usage", "This tile is not used in any supertiles.", parent=self.root)
            return

        # Select the queried tile itself, but NOT the supertile
        current_tile_index = tile_index
        selected_tile_for_supertile = tile_index

        self.is_setting_programmatic_highlight = True
        
        self._clear_marked_unused(trigger_redraw=False)
        self.marked_unused_supertiles = set(supertiles_to_highlight)
        _debug(f" APP: Set self.marked_unused_supertiles to: {self.marked_unused_supertiles}")

        def do_final_updates_for_st_highlight():
            _debug(" APP: Running deferred updates for ST highlight.")
            # This call will draw the blue highlights, and the red border on the correct, unchanged selection
            self.update_all_displays(changed_level="all")
            
            # Now, just scroll to the first blue-highlighted item
            if self.marked_unused_supertiles:
                first_highlighted_st = min(self.marked_unused_supertiles)
                self.scroll_selectors_to_supertile(first_highlighted_st)

            self.root.lift()
            self.is_setting_programmatic_highlight = False

        target_tab = self.tab_supertile_editor 
        needs_switch = False
        
        if hasattr(self, 'notebook') and self.notebook.winfo_exists():
            selected_tab_widget = self.notebook.nametowidget(self.notebook.select())
            
            if selected_tab_widget in [self.tab_supertile_editor, self.tab_map_editor]:
                needs_switch = False
                _debug(f" APP: Already on a valid tab ({selected_tab_widget.winfo_class()}). No switch needed.")
            else:
                needs_switch = True
        else:
            needs_switch = True

        if needs_switch:
            _debug(f" APP: Tab switch needed. Selecting Supertile Editor tab.")
            self.notebook.select(target_tab)
            self.root.after(50, do_final_updates_for_st_highlight)
        else:
            do_final_updates_for_st_highlight()

    def _pan_map_to_cell(self, target_row, target_col):
        """Helper to pan the map canvas to center on a specific supertile cell."""
        canvas = self.map_canvas
        if not canvas or not canvas.winfo_exists():
            return

        # Get zoomed dimensions
        zoomed_st_w, zoomed_st_h = self._get_zoomed_supertile_pixel_dims()
        if zoomed_st_w <= 0 or zoomed_st_h <= 0:
            return

        # Calculate the center coordinate of the target cell in the canvas's content space
        target_x_content = (target_col + 0.5) * zoomed_st_w
        target_y_content = (target_row + 0.5) * zoomed_st_h

        # Get total content size
        total_w_content = map_width * zoomed_st_w
        total_h_content = map_height * zoomed_st_h

        # Get viewport dimensions
        viewport_w = canvas.winfo_width()
        viewport_h = canvas.winfo_height()

        # Calculate the desired top-left corner of the viewport (in content coords)
        # to center the target point
        new_view_x1 = target_x_content - (viewport_w / 2)
        new_view_y1 = target_y_content - (viewport_h / 2)

        # Calculate the scroll fraction needed to get to this new view
        # Ensure total content dimensions are not zero to avoid division errors
        frac_x = new_view_x1 / total_w_content if total_w_content > 0 else 0
        frac_y = new_view_y1 / total_h_content if total_h_content > 0 else 0

        # Clamp the fractions to be within the valid [0.0, 1.0] range
        frac_x = max(0.0, min(1.0, frac_x))
        frac_y = max(0.0, min(1.0, frac_y))

        # Apply the scroll
        canvas.xview_moveto(frac_x)
        canvas.yview_moveto(frac_y)

        # The scroll command itself will trigger a configure event, which should redraw.
        # But we can force an immediate redraw for responsiveness.
        self.draw_map_canvas()
        self.draw_minimap()

    def show_map_locations_using_supertile(self, supertile_index):
        """
        Finds all map cells using a specific supertile, highlights them,
        selects the supertile, and switches to the Map Editor tab.
        """
        global current_supertile_index, selected_supertile_for_map

        _debug(f" Finding map usage for Supertile {supertile_index}")
        
        # Find all (row, col) coordinates where the supertile is used
        usage_coords = self._check_supertile_usage(supertile_index)

        if not usage_coords:
            messagebox.showinfo("Supertile Usage", "This supertile is not used on the map.", parent=self.root)
            return

        # Set the flag to prevent tab changes from clearing the marks
        self.is_setting_programmatic_highlight = True
        
        # Clear any previous highlights and set the new ones
        self._clear_marked_unused(trigger_redraw=False)
        self.highlighted_map_cells = set(usage_coords)
        _debug(f" Highlighting map cells: {self.highlighted_map_cells}")
        
        # Also select the queried supertile
        current_supertile_index = supertile_index
        selected_supertile_for_map = supertile_index

        def do_final_updates():
            _debug(" Running deferred updates for map highlight.")
            
            # Update all displays, which will now draw the blue frames on the map
            self.update_all_displays(changed_level="all")
            
            # Pan to the first found location
            if self.highlighted_map_cells:
                # Find the top-most, left-most cell to pan to
                first_cell = min(self.highlighted_map_cells) 
                self._pan_map_to_cell(first_cell[0], first_cell[1])
            
            # Scroll the supertile selector to the newly selected item
            self.scroll_selectors_to_supertile(supertile_index)
            
            self.root.lift()
            self.is_setting_programmatic_highlight = False # Unset the flag

        # Switch to the map tab if not already there
        if self.notebook.select() != self.tab_map_editor._name:
            self.notebook.select(self.tab_map_editor)
            self.root.after(50, do_final_updates) # Delay to allow tab switch to process
        else:
            do_final_updates() # Already on the right tab

    def _handle_supertile_map_usage_label_click(self, event=None):
        """Called when the map usage label in the Supertile Editor is clicked."""
        if not (0 <= current_supertile_index < len(supertiles_data)):
            return

        # Check if the supertile is actually used on the map before proceeding
        map_usage_count, _ = self._get_info_for_single_supertile(current_supertile_index)
        
        if map_usage_count > 0:
            # If it's used, call the function to show the locations
            self.show_map_locations_using_supertile(current_supertile_index)

    def _handle_st_tab_global_usage_click(self, event=None):
        """Called when the global tile usage label in the Supertile Editor is clicked."""
        if not (0 <= selected_tile_for_supertile < len(tileset_patterns)):
            return

        # Check if the tile is actually used before proceeding
        _, unique_sts = self._calculate_single_tile_usage(selected_tile_for_supertile)
        
        if unique_sts > 0:
            # Call the EXISTING method. It contains all the necessary logic.
            self.show_supertiles_using_tile(selected_tile_for_supertile)

    def _validate_project_files(self, base_path):
        # Checks for all required project files for a given base_path.
        # Returns a tuple: (bool: is_valid, list: missing_files)
        if not base_path or not isinstance(base_path, str):
            return (False, ["Invalid project path."])

        missing_files = []
        
        pal_path_new = base_path + ".SC4Pal"
        pal_path_old = base_path + ".msxpal"
        til_path = base_path + ".SC4Tiles"
        sup_path = base_path + ".SC4Super"
        map_path = base_path + ".SC4Map"

        palette_exists = os.path.exists(pal_path_new) or os.path.exists(pal_path_old)
        if not palette_exists:
            missing_files.append(os.path.basename(pal_path_new))

        if not os.path.exists(til_path):
            missing_files.append(os.path.basename(til_path))
        
        if not os.path.exists(sup_path):
            missing_files.append(os.path.basename(sup_path))

        if not os.path.exists(map_path):
            missing_files.append(os.path.basename(map_path))

        is_valid = not missing_files
        return (is_valid, missing_files)

    def _execute_new_project_on_startup(self):
        """A non-interactive version of new project creation for startup."""
        _debug(" _execute_new_project_on_startup: Creating new project non-interactively.")
        # No need to prepare for change, as no windows can be open yet.
        self.new_project(interactive=False)
        self.current_project_base_path = None
        # No need to save settings on startup.
        self._finalize_project_change()
        if hasattr(self, 'notebook') and self.notebook.winfo_exists():
            self.notebook.select(self.tab_palette_editor)

    def _perform_initial_project_setup(self):
        # Determines and executes the initial project state at startup.
        _debug(" _perform_initial_project_setup: Method entered.")

        last_project_path = self.app_settings.get('last_opened_project')
        _debug(f" _perform_initial_project_setup: Found last_opened_project path: '{last_project_path}'")
        
        is_valid, _ = self._validate_project_files(last_project_path)
        _debug(f" _perform_initial_project_setup: Validation of path returned is_valid={is_valid}")
        
        if is_valid:
            _debug(f" _perform_initial_project_setup: Path is valid. Calling _handle_open_project_action for startup.")
            self._handle_open_project_action(filepath=last_project_path, open_mode=OPEN_MODE_STARTUP)
        else:
            _debug(" _perform_initial_project_setup: Path is NOT valid. Calling _execute_new_project_on_startup.")
            # Call the new execute method directly for a clean, non-interactive new project.
            self._execute_new_project_on_startup() 
        _debug(" _perform_initial_project_setup: Method finished.")

    def _prepare_for_project_change(self, is_auto_load=False):
        # Saves the state of any open usage windows and then destroys them.
        _debug(f" _prepare_for_project_change: Method entered with is_auto_load={is_auto_load}")
        
        if not is_auto_load:
            _debug(" _prepare_for_project_change: is_auto_load is False. Calling _gather_open_window_states.")
            self._gather_open_window_states()
        else:
            _debug(" _prepare_for_project_change: is_auto_load is True. SKIPPING _gather_open_window_states.")
        
        _debug(" _prepare_for_project_change: Destroying usage windows (if they exist).")
        if self.color_usage_window and tk.Toplevel.winfo_exists(self.color_usage_window): self.color_usage_window.destroy()
        if self.tile_usage_window and tk.Toplevel.winfo_exists(self.tile_usage_window): self.tile_usage_window.destroy()
        if self.supertile_usage_window and tk.Toplevel.winfo_exists(self.supertile_usage_window): self.supertile_usage_window.destroy()
        self.color_usage_window, self.tile_usage_window, self.supertile_usage_window = None, None, None
        _debug(" _prepare_for_project_change: Method finished.")

    def _finalize_project_change(self):
        # Updates UI and restores windows after a project change.
        _debug(" Finalizing project change: updating UI and settings.")
        self.undo_manager.clear() # Clear undo/redo history for the new project state
        self._update_window_title()
        
        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        self._reconfigure_supertile_definition_canvas()

        self._perform_project_load_ui_updates()
        _debug(" Project data loaded/created. Now restoring usage windows...")
        self._restore_window_states()

    def _execute_new_project(self):
        """The single, authoritative function to create a new project."""
        _debug(" _execute_new_project: Creating new project.")

        # 1. Prepare for the change (gather states, close windows)
        self._prepare_for_project_change()

        # 2. Create the new project data model
        self.new_project(interactive=True)
        self.current_project_base_path = None
        
        # 3. Save settings (as this is a user action)
        self._save_app_settings()

        # 4. Finalize the UI
        self._finalize_project_change()

        # 5. After finalizing, select the correct tab.
        if hasattr(self, 'notebook') and self.notebook.winfo_exists():
            self.notebook.select(self.tab_palette_editor)

    def _handle_new_project_action(self, event=None): # Added event=None to handle key binding
        # Controller for the 'New Project' action.
        if self.project_modified:
            if not messagebox.askokcancel("Unsaved Changes", "Discard current unsaved changes and start a new project?", icon="warning"):
                return

        # Call the dedicated execution function
        self._execute_new_project()

    def _handle_open_project_action(self, filepath=None, open_mode=OPEN_MODE_INTERACTIVE):
        """Controller for the 'Open Project' action. Determines the mode and gets user confirmation if needed."""
        path_to_open = filepath
        
        # Step 1: Get the path if not provided (only happens in INTERACTIVE mode)
        if open_mode == OPEN_MODE_INTERACTIVE and not path_to_open:
            path_to_open = filedialog.askopenfilename(
                filetypes=[
                    ("SC4 Palette File (*.SC4Pal)", "*.SC4Pal"),       
                    ("MSX Tileset File (*.SC4Tiles)", "*.SC4Tiles"),  
                    ("MSX Supertile File (*.SC4Super)", "*.SC4Super"),
                    ("MSX Map File (*.SC4Map)", "*.SC4Map"),
                    ("Old MSX Palette File (*.msxpal)", "*.msxpal"), 
                    ("All Files", "*.*"),
                ],
                title="Open Project (Select Any Component File)",
                parent=self.root
            )
        
        if not path_to_open:
            return # User cancelled the dialog

        # Step 2: Handle unsaved changes confirmation (for any user-initiated action)
        if self.project_modified and open_mode in [OPEN_MODE_INTERACTIVE, OPEN_MODE_RECENT]:
            if not messagebox.askokcancel("Unsaved Changes", f"Discard current unsaved changes and open '{os.path.basename(path_to_open)}'?", icon="warning"):
                return # User cancelled the confirmation

        # Step 3: Call the unified execution function with the correct mode
        self._execute_project_open(path_to_open, open_mode)

    def _prepare_for_project_change(self):
        """Saves the state of any open usage windows and then destroys them."""
        _debug(" _prepare_for_project_change: Method entered.")
        
        self.is_changing_projects = True # Set the flag to disable on_close logic
        
        self._gather_open_window_states()
        
        _debug(" _prepare_for_project_change: Destroying usage windows.")
        if self.color_usage_window and tk.Toplevel.winfo_exists(self.color_usage_window): self.color_usage_window.destroy()
        if self.tile_usage_window and tk.Toplevel.winfo_exists(self.tile_usage_window): self.tile_usage_window.destroy()
        if self.supertile_usage_window and tk.Toplevel.winfo_exists(self.supertile_usage_window): self.supertile_usage_window.destroy()
        self.color_usage_window, self.tile_usage_window, self.supertile_usage_window = None, None, None
        
        self.root.update_idletasks() # Process the destroy events
        
        self.is_changing_projects = False # Unset the flag
        
        _debug(" _prepare_for_project_change: Method finished.")

    def _open_recent_by_index(self, list_type, index):
        """Opens a project or module from the recent list by its zero-based index."""
        _debug(f" Attempting to open recent {list_type} at index {index}.")

        if 'recent_files' not in self.app_settings:
            return

        recent_list = self.app_settings['recent_files'].get(list_type, [])
        
        # Check if the requested index is valid for the current list size.
        if 0 <= index < len(recent_list):
            path_to_open = recent_list[index]
            _debug(f" Found path: {path_to_open}")
            
            if list_type == 'projects':
                # Use the existing handler for opening projects.
                self._handle_open_project_action(filepath=path_to_open, open_mode=OPEN_MODE_RECENT)
            elif list_type == 'modules':
                # Use the existing handler for opening individual modules.
                self._open_recent_module(path_to_open)
        else:
            _debug(f" Index {index} is out of bounds for recent {list_type} list (size {len(recent_list)}).")

    def _post_menu_at_cursor(self, event, menu_to_post):
        """Posts a given menu submenu at the current cursor location."""
        # Ensure the menu we want to post actually exists.
        if not menu_to_post or not menu_to_post.winfo_exists():
            return
            
        # The event object contains the absolute screen coordinates of the cursor.
        if event:
            try:
                # Post the menu at the cursor's screen coordinates.
                menu_to_post.tk_popup(event.x_root, event.y_root)
            except tk.TclError as e:
                _error(f"Error posting menu: {e}")

    def _swap_items(self, item_type, index_a, index_b):
        _debug(f"Attempting to swap {item_type}s at indices {index_a} and {index_b}")
        
        commands = []
        
        if item_type == "tile":
            commands.append(ReorderListCommand("Swap Tiles", tileset_patterns, index_a, index_b, is_swap=True))
            commands.append(ReorderListCommand("Swap Tiles", tileset_colors, index_a, index_b, is_swap=True))
            
            # Use the new, fast, procedural command
            commands.append(UpdateSupertileRefsForTileSwapCommand("Update Supertile Refs", self, index_a, index_b))

            old_state = (current_tile_index, selected_tile_for_supertile)
            new_cti = current_tile_index
            if current_tile_index == index_a: new_cti = index_b
            elif current_tile_index == index_b: new_cti = index_a
            new_sts = selected_tile_for_supertile
            if selected_tile_for_supertile == index_a: new_sts = index_b
            elif selected_tile_for_supertile == index_b: new_sts = index_a
            new_state = (new_cti, new_sts)
            def state_setter_tile(state):
                global current_tile_index, selected_tile_for_supertile
                current_tile_index, selected_tile_for_supertile = state
            commands.append(SetDataCommand("Update App State", self, state_setter_tile, new_state, old_state))

        elif item_type == "supertile":
            commands.append(ReorderListCommand("Swap Supertiles", supertiles_data, index_a, index_b, is_swap=True))
            commands.append(UpdateMapRefsForSupertileSwapCommand("Update Map Refs", self, index_a, index_b))

            old_state = (current_supertile_index, selected_supertile_for_map)
            new_csi = current_supertile_index
            if current_supertile_index == index_a: new_csi = index_b
            elif current_supertile_index == index_b: new_csi = index_a
            new_ssm = selected_supertile_for_map
            if selected_supertile_for_map == index_a: new_ssm = index_b
            elif selected_supertile_for_map == index_b: new_ssm = index_a
            new_state = (new_csi, new_ssm)
            def state_setter_st(state):
                global current_supertile_index, selected_supertile_for_map
                current_supertile_index, selected_supertile_for_map = state
            commands.append(SetDataCommand("Update App State", self, state_setter_st, new_state, old_state))
        
        def post_hooks():
            self._mark_project_modified()
            # Side effects are now handled by the specific commands
            if item_type == "tile":
                self.scroll_viewers_to_tile(current_tile_index)
            elif item_type == "supertile":
                self.scroll_selectors_to_supertile(current_supertile_index)

        composite = CompositeCommand(f"Swap {item_type}s", commands, app_ref=self, post_hooks=[post_hooks])
        self.undo_manager.execute(composite)
        return True

    def _update_supertile_refs_for_tile_swap(self, index_a, index_b):
        """Updates supertile definitions after a tile swap."""
        for st_idx in range(len(supertiles_data)):
            definition = supertiles_data[st_idx]
            if not definition: continue

            for r in range(self.supertile_grid_height):
                if r >= len(definition): continue
                row = definition[r]
                for c in range(self.supertile_grid_width):
                    if c >= len(row): continue
                    
                    if row[c] == index_a:
                        supertiles_data[st_idx][r][c] = index_b
                    elif row[c] == index_b:
                        supertiles_data[st_idx][r][c] = index_a

    def _update_map_refs_for_supertile_swap(self, index_a, index_b):
        """Updates map data after a supertile swap."""
        for r in range(map_height):
            if r >= len(map_data): continue
            row = map_data[r]
            for c in range(map_width):
                if c >= len(row): continue

                if row[c] == index_a:
                    map_data[r][c] = index_b
                elif row[c] == index_b:
                    map_data[r][c] = index_a

    def _display_import_from_image_dialog(self):
        """
        Displays a modal dialog for the user to choose image import options.
        Returns a tuple: (choice_string, ignore_duplicates_bool) or (None, None) if cancelled.
        """
        dialog = tk.Toplevel(self.root)
        dialog.title("Image Import Options")
        dialog.transient(self.root)
        dialog.grab_set()
        dialog.resizable(False, False)

        result = {"choice": None, "ignore_dupes": False}

        main_frame = ttk.Frame(dialog, padding="15")
        main_frame.pack(expand=True, fill="both")

        warning_text = (
            "This will replace the current tileset and palette with content derived "
            "from the image.\n\nThis action cannot be undone."
        )
        ttk.Label(main_frame, text=warning_text, justify=tk.LEFT, wraplength=400).pack(pady=(0, 15))

        # --- Palette Options ---
        options_frame = ttk.LabelFrame(main_frame, text="Palette Generation Method")
        options_frame.pack(pady=5, fill="x")
        choice_var = tk.StringVar(value="use_current")
        
        ttk.Radiobutton(
            options_frame, 
            text="Use Current Active Palette",
            value="use_current", 
            variable=choice_var
        ).pack(anchor="w", padx=10, pady=3)

        ttk.Radiobutton(
            options_frame, 
            text="Generate New 16-Color Palette (from image)",
            value="generate_new", 
            variable=choice_var
        ).pack(anchor="w", padx=10, pady=3)
        
        ttk.Radiobutton(
            options_frame, 
            text="Generate New 16-Color Palette with Dithering",
            value="generate_dither", 
            variable=choice_var
        ).pack(anchor="w", padx=10, pady=3)

        # --- Other Options ---
        other_options_frame = ttk.LabelFrame(main_frame, text="Import Options")
        other_options_frame.pack(pady=(10, 5), fill="x")
        ignore_dupes_var = tk.BooleanVar(value=True)
        
        ttk.Checkbutton(
            other_options_frame,
            text="Ignore duplicate tiles",
            variable=ignore_dupes_var
        ).pack(anchor="w", padx=10, pady=3)

        # --- Buttons ---
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=(15, 0))

        def on_ok():
            result["choice"] = choice_var.get()
            result["ignore_dupes"] = ignore_dupes_var.get()
            dialog.destroy()

        def on_cancel():
            dialog.destroy() # result values remain None/False

        ok_button = ttk.Button(button_frame, text="Import", command=on_ok)
        ok_button.pack(side=tk.LEFT, padx=10)
        cancel_button = ttk.Button(button_frame, text="Cancel", command=on_cancel)
        cancel_button.pack(side=tk.LEFT, padx=10)

        dialog.bind("<Return>", lambda e: on_ok())
        dialog.bind("<Escape>", lambda e: on_cancel())

        # Center dialog
        self.root.update_idletasks()
        dialog.update_idletasks()
        root_x, root_y = self.root.winfo_rootx(), self.root.winfo_rooty()
        root_w, root_h = self.root.winfo_width(), self.root.winfo_height()
        dialog_w, dialog_h = dialog.winfo_reqwidth(), dialog.winfo_reqheight()
        x_pos = root_x + (root_w - dialog_w) // 2
        y_pos = root_y + (root_h - dialog_h) // 2
        dialog.geometry(f"+{x_pos}+{y_pos}")

        dialog.wait_window()
        return result["choice"], result["ignore_dupes"]

    def _quantize_image_to_palette(self, source_image, target_palette_pil, dither):
        """
        Quantizes an image to a given Pillow palette.

        Args:
            source_image (PIL.Image): The source image to quantize.
            target_palette_pil (PIL.Image): A 1x256 'P' mode palette image.
            dither (bool): Whether to apply Floyd-Steinberg dithering.

        Returns:
            PIL.Image: The quantized 'P' mode image.
        """
        # Ensure the source image is in RGB mode for quantization
        if source_image.mode != "RGB":
            source_image = source_image.convert("RGB")
        
        dither_method = Image.Dither.FLOYDSTEINBERG if dither else Image.Dither.NONE

        # Perform the quantization. This maps every pixel in the source image
        # to the closest color in the provided palette image.
        quantized_image = source_image.quantize(
            palette=target_palette_pil,
            dither=dither_method
        )
        
        return quantized_image

    def _generate_palette_from_image(self, source_image):
        """
        Generates an optimized 16-color palette from a source image.

        Args:
            source_image (PIL.Image): The image to analyze.

        Returns:
            list: A list of exactly 16 (r, g, b) tuples representing the new palette.
        """
        # Use Pillow's built-in functionality to create an optimized 16-color palette
        # This returns a new image in 'P' (palette) mode.
        palette_image = source_image.quantize(colors=16, dither=Image.Dither.NONE)
        
        # The palette data is stored as a flat list [r1,g1,b1, r2,g2,b2, ...]
        palette_flat = palette_image.getpalette()
        
        # Convert the flat list into a list of (r, g, b) tuples
        new_palette = []
        # The number of colors generated might be less than 16 if the image is simple
        num_colors_generated = len(palette_flat) // 3
        
        for i in range(0, num_colors_generated * 3, 3):
            new_palette.append(tuple(palette_flat[i:i+3]))
        
        # Pad the palette with black if fewer than 16 colors were generated
        while len(new_palette) < 16:
            new_palette.append((0, 0, 0))
            
        return new_palette

    def _convert_row_to_msx_format(self, pixel_row_indices, full_palette_rgb, dither):
        """
        Converts a list of 8 palette indices into a valid MSX row format.
        This involves reducing colors to 2 per row, with optional dithering.

        Args:
            pixel_row_indices (list): A list of 8 integers (palette indices).
            full_palette_rgb (list): The full list of 16 (r,g,b) tuples for the target palette.
            dither (bool): Whether to apply 1D dithering for color reduction.

        Returns:
            tuple: (pattern_byte, fg_index, bg_index)
        """
        from collections import Counter

        # Defensive step: Ensure all indices are within the valid 0-15 range.
        # This prevents IndexErrors if Pillow's quantize function returns an unexpected index.
        validated_pixel_indices = [min(idx, 15) for idx in pixel_row_indices]

        unique_colors_in_row = Counter(validated_pixel_indices)
        num_unique_colors = len(unique_colors_in_row)

        if num_unique_colors <= 1:
            # Simple case: 0 or 1 color in the row
            fg_idx = validated_pixel_indices[0] if num_unique_colors == 1 else WHITE_IDX
            bg_idx = BLACK_IDX
            pattern = 0xFF if num_unique_colors == 1 else 0x00
            return (pattern, fg_idx, bg_idx)

        elif num_unique_colors == 2:
            # Simple case: Exactly 2 colors, they become FG and BG
            color1, color2 = unique_colors_in_row.keys()
            # Assign FG/BG based on palette index (higher index is typically brighter)
            fg_idx = max(color1, color2)
            bg_idx = min(color1, color2)
            pattern = 0
            for i, px_idx in enumerate(validated_pixel_indices):
                if px_idx == fg_idx:
                    pattern |= (1 << (7 - i))
            return (pattern, fg_idx, bg_idx)

        else: # Complex case: > 2 colors, must reduce
            # Find the two most frequent colors to be the new FG/BG
            most_common = unique_colors_in_row.most_common(2)
            color1_idx = most_common[0][0]
            color2_idx = most_common[1][0]

            final_fg_idx = max(color1_idx, color2_idx)
            final_bg_idx = min(color1_idx, color2_idx)

            final_fg_rgb = full_palette_rgb[final_fg_idx]
            final_bg_rgb = full_palette_rgb[final_bg_idx]

            output_pattern = 0
            
            if not dither:
                # No dithering: just map each original pixel to the closest of the two final colors
                for i, original_px_idx in enumerate(validated_pixel_indices):
                    original_rgb = full_palette_rgb[original_px_idx]
                    
                    # Simple distance calculation (sum of squared differences)
                    dist_to_fg = sum((a - b)**2 for a, b in zip(original_rgb, final_fg_rgb))
                    dist_to_bg = sum((a - b)**2 for a, b in zip(original_rgb, final_bg_rgb))
                    
                    if dist_to_fg <= dist_to_bg:
                        output_pattern |= (1 << (7 - i)) # Set bit for FG
            
            else:
                # 1D Dithering: Propagate error to the right
                error_rgb = [0.0, 0.0, 0.0] # [r, g, b] error
                
                for i, original_px_idx in enumerate(validated_pixel_indices):
                    original_rgb = full_palette_rgb[original_px_idx]
                    
                    # Apply propagated error to the current pixel's color
                    modified_rgb = [
                        original_rgb[0] + error_rgb[0],
                        original_rgb[1] + error_rgb[1],
                        original_rgb[2] + error_rgb[2]
                    ]

                    # Find the closest of the two final colors to the modified color
                    dist_to_fg = sum((a - b)**2 for a, b in zip(modified_rgb, final_fg_rgb))
                    dist_to_bg = sum((a - b)**2 for a, b in zip(modified_rgb, final_bg_rgb))

                    chosen_rgb = final_fg_rgb
                    if dist_to_fg <= dist_to_bg:
                        output_pattern |= (1 << (7 - i)) # Set bit for FG
                    else:
                        chosen_rgb = final_bg_rgb
                        
                    # Calculate the new error and propagate it
                    error_rgb = [
                        modified_rgb[0] - chosen_rgb[0],
                        modified_rgb[1] - chosen_rgb[1],
                        modified_rgb[2] - chosen_rgb[2]
                    ]

            return (output_pattern, final_fg_idx, final_bg_idx)

    def import_tiles_from_image(self):
        """
        NEW WORKFLOW: Runs msxtilemagic.py to pre-process an image, then presents
        the resulting tiles in a selection dialog for undoable, additive import.
        """
        image_filepath = filedialog.askopenfilename(
            title="Select Image to Generate Tiles From",
            filetypes=[
                ("All Supported Images", "*.png *.bmp *.gif *.jpg *.jpeg"),
                ("PNG files", "*.png"),
                ("BMP files", "*.bmp"),
                ("All files", "*.*")
            ],
            parent=self.root
        )
        if not image_filepath:
            return

        dialog = ImageTileImportDialog(self.root, self, image_filepath)
        dialog.wait_window()
        
        options = dialog.result
        if options is None:
            _info("Image to Tile import cancelled by user at options dialog.")
            return

        # --- Assemble and run the external script ---
        script_path = os.path.join(os.path.dirname(sys.argv[0]), "msxtilemagic.py")
        if not os.path.exists(script_path):
            messagebox.showerror("Script Error", f"Could not find 'msxtilemagic.py'.", parent=self.root)
            return

        # Define temporary output location
        output_dir = os.path.join(platformdirs.user_cache_dir(self.config_app_name, appauthor=False, ensure_exists=True), "tile_import_temp")
        os.makedirs(output_dir, exist_ok=True)
        basename = "temp_tile_import"
        
        # Assemble the command with the new --no-maps flag
        command = [
            sys.executable, script_path, image_filepath,
            "--output-dir", output_dir, "--output-basename", basename,
            "--no-maps", # NEW: Prevent supertile/map generation
            "--max-tiles", str(options["max_tiles"]),
            "--optimization-mode", options["opt_mode"],
            "--supertile-width", str(options["st_width"]), # Still needed for tile ripping logic
            "--supertile-height", str(options["st_height"]),
            "--color-metric", options["metric"],
            "--sort-tileset", options["sort_tiles"]
        ]
        
        for i, rule in enumerate(options["palette_rules"]):
            command.append(f"--palette-slot"); command.append(str(i)); command.append(rule)

        if not options["dithering"]: command.append("--no-dithering")
        if options["find_offset"]: command.append("--find-best-offset")
        if options["synthesize"]: command.append("--synthesize-tiles")
        if options["limit_cores"]: command.append("--cores"); command.append(str(options["cores"]))
            
        _info(f"Executing tile generation script: {' '.join(command)}")

        # --- Run the script with progress dialog ---
        runner_dialog = tk.Toplevel(self.root)
        runner_dialog.title("Generating Tiles from Image...")
        runner_dialog.transient(self.root)
        runner_dialog.grab_set()
        runner_dialog.resizable(False, False)

        log_text = tk.Text(runner_dialog, height=20, width=90, wrap=tk.WORD, state=tk.DISABLED, bg="#1E1E1E", fg="#D4D4D4", font=("Consolas", 9))
        log_text.pack(padx=10, pady=10, expand=True, fill="both")
        
        def on_script_complete(success):
            runner_dialog.destroy() # Close the log window
            if success:
                temp_pal_path = os.path.join(output_dir, f"{basename}.SC4Pal")
                temp_tiles_path = os.path.join(output_dir, f"{basename}.SC4Tiles")
                
                # After success, proceed to the selection dialog (Phase 3)
                self._show_image_tile_selection_dialog(temp_pal_path, temp_tiles_path, output_dir)
            else:
                messagebox.showerror("Generation Failed", "The tile generation script failed. See console for details.", parent=self.root)
                # Cleanup failed run
                try:
                    if os.path.exists(output_dir): shutil.rmtree(output_dir)
                except Exception as e:
                    _error(f"Failed to clean up temp dir after failed run: {e}")

        self._run_script_and_stream_output(command, log_text, on_script_complete)

    def clear_all_supertiles_non_interactive(self):
        """
        Clears all supertile definitions to point to Tile 0 without user confirmation.
        Used internally after an image import invalidates the entire tileset.
        """
        global supertiles_data

        _debug("Performing non-interactive clear of all supertile definitions.")
        
        for i in range(len(supertiles_data)):
            # Recreate the definition based on current project dimensions
            supertiles_data[i] = [
                [0 for _c in range(self.supertile_grid_width)] for _r in range(self.supertile_grid_height)
            ]
            self.invalidate_supertile_cache(i)
        
        # Also clear map data as it references old supertiles that now have different content
        self.clear_map_non_interactive()

    def clear_map_non_interactive(self):
        """
        Clears the map data to all zeros without user confirmation.
        Used internally after an image import invalidates the entire tileset/supertile set.
        """
        global map_data, map_width, map_height
        _debug("Performing non-interactive clear of map data.")
        map_data = [[0 for _ in range(map_width)] for _ in range(map_height)]
        self.invalidate_minimap_background_cache()

    def _swap_palette_indices(self, index_a, index_b):
        """Swaps two colors in the palette and updates all tile color references."""
        global tileset_colors

        if not (0 <= index_a < 16 and 0 <= index_b < 16):
            return False
        
        if index_a == index_b:
            return False

        # --- Command for swapping palette hex values ---
        old_palette = list(self.active_msx_palette)
        new_palette = list(self.active_msx_palette)
        new_palette[index_a], new_palette[index_b] = new_palette[index_b], new_palette[index_a]
        
        def palette_setter(p):
            self.active_msx_palette[:] = p # Modify list in-place
        
        palette_swap_command = SetDataCommand("Swap Palette Colors", self, palette_setter, new_palette, old_palette)

        # --- Command for swapping color references in tileset ---
        old_tileset_colors = copy.deepcopy(tileset_colors)
        new_tileset_colors = copy.deepcopy(tileset_colors)
        for tile_color_def in new_tileset_colors:
            for i, (fg, bg) in enumerate(tile_color_def):
                new_fg, new_bg = fg, bg
                if fg == index_a: new_fg = index_b
                elif fg == index_b: new_fg = index_a
                if bg == index_a: new_bg = index_b
                elif bg == index_b: new_bg = index_a
                if (new_fg, new_bg) != (fg, bg):
                    tile_color_def[i] = (new_fg, new_bg)

        def tileset_colors_setter(c):
            global tileset_colors
            tileset_colors = c

        tileset_refs_command = SetDataCommand("Update Tile Color Refs", self, tileset_colors_setter, new_tileset_colors, old_tileset_colors)
        composite = CompositeCommand("Swap Palette Colors", [palette_swap_command, tileset_refs_command])
        self.undo_manager.execute(composite)
        
        return True

    def handle_palette_drag_motion(self, event):
        if not self.drag_active and self.drag_item_type == "palette_color":
            dx = event.x - self.drag_press_x
            dy = event.y - self.drag_press_y
            if (dx*dx + dy*dy) >= (DRAG_THRESHOLD_PIXELS * DRAG_THRESHOLD_PIXELS):
                self.drag_active = True
                
                _debug(f" DRAG INITIATED: is_alt_pressed={self.is_alt_pressed}, is_ctrl_pressed={self.is_ctrl_pressed}")
                
                cursor_type = "spraycan" if self.is_alt_pressed else "exchange"
                self.drag_canvas.config(cursor=cursor_type)
        
        if self.drag_active and self.drag_item_type == "palette_color":
            if self.drag_indicator_id:
                try:
                    self.drag_canvas.delete(self.drag_indicator_id)
                except (tk.TclError, AttributeError): pass

            size = CURRENT_PALETTE_SLOT_SIZE
            padding = 2
            col = event.x // (size + padding)
            row = event.y // (size + padding)
            target_index = row * 4 + col
            
            if 0 <= target_index < 16 and target_index != self.drag_start_index and not self.is_alt_pressed:
                x1 = col * (size + padding) + (padding / 2)
                y1 = row * (size + padding) + (padding / 2)
                x2 = x1 + size + padding
                y2 = y1 + size + padding
                self.drag_indicator_id = self.drag_canvas.create_rectangle(
                    x1, y1, x2, y2, outline="yellow", width=3, tags="drop_indicator"
                )

    def handle_palette_drag_release(self, event):
        try:
            if self.drag_active and self.drag_item_type == "palette_color":
                size = CURRENT_PALETTE_SLOT_SIZE
                padding = 2
                col = event.x // (size + padding)
                row = event.y // (size + padding)
                target_index = row * 4 + col
                
                if 0 <= target_index < 16 and target_index != self.drag_start_index:
                    source_index = self.drag_start_index
                    is_alt_down_at_release = (event.state & 0x20000) != 0

                    if is_alt_down_at_release:
                        _debug("[Drag Release] Alt key is down. Attempting 'Replace All'.")
                        if self._execute_replace_all_references("palette_color", source_index, target_index):
                            _debug("[Drag Release] Confirmation was True. Creating and executing command.")
                            command = ReplaceRefsCommand("Replace All Colors", self, "palette_color", source_index, target_index)
                            self.undo_manager.execute(command)
                        else:
                            _debug("[Drag Release] Confirmation was False. No command created.")
                    else:
                        _debug("[Drag Release] Alt key is NOT down. Attempting 'Swap'.")
                        success = self._swap_palette_indices(source_index, target_index)
                        if success:
                            self.selected_palette_slot = target_index
        finally:
            _debug(" --- PALETTE DRAG RELEASE: FINALLY BLOCK ---")
            
            if self.drag_indicator_id:
                try:
                    self.drag_canvas.delete(self.drag_indicator_id)
                except (tk.TclError, AttributeError):
                    pass
                self.drag_indicator_id = None
            
            if hasattr(self, 'drag_canvas') and self.drag_canvas and self.drag_canvas.winfo_exists():
                try:
                    self.drag_canvas.config(cursor="")
                except tk.TclError:
                    pass
            
            _debug(f" State BEFORE reset: drag_active={self.drag_active}, is_alt_pressed={self.is_alt_pressed}")
            
            # Forcefully reset all drag-related state
            self.drag_active = False
            self.drag_item_type = None
            self.drag_start_index = -1
            self.drag_canvas = None
            self.is_alt_pressed = False
            
            _debug(f" State AFTER reset: drag_active={self.drag_active}, is_alt_pressed={self.is_alt_pressed}")

    def handle_alt_press(self, event):
        """Handles Alt key press."""
        if "Alt" in event.keysym:
            if not self.is_alt_pressed:
                self.is_alt_pressed = True
                if self.drag_active and self.drag_item_type in ["tile", "supertile", "palette_color"]:
                    if self.drag_canvas and self.drag_canvas.winfo_exists():
                        try:
                            self.drag_canvas.config(cursor="spraycan")
                        except tk.TclError:
                            pass

    def handle_alt_release(self, event):
        """Handles Alt key release."""
        if "Alt" in event.keysym:
            if self.is_alt_pressed:
                self.is_alt_pressed = False
                if self.drag_active and self.drag_item_type in ["tile", "supertile", "palette_color"]:
                    if self.drag_canvas and self.drag_canvas.winfo_exists():
                        try:
                            # Revert cursor to the appropriate state based on other modifiers
                            new_cursor = "exchange" if self.is_ctrl_pressed else "target"
                            self.drag_canvas.config(cursor=new_cursor)
                        except tk.TclError:
                            pass

    def _get_active_viewer_canvas(self, item_type):
        """Returns the currently visible canvas for a given item type."""
        if not self.notebook or not self.notebook.winfo_exists():
            return None
            
        try:
            active_tab_widget = self.notebook.nametowidget(self.notebook.select())
            if item_type == "tile":
                if active_tab_widget == self.tab_tile_editor:
                    return self.tileset_canvas
                elif active_tab_widget == self.tab_supertile_editor:
                    return self.st_tileset_canvas
            elif item_type == "supertile":
                if active_tab_widget == self.tab_supertile_editor:
                    return self.supertile_selector_canvas
                elif active_tab_widget == self.tab_map_editor:
                    return self.map_supertile_selector_canvas
            elif item_type == "palette_color":
                if active_tab_widget == self.tab_palette_editor:
                    return self.current_palette_canvas
        except (tk.TclError, KeyError):
            return None
        return None

    def _show_visual_confirm_dialog(self, title, message, source_image, target_image):
        """Displays a modal confirmation dialog with images."""
        dialog = tk.Toplevel(self.root)
        dialog.title(title)
        dialog.transient(self.root)
        dialog.grab_set()
        dialog.resizable(False, False)

        result = {"confirmed": False}
        main_frame = ttk.Frame(dialog, padding="20")
        main_frame.pack(expand=True, fill="both")

        ttk.Label(main_frame, text=message, wraplength=450, justify=tk.LEFT).pack(pady=(0, 15))

        visual_frame = ttk.Frame(main_frame)
        visual_frame.pack(pady=10)
        
        # Target Item Display (Now on the left)
        target_frame = ttk.LabelFrame(visual_frame, text="Replace This (Target)")
        target_frame.pack(side=tk.LEFT, padx=10, fill="y")
        target_label = ttk.Label(target_frame, image=target_image)
        target_label.image = target_image
        target_label.pack(padx=10, pady=10)

        # Arrow/Indicator (Now pointing left, using direct Unicode code point)
        arrow_label = ttk.Label(visual_frame, text="\u2b05", font=("", 20))
        arrow_label.pack(side=tk.LEFT, padx=20, expand=True)

        # Source Item Display (Now on the right)
        source_frame = ttk.LabelFrame(visual_frame, text="With This (Source)")
        source_frame.pack(side=tk.LEFT, padx=10, fill="y")
        source_label = ttk.Label(source_frame, image=source_image)
        source_label.image = source_image
        source_label.pack(padx=10, pady=10)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=(15, 0))

        def on_ok():
            result["confirmed"] = True
            dialog.destroy()

        def on_cancel():
            dialog.destroy()

        ok_button = ttk.Button(button_frame, text="Replace All", command=on_ok)
        ok_button.pack(side=tk.LEFT, padx=10)
        cancel_button = ttk.Button(button_frame, text="Cancel", command=on_cancel)
        cancel_button.pack(side=tk.LEFT, padx=10)
        
        ok_button.focus_set()
        dialog.bind("<Return>", lambda e: on_ok())
        dialog.bind("<Escape>", lambda e: on_cancel())

        self.root.update_idletasks()
        dialog.update_idletasks()
        root_x, root_y, root_w, root_h = self.root.winfo_rootx(), self.root.winfo_rooty(), self.root.winfo_width(), self.root.winfo_height()
        dialog_w, dialog_h = dialog.winfo_reqwidth(), dialog.winfo_reqheight()
        x = root_x + (root_w - dialog_w) // 2
        y = root_y + (root_h - dialog_h) // 2
        dialog.geometry(f"+{x}+{y}")
        
        dialog.wait_window()
        return result["confirmed"]

    def _execute_replace_all_references(self, item_type, source_index, target_index):
        _debug(f"[Replace Refs] PRE-CONFIRM: Attempting replace '{item_type}' from {source_index} to {target_index}")
        if source_index == target_index:
            _debug("[Replace Refs] Aborted: source and target are the same.")
            return False

        source_image, target_image = None, None
        img_size = 64
        
        if item_type == "palette_color":
            source_image = tk.PhotoImage(width=img_size, height=img_size)
            source_image.put(self.active_msx_palette[source_index], to=(0, 0, img_size, img_size))
            target_image = tk.PhotoImage(width=img_size, height=img_size)
            target_image.put(self.active_msx_palette[target_index], to=(0, 0, img_size, img_size))
        elif item_type == "tile":
            source_image = self.create_tile_image(source_index, img_size)
            target_image = self.create_tile_image(target_index, img_size)
        elif item_type == "supertile":
            source_image = self.create_supertile_image(source_index, img_size, img_size)
            target_image = self.create_supertile_image(target_index, img_size, img_size)

        if not source_image or not target_image:
            messagebox.showerror("Replace Error", "Could not generate preview images for confirmation.")
            _debug("[Replace Refs] Aborted: Could not generate preview images.")
            return False

        message = (f"This will replace all uses of {item_type.replace('_', ' ')} {target_index} "
                   f"with {item_type.replace('_', ' ')} {source_index} throughout the entire project.\n\n"
                   "This action is undoable.")
        
        confirmed = self._show_visual_confirm_dialog("Confirm Replace All", message, source_image, target_image)
        _debug(f"[Replace Refs] POST-CONFIRM: User confirmation dialog returned: {confirmed}")
        return confirmed

    def handle_viewer_drag_release(self, event):
        global current_tile_index, selected_tile_for_supertile
        global current_supertile_index, selected_supertile_for_map

        canvas = event.widget
        was_dragging = self.drag_active
        
        try:
            if not was_dragging:
                item_type_for_click = self.drag_item_type
                if item_type_for_click is None: return

                max_items = 0
                if item_type_for_click == "tile": max_items = len(tileset_patterns)
                elif item_type_for_click == "supertile": max_items = len(supertiles_data)

                index_at_release = self._get_index_from_canvas_coords(canvas, event.x, event.y, item_type_for_click)
                if 0 <= index_at_release < max_items:
                    source_canvas_type = None
                    if canvas == self.tileset_canvas: source_canvas_type = "tile_editor_main"
                    elif canvas == self.st_tileset_canvas: source_canvas_type = "supertile_editor_tile"
                    elif canvas == self.supertile_selector_canvas: source_canvas_type = "supertile_editor_main"
                    elif canvas == self.map_supertile_selector_canvas: source_canvas_type = "map_editor_palette"

                    if item_type_for_click == "tile":
                        if source_canvas_type == "tile_editor_main":
                            if current_tile_index != index_at_release:
                                current_tile_index = index_at_release
                                self.update_all_displays(changed_level="tile_select")
                                self.scroll_viewers_to_tile(current_tile_index)
                        elif source_canvas_type == "supertile_editor_tile":
                            if selected_tile_for_supertile != index_at_release:
                                selected_tile_for_supertile = index_at_release
                                self.draw_tileset_viewer(canvas, selected_tile_for_supertile)
                                self._update_st_tab_selected_tile_info_panel()
                                self.scroll_viewers_to_tile(selected_tile_for_supertile)
                    elif item_type_for_click == "supertile":
                        if source_canvas_type == "supertile_editor_main":
                            if current_supertile_index != index_at_release:
                                current_supertile_index = index_at_release
                                self.update_all_displays(changed_level="supertile")
                                self.scroll_selectors_to_supertile(current_supertile_index)
                        elif source_canvas_type == "map_editor_palette":
                            if selected_supertile_for_map != index_at_release:
                                selected_supertile_for_map = index_at_release
                                self.update_all_displays(changed_level="map")
                                self.scroll_selectors_to_supertile(selected_supertile_for_map)
            
            elif self.drag_item_type is not None:
                item_type = self.drag_item_type
                max_items = 0
                if item_type == "tile": max_items = len(tileset_patterns)
                elif item_type == "supertile": max_items = len(supertiles_data)
                
                is_alt_down = (event.state & 0x20000) != 0
                is_ctrl_down = (event.state & 0x0004) != 0
                source_index = self.drag_start_index
                target_index = self._get_index_from_canvas_coords(canvas, event.x, event.y, item_type)

                if is_alt_down and 0 <= target_index < max_items and target_index != source_index:
                    if self._execute_replace_all_references(item_type, source_index, target_index):
                        command = ReplaceRefsCommand(f"Replace All {item_type.replace('_',' ')}s", self, item_type, source_index, target_index)
                        self.undo_manager.execute(command)
                
                elif is_ctrl_down and 0 <= target_index < max_items and target_index != source_index:
                    success = self._swap_items(item_type, source_index, target_index)
                    if success:
                        self.clear_all_caches()
                        self.invalidate_minimap_background_cache()
                        self.update_all_displays(changed_level="all")
                        if item_type == "tile":
                            self.scroll_viewers_to_tile(current_tile_index)
                        elif item_type == "supertile":
                            self.scroll_selectors_to_supertile(current_supertile_index)
                
                elif not is_ctrl_down and not is_alt_down:
                    valid_drop_target = (0 <= target_index <= max_items)
                    if valid_drop_target and target_index != source_index:
                        success = False
                        if item_type == "tile": success = self._reposition_tile(source_index, target_index)
                        elif item_type == "supertile": success = self._reposition_supertile(source_index, target_index)
                        
                        if success:
                            self.clear_all_caches()
                            self.invalidate_minimap_background_cache()
                            self.update_all_displays(changed_level="all")
                            if item_type == "tile":
                                self.scroll_viewers_to_tile(current_tile_index)
                            elif item_type == "supertile":
                                self.scroll_selectors_to_supertile(current_supertile_index)
                        else:
                            messagebox.showerror("Reposition Error", f"Failed to move {item_type} from {source_index} to {target_index}.")
                            self.update_all_displays(changed_level="all")
                    else:
                        self.update_all_displays(changed_level="all")
        finally:
            if self.drag_indicator_id:
                try:
                    if self.drag_canvas and self.drag_canvas.winfo_exists():
                        self.drag_canvas.delete(self.drag_indicator_id)
                except (tk.TclError, AttributeError): pass
                self.drag_indicator_id = None
            if hasattr(self, 'drag_canvas') and self.drag_canvas and self.drag_canvas.winfo_exists():
                try:
                    self.drag_canvas.config(cursor="")
                except tk.TclError: pass
            self.drag_active = False
            self.drag_item_type = None
            self.drag_start_index = -1
            self.drag_canvas = None
            self.is_alt_pressed = False

    def _capture_sash_position(self, event):
        """
        A unified handler called on sash release. It enforces minimum width for the
        map editor's sash and then captures the final position and widget width.
        """
        widget = event.widget
        if not widget.winfo_exists():
            return

        if widget == getattr(self, 'map_paned_window', None):
            _debug(" Map sash released. Enforcing min width before capture.")
            self._do_check_and_enforce_palette_min_width()

        def do_capture():
            try:
                if not widget.winfo_exists(): return
                
                pos = widget.sashpos(0)
                width = widget.winfo_width()
                
                if widget == getattr(self, 'st_editor_paned_window', None):
                    self.app_settings['st_editor_sash_pos'] = pos
                    self.app_settings['st_editor_pane_width'] = width # NEW
                    _debug(f" Captured ST Editor sash: pos={pos}, width={width}")
                elif widget == getattr(self, 'map_paned_window', None):
                    self.app_settings['map_editor_sash_pos'] = pos
                    # We don't need to save the map's pane width because its layout is simple
                    # and tied directly to the main window, which we already save.
                    _debug(f" Captured Map Editor sash position: {pos}")

            except tk.TclError as e:
                _error(f"Could not capture sash position: {e}")

        self.root.after(20, do_capture)

    def _on_canvas_double_click(self, event):
        """
        Handles a double-click on ANY supported canvas to cancel a pending
        single-click action and trigger a deep dive edit.
        """
        _debug(f"[DBL-CLICK] Double-click detected on widget: {event.widget._name}")
        
        # Cancel the pending single-click action
        if self.single_click_timer is not None:
            self.root.after_cancel(self.single_click_timer)
            self.single_click_timer = None
            _debug("[DBL-CLICK] Cancelled pending single-click action.")
        
        # Reset any mouse action state that might have been set
        self.current_mouse_action = None
        
        # Perform the deep dive edit
        self._handle_deep_dive_edit(event)
        
        return "break"

    def _handle_deep_dive_edit(self, event):
        """
        Handles a "deep dive" edit request. Switches to the appropriate editor
        tab and selects the underlying component for editing.
        """
        global selected_color_index, current_tile_index, selected_tile_for_supertile
        global current_supertile_index, supertiles_data, map_data
        
        source_widget = event.widget
        
        # --- FROM MAP EDITOR CANVAS ---
        if source_widget == self.map_canvas:
            _debug("[DEEP DIVE] Request from Map to Supertile Editor.")
            canvas_x = self.map_canvas.canvasx(event.x)
            canvas_y = self.map_canvas.canvasy(event.y)
            coords = self._get_supertile_coords_from_canvas(canvas_x, canvas_y)
            if coords:
                c, r = coords
                supertile_idx_to_edit = map_data[r][c]
                _debug(f"[DEEP DIVE] Diving to edit Supertile {supertile_idx_to_edit}.")
                current_supertile_index = supertile_idx_to_edit
                self.notebook.select(self.tab_supertile_editor)
                self.update_all_displays(changed_level="all")
                self.scroll_selectors_to_supertile(current_supertile_index)

        # --- FROM SUPERTILE DEFINITION CANVAS ---
        elif source_widget == self.supertile_def_canvas:
            _debug("[DEEP DIVE] Request from Supertile to Tile Editor.")
            mini_tile_dsize = SUPERTILE_DEF_TILE_SIZE
            col = event.x // mini_tile_dsize
            row = event.y // mini_tile_dsize
            if (0 <= row < self.supertile_grid_height and 0 <= col < self.supertile_grid_width):
                tile_idx_to_edit = supertiles_data[current_supertile_index][row][col]
                _debug(f"[DEEP DIVE] Diving to edit Tile {tile_idx_to_edit}.")
                current_tile_index = tile_idx_to_edit
                self.notebook.select(self.tab_tile_editor)
                self.update_all_displays(changed_level="all")
                self.scroll_viewers_to_tile(current_tile_index)
                
        # --- FROM TILE EDITOR'S PALETTE ---
        elif source_widget == self.tile_editor_palette_canvas:
            _debug("[DEEP DIVE] Request from Tile Editor Palette to Palette Editor.")
            size = PALETTE_SQUARE_SIZE
            padding = 2
            col = event.x // (size + padding)
            row = event.y // (size + padding)
            clicked_index = row * 4 + col
            if 0 <= clicked_index < 16:
                self.selected_palette_slot = clicked_index
                selected_color_index = clicked_index
                self.notebook.select(self.tab_palette_editor)
                self.update_all_displays(changed_level="all")

        # --- FROM SUPERTILE EDITOR'S TILESET ---
        elif source_widget == self.st_tileset_canvas:
            _debug("[DEEP DIVE] Request from Supertile Editor Tileset to Tile Editor.")
            tile_idx_to_edit = self._get_index_from_canvas_coords(source_widget, event.x, event.y, "tile")
            if 0 <= tile_idx_to_edit < len(tileset_patterns):
                current_tile_index = tile_idx_to_edit
                selected_tile_for_supertile = tile_idx_to_edit
                self.notebook.select(self.tab_tile_editor)
                self.update_all_displays(changed_level="all")
                self.scroll_viewers_to_tile(current_tile_index)

        # --- FROM MAP EDITOR'S SUPERTILE PALETTE ---
        elif source_widget == self.map_supertile_selector_canvas:
            _debug("[DEEP DIVE] Request from Map Editor Palette to Supertile Editor.")
            supertile_idx_to_edit = self._get_index_from_canvas_coords(source_widget, event.x, event.y, "supertile")
            if 0 <= supertile_idx_to_edit < len(supertiles_data):
                current_supertile_index = supertile_idx_to_edit
                self.notebook.select(self.tab_supertile_editor)
                self.update_all_displays(changed_level="all")
                self.scroll_selectors_to_supertile(current_supertile_index)

    def _place_tile_in_supertile_and_set_drag_state(self, r, c):
        """Helper to call from 'after' to place a tile and set drag state."""
        placed = self._place_tile_in_supertile(r, c)
        if placed:
            # This state is for handling drags, so it's fine to set it here.
            self.last_placed_supertile_cell = (r, c)

    def _run_script_and_stream_output(self, command, text_widget, on_complete_callback):
        """
        Runs an external script in a separate thread and streams its output
        to a tkinter Text widget in a GUI-safe way.
        """
        output_queue = queue.Queue()

        def thread_target(cmd, q):
            """This function runs in a background thread."""
            try:
                # Create a copy of the current environment and force UTF-8 encoding
                env = os.environ.copy()
                env['PYTHONIOENCODING'] = 'utf-8'

                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    encoding='utf-8',
                    errors='replace',
                    bufsize=1,
                    universal_newlines=True,
                    creationflags=subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0,
                    env=env # Pass the modified environment to the subprocess
                )

                for line in iter(process.stdout.readline, ''):
                    q.put(line)

                process.stdout.close()
                return_code = process.wait()
                q.put(f"\n--- Process finished with exit code {return_code} ---")
                # Put the success status (True/False) on the queue as the final item
                q.put(return_code == 0)
                
            except Exception as e:
                q.put(f"\n--- THREAD ERROR: {e} ---")
            finally:
                # Put failure status on the queue if an exception occurred
                q.put(False)

        thread = threading.Thread(target=thread_target, args=(command, output_queue))
        thread.daemon = True
        thread.start()
        self._check_output_queue(text_widget, output_queue, on_complete_callback)

    def _check_output_queue(self, text_widget, q, on_complete_callback):
        """Periodically checks the queue for new output and updates the Text widget."""
        try:
            while True:
                line = q.get_nowait()

                if isinstance(line, bool):
                    if on_complete_callback:
                        on_complete_callback(line) # Pass success status to callback
                    return

                if text_widget.winfo_exists():
                    text_widget.config(state=tk.NORMAL)
                    text_widget.insert(tk.END, line)
                    text_widget.see(tk.END)
                    text_widget.config(state=tk.DISABLED)

        except queue.Empty:
            if self.root.winfo_exists():
                self.root.after(100, self._check_output_queue, text_widget, q, on_complete_callback)

    def handle_export_raw(self):
        if self.current_project_base_path is None:
            messagebox.showerror("Export Error", "Please save your project before exporting.", parent=self.root)
            return

        if self.project_modified:
            if messagebox.askyesno("Unsaved Changes", "Your project has unsaved changes. You must save before exporting.\n\nSave now?", parent=self.root):
                if not self.save_project():
                    return
            else:
                return

        export_dialog = ExportDialog(self.root, self, self.current_project_base_path)

    def _create_color_remap_table(self, source_palette_hex, dest_palette_hex):
        """
        Creates an optimal mapping from source to destination palette indices
        using the CIELAB color space for perceptual distance and the Hungarian
        algorithm to prevent color collisions.
        """
        # Convert both source and destination palettes to the CIELAB color space.
        source_lab = []
        for hex_color in source_palette_hex:
            r = int(hex_color[1:3], 16)
            g = int(hex_color[3:5], 16)
            b = int(hex_color[5:7], 16)
            source_lab.append(self._rgb_to_lab(r, g, b))

        dest_lab = []
        for hex_color in dest_palette_hex:
            r = int(hex_color[1:3], 16)
            g = int(hex_color[3:5], 16)
            b = int(hex_color[5:7], 16)
            dest_lab.append(self._rgb_to_lab(r, g, b))

        # Create a cost matrix where each cell (i, j) is the perceptual
        # distance between source color i and destination color j.
        cost_matrix = [[0.0 for _ in range(16)] for _ in range(16)]
        for i, src_lab_color in enumerate(source_lab):
            for j, dest_lab_color in enumerate(dest_lab):
                # Calculate squared Euclidean distance in CIELAB space (Delta E 76).
                delta_l = src_lab_color[0] - dest_lab_color[0]
                delta_a = src_lab_color[1] - dest_lab_color[1]
                delta_b = src_lab_color[2] - dest_lab_color[2]
                cost_matrix[i][j] = delta_l**2 + delta_a**2 + delta_b**2

        # Use the Hungarian algorithm to find the optimal assignment (minimum total cost).
        row_ind, col_ind = linear_sum_assignment(cost_matrix)

        # Build the final remap table, converting NumPy integers to standard Python ints.
        remap_table = {int(r): int(c) for r, c in zip(row_ind, col_ind)}
        
        _debug(f"Optimal Color Remap Table created: {remap_table}")
        return remap_table

    def _rgb_to_xyz(self, r, g, b):
        # Helper to convert sRGB to XYZ color space.
        # Assumes sRGB values are 0-255.
        
        # Normalize to 0-1
        r_lin, g_lin, b_lin = [x / 255.0 for x in (r, g, b)]

        # Apply the sRGB gamma correction formula
        r_lin = ((r_lin + 0.055) / 1.055)**2.4 if r_lin > 0.04045 else r_lin / 12.92
        g_lin = ((g_lin + 0.055) / 1.055)**2.4 if g_lin > 0.04045 else g_lin / 12.92
        b_lin = ((b_lin + 0.055) / 1.055)**2.4 if b_lin > 0.04045 else b_lin / 12.92

        # Standard sRGB to XYZ conversion matrix
        x = r_lin * 0.4124564 + g_lin * 0.3575761 + b_lin * 0.1804375
        y = r_lin * 0.2126729 + g_lin * 0.7151522 + b_lin * 0.0721750
        z = r_lin * 0.0193339 + g_lin * 0.1191920 + b_lin * 0.9503041
        
        return x * 100, y * 100, z * 100

    def _xyz_to_lab(self, x, y, z):
        # Helper to convert XYZ to CIELAB color space.
        # Uses D65 illuminant as a reference.
        ref_x, ref_y, ref_z = 95.047, 100.000, 108.883
        
        x /= ref_x
        y /= ref_y
        z /= ref_z

        # CIELAB formula for f(t)
        def f(t):
            return t**(1/3) if t > (6/29)**3 else (1/3) * ((29/6)**2) * t + (4/29)

        fx, fy, fz = f(x), f(y), f(z)

        L = 116 * fy - 16
        a = 500 * (fx - fy)
        b = 200 * (fy - fz)
        
        return L, a, b

    def _rgb_to_lab(self, r, g, b):
        # Convenience function to convert sRGB (0-255) to CIELAB.
        x, y, z = self._rgb_to_xyz(r, g, b)
        return self._xyz_to_lab(x, y, z)

    def _find_closest_msx2_color(self, hex_color_24bit):
        """
        Finds the closest MSX2 color to a given 24-bit hex color using
        perceptual CIELAB color difference.
        
        Returns:
            tuple: A tuple of (r, g, b) in the 0-7 MSX2 range.
        """
        try:
            r_in = int(hex_color_24bit[1:3], 16)
            g_in = int(hex_color_24bit[3:5], 16)
            b_in = int(hex_color_24bit[5:7], 16)
            
            input_lab = self._rgb_to_lab(r_in, g_in, b_in)
            
            min_dist = float('inf')
            best_match_rgb7 = (0, 0, 0)

            # msx2_512_colors_rgb7 is a pre-calculated global list
            for i, msx2_rgb7 in enumerate(msx2_512_colors_rgb7):
                msx2_hex = msx2_512_colors_hex[i]
                r_msx = int(msx2_hex[1:3], 16)
                g_msx = int(msx2_hex[3:5], 16)
                b_msx = int(msx2_hex[5:7], 16)
                
                msx2_lab = self._rgb_to_lab(r_msx, g_msx, b_msx)
                
                # Calculate squared Euclidean distance in CIELAB space (Delta E 76)
                delta_l = input_lab[0] - msx2_lab[0]
                delta_a = input_lab[1] - msx2_lab[1]
                delta_b = input_lab[2] - msx2_lab[2]
                dist_sq = delta_l**2 + delta_a**2 + delta_b**2
                
                if dist_sq < min_dist:
                    min_dist = dist_sq
                    best_match_rgb7 = msx2_rgb7

            return best_match_rgb7

        except (ValueError, IndexError):
            # Fallback on any conversion or parsing error
            return (0, 0, 0)

    def _render_tile_to_lab_pixels(self, tile_pattern, tile_colors_per_row, palette_hex):
        """
        Renders a tile's data into a flat list of 64 CIELAB color values.
        This list acts as a 'fingerprint' for visual comparison.

        Args:
            tile_pattern (list): The 8x8 pattern data for the tile.
            tile_colors_per_row (list): The list of (fg_idx, bg_idx) tuples for each row.
            palette_hex (list): The 16-color hex palette to use for rendering.

        Returns:
            list: A list of 64 (L, a, b) CIELAB tuples, or None on error.
        """
        try:
            lab_pixels = []
            for r in range(TILE_HEIGHT):
                fg_idx, bg_idx = tile_colors_per_row[r]
                fg_hex = palette_hex[fg_idx]
                bg_hex = palette_hex[bg_idx]

                # Pre-convert the two possible colors for this row to LAB.
                fg_lab = self._rgb_to_lab(int(fg_hex[1:3], 16), int(fg_hex[3:5], 16), int(fg_hex[5:7], 16))
                bg_lab = self._rgb_to_lab(int(bg_hex[1:3], 16), int(bg_hex[3:5], 16), int(bg_hex[5:7], 16))

                for c in range(TILE_WIDTH):
                    if tile_pattern[r][c] == 1:
                        lab_pixels.append(fg_lab)
                    else:
                        lab_pixels.append(bg_lab)
            return lab_pixels
        except (IndexError, TypeError) as e:
            _error(f"Error rendering tile to LAB pixels: {e}")
            return None

    def _find_best_tile_match(self, source_lab_pixels, dest_tileset_lab_fingerprints):
        """
        Finds the best matching tile in the destination tileset for a given source tile.

        Args:
            source_lab_pixels (list): The LAB fingerprint of the source tile.
            dest_tileset_lab_fingerprints (dict): A pre-calculated dictionary of
                                                  {dest_idx: dest_lab_fingerprint}.

        Returns:
            int: The index of the best matching tile in the destination tileset.
        """
        best_match_idx = 0
        min_total_distance = float('inf')

        # Iterate through all pre-calculated fingerprints of the destination tileset.
        for dest_idx, dest_lab_pixels in dest_tileset_lab_fingerprints.items():
            if not dest_lab_pixels:
                continue

            current_total_distance = 0
            # Calculate the total perceptual distance by summing the distance
            # for each of the 64 corresponding pixels.
            for i in range(len(source_lab_pixels)):
                src_lab = source_lab_pixels[i]
                dest_lab = dest_lab_pixels[i]
                delta_l = src_lab[0] - dest_lab[0]
                delta_a = src_lab[1] - dest_lab[1]
                delta_b = src_lab[2] - dest_lab[2]
                current_total_distance += delta_l**2 + delta_a**2 + delta_b**2
            
            if current_total_distance < min_total_distance:
                min_total_distance = current_total_distance
                best_match_idx = dest_idx
        
        return best_match_idx

    def _on_window_focus_in(self, event=None):
        """
        Called when the main application window gains focus.
        Updates the edit menu to reflect the current clipboard state.
        """
        _debug("Main window gained focus. Re-evaluating menu states.")
        self._update_edit_menu_state()

    def handle_import_project_from_image(self):
        if self.project_modified:
            self.root.bell()
            if not messagebox.askokcancel(
                "Confirm Project Replace",
                "This will replace your current project with content generated from the image, and your unsaved changes will be lost.\n\n"
                "This action cannot be undone and will clear the undo history. Proceed?",
                icon="warning", 
                parent=self.root
            ):
                return

        image_filepath = filedialog.askopenfilename(
            title="Select Image to Import",
            filetypes=[
                ("All Supported Images", "*.png *.bmp *.gif *.jpg *.jpeg"),
                ("PNG files", "*.png"),
                ("BMP files", "*.bmp"),
                ("All files", "*.*")
            ],
            parent=self.root
        )
        if not image_filepath:
            return

        dialog = ImageImportDialog(self.root, self, image_filepath)
        dialog.wait_window()
        
        options = dialog.result
        if options is None:
            _info("Image import cancelled by user.")
            return

        # --- Save a copy of the current palette before loading the new one ---
        palette_before_load = list(self.active_msx_palette)
        _debug(f"Saved pre-import palette state: {palette_before_load}")

        # --- Assemble the command ---
        script_path = os.path.join(os.path.dirname(sys.argv[0]), "msxtilemagic.py")
        if not os.path.exists(script_path):
            messagebox.showerror("Script Error", f"Could not find the 'msxtilemagic.py' script.\nExpected location: {script_path}", parent=self.root)
            return

        output_dir = os.path.join(platformdirs.user_cache_dir(self.config_app_name, appauthor=False, ensure_exists=True), "img_import_temp")
        os.makedirs(output_dir, exist_ok=True)
        basename = os.path.splitext(os.path.basename(image_filepath))[0] + "_imp"
        
        command = [
            sys.executable,
            script_path,
            image_filepath,
            "--output-dir", output_dir,
            "--output-basename", basename,
            "--max-tiles", str(options["max_tiles"]),
            "--optimization-mode", options["opt_mode"],
            "--supertile-width", str(options["st_width"]),
            "--supertile-height", str(options["st_height"]),
            "--color-metric", options["metric"],
            "--sort-tileset", options["sort_tiles"]
        ]
        
        palette_rules = options["palette_rules"]
        for i, rule in enumerate(palette_rules):
            command.append("--palette-slot")
            command.append(str(i))
            command.append(rule)

        if not options["dithering"]:
            command.append("--no-dithering")
        if options["find_offset"]:
            command.append("--find-best-offset")
        if options["synthesize"]:
            command.append("--synthesize-tiles")
        if options["limit_cores"]:
            command.append("--cores")
            command.append(str(options["cores"]))
            
        _info(f"Executing external command: {' '.join(command)}")

        # --- Run the script ---
        runner_dialog = tk.Toplevel(self.root)
        runner_dialog.title("Importing Project...")
        runner_dialog.transient(self.root)
        runner_dialog.grab_set()
        runner_dialog.resizable(False, False)

        log_text = tk.Text(runner_dialog, height=20, width=90, wrap=tk.WORD, state=tk.DISABLED, bg="#1E1E1E", fg="#D4D4D4", font=("Consolas", 9))
        scrollbar = ttk.Scrollbar(runner_dialog, command=log_text.yview)
        log_text['yscrollcommand'] = scrollbar.set
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        def cleanup_and_close():
            try:
                if os.path.exists(output_dir):
                    shutil.rmtree(output_dir)
                    _debug(f"Cleaned up temporary import directory: {output_dir}")
            except Exception as e:
                _error(f"Failed to clean up temporary directory {output_dir}: {e}")
            runner_dialog.destroy()

        close_button = ttk.Button(runner_dialog, text="Close", state=tk.DISABLED, command=cleanup_and_close)
        close_button.pack(pady=5)
        
        def on_script_complete(success):
            if success:
                runner_dialog.destroy()
                project_base_path = os.path.join(output_dir, basename)
                self._execute_project_open(project_base_path, OPEN_MODE_STARTUP, preserved_palette=palette_before_load)
                
                self.current_project_base_path = None
                self._mark_project_modified()
                messagebox.showinfo("Import Successful", "Project successfully created from image.\nUse 'Save Project As...' to save it.", parent=self.root)

                try:
                    if os.path.exists(output_dir):
                        shutil.rmtree(output_dir)
                        _debug(f"Cleaned up temporary import directory: {output_dir}")
                except Exception as e:
                    _error(f"Failed to clean up temporary directory after successful import: {e}")
            else:
                messagebox.showerror("Import Failed", "The import script failed to complete. See log for details.", parent=self.root)
                close_button.config(state=tk.NORMAL)
                runner_dialog.grab_release()

        self._run_script_and_stream_output(command, log_text, on_script_complete)

    def _cleanup_temp_dirs(self):
        """Deletes temporary directories used by the application on startup."""
        try:
            temp_dir_path = os.path.join(platformdirs.user_cache_dir(self.config_app_name, appauthor=False), "img_import_temp")
            if os.path.exists(temp_dir_path):
                shutil.rmtree(temp_dir_path)
                _debug(f"Successfully cleaned up temporary directory: {temp_dir_path}")
        except Exception as e:
            _error(f"Could not clean up temporary directory on startup: {e}")

    def _apply_palette_change_updates(self):
        """Helper to perform all necessary UI updates after a palette color change."""
        self._mark_project_modified()
        self.clear_all_caches()
        self.invalidate_minimap_background_cache()
        self.update_all_displays(changed_level="all")
        self._request_color_usage_refresh()
        self._request_tile_usage_refresh()
        self._request_supertile_usage_refresh()

    def _apply_tile_limit_from_entry(self, event=None):
        """Validates and applies the tileset limit from the UI Entry widget."""
        try:
            new_limit = self.tile_limit_var.get()
            # This will be the new name for our refactored function
            self.set_tileset_limit(new_limit)
        except tk.TclError:
            messagebox.showerror("Invalid Input", "Please enter a valid whole number for the limit.", parent=self.root)
            # Reset the UI variable to the actual current limit
            self.tile_limit_var.set(self.project_tile_limit)

    def _apply_supertile_limit_from_entry(self, event=None):
        """Validates and applies the supertile limit from the UI Entry widget."""
        try:
            new_limit = self.supertile_limit_var.get()
            self.set_supertile_limit(new_limit)
        except tk.TclError:
            messagebox.showerror("Invalid Input", "Please enter a valid whole number for the limit.", parent=self.root)
            self.supertile_limit_var.set(self.project_supertile_limit)

    def _show_image_tile_selection_dialog(self, pal_path, tiles_path, temp_dir_to_cleanup):
        """
        Reads temporary files from msxtilemagic.py and displays the generated tiles
        in a selection dialog for the user to choose which ones to import.
        """
        try:
            # --- Read the temporary palette file ---
            with open(pal_path, "rb") as f:
                f.read(RESERVED_BYTES_COUNT) # Skip header
                palette_data_bytes = f.read(16 * 3)
            temp_palette_hex = []
            for i in range(16):
                r, g, b = struct.unpack_from("BBB", palette_data_bytes, i * 3)
                temp_palette_hex.append(self._rgb7_to_hex(r, g, b))

            # --- Read the temporary tileset file ---
            with open(tiles_path, "rb") as f:
                header = struct.unpack("B", f.read(1))[0]
                num_tiles = 256 if header == 0 else header
                f.read(RESERVED_BYTES_COUNT) # Skip reserved bytes
                pattern_bytes = f.read(num_tiles * TILE_HEIGHT)
                color_bytes = f.read(num_tiles * TILE_HEIGHT)
            
            temp_tileset_patterns = []
            temp_tileset_colors = []
            for i in range(num_tiles):
                pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
                colors = [(0, 0)] * TILE_HEIGHT
                for r in range(TILE_HEIGHT):
                    p_byte = pattern_bytes[i * TILE_HEIGHT + r]
                    c_byte = color_bytes[i * TILE_HEIGHT + r]
                    colors[r] = ((c_byte >> 4) & 0xF, c_byte & 0xF)
                    for c in range(TILE_WIDTH):
                        pattern[r][c] = (p_byte >> (7 - c)) & 1
                temp_tileset_patterns.append(pattern)
                temp_tileset_colors.append(colors)

        except Exception as e:
            messagebox.showerror("Import Error", f"Could not read temporary tile/palette files:\n{e}", parent=self.root)
            return

        # --- Create the Dialog (adapted from ROM Importer) ---
        dialog = tk.Toplevel(self.root)
        dialog.title("Image Tile Importer - Select Tiles to Import")
        dialog.transient(self.root)
        dialog.grab_set()

        # Store the loaded data on the dialog instance
        dialog.temp_palette_hex = temp_palette_hex
        dialog.temp_tileset_patterns = temp_tileset_patterns
        dialog.temp_tileset_colors = temp_tileset_colors
        dialog.selection = {}
        dialog.anchor_idx = -1
        dialog.grid_cols = 1
        dialog.redraw_timer_id = None
        dialog.hover_info_text_var = tk.StringVar(value="Grid Index: N/A")
        dialog.selection_info_text_var = tk.StringVar(value="Tiles Selected: 0")

        main_frame = ttk.Frame(dialog, padding=5)
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_columnconfigure(0, weight=1); main_frame.grid_rowconfigure(0, weight=1)

        # Left info panel (simplified)
        left_frame = ttk.Frame(main_frame)
        left_frame.grid(row=0, column=0, sticky="nswe", padx=(0, 10))
        ttk.Label(left_frame, textvariable=dialog.hover_info_text_var).pack(anchor="w")
        ttk.Label(left_frame, textvariable=dialog.selection_info_text_var).pack(anchor="w")
        
        # Main canvas view
        canvas_frame = ttk.Frame(main_frame); canvas_frame.grid(row=0, column=1, sticky="nswe")
        canvas_frame.grid_rowconfigure(0, weight=1); canvas_frame.grid_columnconfigure(0, weight=1)
        v_scroll = ttk.Scrollbar(canvas_frame, orient=tk.VERTICAL)
        # --- NEW: Calculate the fixed size for a 16x16 grid ---
        fixed_size = VIEWER_TILE_SIZE
        fixed_padding = 1
        num_cols = 16
        num_rows = 16
        canvas_fixed_width = num_cols * (fixed_size + fixed_padding) + fixed_padding
        canvas_fixed_height = num_rows * (fixed_size + fixed_padding) + fixed_padding

        dialog.canvas = tk.Canvas(
            canvas_frame,
            bg="darkgrey",
            yscrollcommand=v_scroll.set,
            highlightthickness=0,
            width=canvas_fixed_width,   # Set fixed width
            height=canvas_fixed_height  # Set fixed height
        )
        v_scroll.config(command=lambda *args: self._on_image_importer_scroll(dialog, *args))
        dialog.canvas.grid(row=0, column=0, sticky="nsew")
        v_scroll.grid(row=0, column=1, sticky="ns")

        # Bottom buttons
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(10,0))
        buttons_frame.grid_columnconfigure(0, weight=1) # Center buttons
        
        dialog.import_button = ttk.Button(
            buttons_frame, text="Import", state=tk.DISABLED,
            command=lambda: self._execute_image_tile_import(dialog, temp_dir_to_cleanup)
        )
        cancel_button = ttk.Button(
            buttons_frame, text="Cancel",
            command=lambda: self._close_image_importer_dialog(dialog, temp_dir_to_cleanup)
        )
        dialog.import_button.pack(side=tk.LEFT, padx=5)
        cancel_button.pack(side=tk.LEFT, padx=5)

        # Bind events
        dialog.canvas.bind("<Configure>", lambda e: self._on_image_importer_canvas_configure(dialog))
        dialog.canvas.bind("<Motion>", lambda e: self._on_image_canvas_motion(e, dialog))
        dialog.canvas.bind("<Button-1>", lambda e: self._on_image_canvas_left_click(e, dialog))
        dialog.canvas.bind("<Escape>", lambda e: self._clear_image_import_selection(dialog))
        dialog.protocol("WM_DELETE_WINDOW", lambda: self._close_image_importer_dialog(dialog, temp_dir_to_cleanup))

        # Initial draw
        dialog.after(50, lambda: self._on_image_importer_canvas_configure(dialog))

    def _on_image_importer_canvas_configure(self, dialog):
        if not dialog.winfo_exists(): return
        if dialog.redraw_timer_id: dialog.after_cancel(dialog.redraw_timer_id)
        dialog.redraw_timer_id = dialog.after(150, lambda: self._draw_image_importer_canvas(dialog))

    def _on_image_importer_scroll(self, dialog, *args):
        if not dialog.winfo_exists(): return
        dialog.canvas.yview(*args)
        if dialog.redraw_timer_id: dialog.after_cancel(dialog.redraw_timer_id)
        dialog.redraw_timer_id = dialog.after(30, lambda: self._draw_image_importer_canvas(dialog))

    def _draw_image_importer_canvas(self, dialog):
        if not dialog.winfo_exists(): return
        dialog.canvas.delete("all")
        
        patterns = dialog.temp_tileset_patterns
        colors = dialog.temp_tileset_colors
        palette = dialog.temp_palette_hex
        
        canvas_w = dialog.canvas.winfo_width()
        if canvas_w <= 1: return

        size = VIEWER_TILE_SIZE
        padding = 1
        cols = 16
        dialog.grid_cols = cols
        rows = (len(patterns) + cols - 1) // cols
        
        dialog.canvas.config(scrollregion=(0, 0, cols * (size + padding) + padding, rows * (size + padding) + padding))

        if not hasattr(dialog, 'image_refs'):
            dialog.image_refs = []
        dialog.image_refs.clear()

        for i, pattern in enumerate(patterns):
            r, c = divmod(i, cols)
            x1 = c * (size + padding) + padding
            y1 = r * (size + padding) + padding
            
            img = self._render_temp_tile_image(pattern, colors[i], palette, size)
            dialog.image_refs.append(img) # Store reference
            dialog.canvas.create_image(x1, y1, image=img, anchor="nw", tags=f"tile_{i}")
            
            if i in dialog.selection:
                dialog.canvas.create_rectangle(x1-1, y1-1, x1+size+1, y1+size+1, outline="yellow", width=2)
                
    def _render_temp_tile_image(self, pattern, colors, palette, size):
        img = tk.PhotoImage(width=size, height=size)
        for r in range(TILE_HEIGHT):
            fg_idx, bg_idx = colors[r]
            fg_hex = palette[fg_idx]
            bg_hex = palette[bg_idx]
            for c in range(TILE_WIDTH):
                color = fg_hex if pattern[r][c] == 1 else bg_hex
                x1, y1 = c * (size // TILE_WIDTH), r * (size // TILE_HEIGHT)
                x2, y2 = x1 + (size // TILE_WIDTH), y1 + (size // TILE_HEIGHT)
                img.put(color, to=(x1, y1, x2, y2))
        return img

    def _execute_image_tile_import(self, dialog, temp_dir_to_cleanup):
        """
        Takes the selected tiles from the image import dialog and appends them
        to the project in a single, undoable command.
        """
        global current_tile_index, tileset_patterns, tileset_colors
        
        if not dialog.winfo_exists(): return
        
        selection = dialog.selection
        if not selection:
            messagebox.showwarning("Import Error", "No tiles were selected.", parent=dialog)
            return

        # --- Prepare data and commands ---
        commands = []
        
        # 1. Command to replace the palette
        old_palette = list(self.active_msx_palette)
        new_palette = dialog.temp_palette_hex
        def palette_setter(p): self.active_msx_palette[:] = p
        commands.append(SetDataCommand("Import Palette from Image", self, palette_setter, new_palette, old_palette))

        # 2. Commands to append tiles
        sorted_indices = sorted(selection.keys())
        first_new_tile_idx = len(tileset_patterns)
        
        for i, tile_idx in enumerate(sorted_indices):
            current_project_size = len(tileset_patterns) + i
            if current_project_size >= self.project_tile_limit:
                messagebox.showinfo("Import Limit Reached", f"Project tileset limit of {self.project_tile_limit} reached. Imported {i} tiles.", parent=self.root)
                break
            
            new_idx_in_project = len(tileset_patterns) + i
            pattern_to_add = dialog.temp_tileset_patterns[tile_idx]
            colors_to_add = dialog.temp_tileset_colors[tile_idx]
            
            commands.append(ModifyListCommand("Import Tile", tileset_patterns, new_idx_in_project, pattern_to_add, is_insert=True))
            commands.append(ModifyListCommand("Import Tile", tileset_colors, new_idx_in_project, colors_to_add, is_insert=True))

        # 3. Command to update selection state
        old_state = (current_tile_index,)
        new_state = (first_new_tile_idx,)
        def state_setter(state): global current_tile_index; current_tile_index = state[0]
        commands.append(SetDataCommand("Update App State", self, state_setter, new_state, old_state))
        
        # 4. Define post-import hooks
        def post_import_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            self._request_color_usage_refresh()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

        composite = CompositeCommand(f"Import {len(selection)} Tiles from Image", commands, app_ref=self, post_hooks=[post_import_hooks])
        
        # Close dialog BEFORE executing the command
        self._close_image_importer_dialog(dialog, temp_dir_to_cleanup)
        
        # Execute the entire import
        self.undo_manager.execute(composite)
        
        messagebox.showinfo("Import Successful", f"Successfully imported {len(selection)} tile(s).", parent=self.root)

    def _on_image_importer_canvas_configure(self, dialog):
        if not dialog.winfo_exists(): return
        if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id:
            dialog.after_cancel(dialog.redraw_timer_id)
        dialog.redraw_timer_id = dialog.after(150, lambda: self._draw_image_importer_canvas(dialog))

    def _on_image_importer_scroll(self, dialog, *args):
        if not dialog.winfo_exists(): return
        dialog.canvas.yview(*args)
        if hasattr(dialog, 'redraw_timer_id') and dialog.redraw_timer_id:
            dialog.after_cancel(dialog.redraw_timer_id)
        dialog.redraw_timer_id = dialog.after(30, lambda: self._draw_image_importer_canvas(dialog))

    def _draw_image_importer_canvas(self, dialog):
        if not dialog.winfo_exists(): return
        dialog.canvas.delete("all")
        
        patterns = dialog.temp_tileset_patterns
        colors = dialog.temp_tileset_colors
        palette = dialog.temp_palette_hex
        
        canvas_w = dialog.canvas.winfo_width()
        if canvas_w <= 1: return

        size = VIEWER_TILE_SIZE
        padding = 1
        cols = max(1, canvas_w // (size + padding))
        dialog.grid_cols = cols
        rows = (len(patterns) + cols - 1) // cols
        
        dialog.canvas.config(scrollregion=(0, 0, cols * (size + padding) + padding, rows * (size + padding) + padding))
        
        # Keep a list of image references on the dialog itself
        if not hasattr(dialog, 'image_refs'):
            dialog.image_refs = []
        dialog.image_refs.clear()

        for i, pattern in enumerate(patterns):
            r, c = divmod(i, cols)
            x1 = c * (size + padding) + padding
            y1 = r * (size + padding) + padding
            
            img = self._render_temp_tile_image(pattern, colors[i], palette, size)
            dialog.image_refs.append(img) # Store reference
            dialog.canvas.create_image(x1, y1, image=img, anchor="nw", tags=f"tile_{i}")
            
            if i in dialog.selection:
                dialog.canvas.create_rectangle(x1-1, y1-1, x1+size+1, y1+size+1, outline="yellow", width=2)
                
    def _render_temp_tile_image(self, pattern, colors, palette, size):
        img = tk.PhotoImage(width=size, height=size)
        px_w = max(1, size // TILE_WIDTH)
        px_h = max(1, size // TILE_HEIGHT)
        for r in range(TILE_HEIGHT):
            fg_idx, bg_idx = colors[r]
            fg_hex = palette[fg_idx]
            bg_hex = palette[bg_idx]
            for c in range(TILE_WIDTH):
                color = fg_hex if pattern[r][c] == 1 else bg_hex
                x1, y1 = c * px_w, r * px_h
                x2, y2 = x1 + px_w, y1 + px_h
                img.put(color, to=(x1, y1, x2, y2))
        return img

    def _on_image_canvas_motion(self, event, dialog):
        if not dialog.winfo_exists(): return
        size = VIEWER_TILE_SIZE
        padding = 1
        cx, cy = dialog.canvas.canvasx(event.x), dialog.canvas.canvasy(event.y)
        col = int(cx // (size + padding))
        row = int(cy // (size + padding))
        idx = row * dialog.grid_cols + col
        
        if 0 <= idx < len(dialog.temp_tileset_patterns):
            dialog.hover_info_text_var.set(f"Grid Index: {idx}")
        else:
            dialog.hover_info_text_var.set("Grid Index: N/A")

    def _on_image_canvas_left_click(self, event, dialog):
        """
        Handles left-clicks on the image import selection canvas.
        This logic is a direct port of the mature selection behavior from the ROM importer.
        """
        if not dialog.winfo_exists(): return
        
        # --- 1. Calculate the clicked tile index ---
        size = VIEWER_TILE_SIZE
        padding = 1
        cx, cy = dialog.canvas.canvasx(event.x), dialog.canvas.canvasy(event.y)
        col = int(cx // (size + padding))
        row = int(cy // (size + padding))
        idx = row * dialog.grid_cols + col

        if not (0 <= idx < len(dialog.temp_tileset_patterns)): return

        # --- 2. Get current state ---
        is_shift = (event.state & 0x0001) != 0
        is_ctrl = (event.state & 0x0004) != 0
        selection = dialog.selection
        
        # --- 3. Apply selection logic (equivalent to ROM importer) ---
        
        if is_shift and is_ctrl:
            # Add a range to the current selection.
            if dialog.anchor_idx != -1:
                start, end = min(dialog.anchor_idx, idx), max(dialog.anchor_idx, idx)
                for i in range(start, end + 1):
                    selection[i] = True
            else:
                # Fallback: No anchor exists, so behave like a Ctrl+Click.
                if idx in selection: del selection[idx]
                else: selection[idx] = True
                dialog.anchor_idx = idx
        
        elif is_shift:
            # Replace the current selection with a new range.
            selection.clear()
            if dialog.anchor_idx != -1:
                start, end = min(dialog.anchor_idx, idx), max(dialog.anchor_idx, idx)
                for i in range(start, end + 1):
                    selection[i] = True
            else:
                # Fallback: No anchor exists, so behave like a Normal Click.
                selection[idx] = True
                dialog.anchor_idx = idx
                
        elif is_ctrl:
            # Toggle a single tile in the current selection.
            if idx in selection:
                del selection[idx]
                if dialog.anchor_idx == idx: # If we deselected the anchor...
                    dialog.anchor_idx = -1 # ...it is no longer a valid anchor.
            else:
                selection[idx] = True
                dialog.anchor_idx = idx # Update anchor to the last-clicked tile.
            
            # If the selection is now empty, there can be no anchor.
            if not selection:
                dialog.anchor_idx = -1
            
        else: # Normal click
            # Replace the current selection with a single tile.
            is_already_selected = (len(selection) == 1 and idx in selection)
            if not is_already_selected:
                selection.clear()
                selection[idx] = True
            dialog.anchor_idx = idx # Always set the anchor on a normal click.

        # --- 4. Update the UI ---
        self._draw_image_importer_canvas(dialog)
        dialog.selection_info_text_var.set(f"Tiles Selected: {len(selection)}")
        dialog.import_button.config(state=tk.NORMAL if selection else tk.DISABLED)

    def _clear_image_import_selection(self, dialog):
        if not dialog.winfo_exists(): return
        dialog.selection.clear()
        dialog.anchor_idx = -1
        self._draw_image_importer_canvas(dialog)
        dialog.selection_info_text_var.set("Tiles Selected: 0")
        dialog.import_button.config(state=tk.DISABLED)

    def _close_image_importer_dialog(self, dialog, temp_dir):
        if dialog.winfo_exists():
            dialog.destroy()
        try:
            if os.path.exists(temp_dir): shutil.rmtree(temp_dir)
        except Exception as e:
            _error(f"Failed to clean up temp dir: {e}")

    def _execute_image_tile_import(self, dialog, temp_dir_to_cleanup):
        """
        Takes the selected tiles from the image import dialog and appends them
        to the project in a single, undoable command.
        """
        global current_tile_index, tileset_patterns, tileset_colors
        
        if not dialog.winfo_exists(): return
        
        selection = dialog.selection
        if not selection:
            messagebox.showwarning("Import Error", "No tiles were selected.", parent=dialog)
            return

        # --- Prepare data and commands ---
        commands = []
        
        # 1. Command to replace the palette
        old_palette = list(self.active_msx_palette)
        new_palette = dialog.temp_palette_hex
        def palette_setter(p): self.active_msx_palette[:] = p
        commands.append(SetDataCommand("Import Palette from Image", self, palette_setter, new_palette, old_palette))

        # 2. Commands to append tiles
        sorted_indices = sorted(selection.keys())
        first_new_tile_idx = len(tileset_patterns)
        
        num_actually_imported = 0
        for tile_idx in sorted_indices:
            current_project_size = len(tileset_patterns) + num_actually_imported
            if current_project_size >= self.project_tile_limit:
                messagebox.showinfo("Import Limit Reached", f"Project tileset limit of {self.project_tile_limit} reached. Imported {num_actually_imported} tiles.", parent=self.root)
                break
            
            new_idx_in_project = len(tileset_patterns) + num_actually_imported
            pattern_to_add = dialog.temp_tileset_patterns[tile_idx]
            colors_to_add = dialog.temp_tileset_colors[tile_idx]
            
            commands.append(ModifyListCommand("Import Tile", tileset_patterns, new_idx_in_project, pattern_to_add, is_insert=True))
            commands.append(ModifyListCommand("Import Tile", tileset_colors, new_idx_in_project, colors_to_add, is_insert=True))
            num_actually_imported += 1

        if num_actually_imported == 0:
             self._close_image_importer_dialog(dialog, temp_dir_to_cleanup)
             messagebox.showinfo("Import Notice", "No tiles were imported (limit may have been reached).", parent=self.root)
             return

        # 3. Command to update selection state
        old_state = (current_tile_index,)
        new_state = (first_new_tile_idx,)
        def state_setter(state): global current_tile_index; current_tile_index = state[0]
        commands.append(SetDataCommand("Update App State", self, state_setter, new_state, old_state))
        
        # 4. Define post-import hooks
        def post_import_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            if hasattr(self, 'notebook') and hasattr(self, 'tab_tile_editor'):
                try: self.notebook.select(self.tab_tile_editor)
                except tk.TclError: pass
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            self._request_color_usage_refresh()
            self._request_tile_usage_refresh()
            self._request_supertile_usage_refresh()

        composite = CompositeCommand(f"Import {num_actually_imported} Tiles from Image", commands, app_ref=self, post_hooks=[post_import_hooks])
        
        # Close dialog BEFORE executing the command
        self._close_image_importer_dialog(dialog, temp_dir_to_cleanup)
        
        # Execute the entire import
        self.undo_manager.execute(composite)

    def handle_import_tiles_from_file(self):
        """
        Handles the 'Import Tiles from File...' action. Reads a .SC4Tiles file
        and opens a selection dialog for the user to choose which tiles to append.
        """
        if len(tileset_patterns) >= self.project_tile_limit:
            messagebox.showinfo("Import Tiles", f"The project tileset is at its limit of {self.project_tile_limit}. Cannot import more tiles.", parent=self.root)
            return

        load_path = filedialog.askopenfilename(
            master=self.root,
            filetypes=[("MSX Tileset", "*.SC4Tiles"), ("All Files", "*.*")],
            title="Select Tileset File to Import From",
        )
        if not load_path:
            return

        try:
            # --- This block reads the entire .SC4Tiles file into temporary lists ---
            with open(load_path, "rb") as f:
                header = struct.unpack("B", f.read(1))[0]
                num_tiles = 256 if header == 0 else header
                f.read(RESERVED_BYTES_COUNT) # Skip reserved bytes
                pattern_bytes = f.read(num_tiles * TILE_HEIGHT)
                color_bytes = f.read(num_tiles * TILE_HEIGHT)

            if len(pattern_bytes) < num_tiles * TILE_HEIGHT or len(color_bytes) < num_tiles * TILE_HEIGHT:
                raise EOFError("File is incomplete or corrupted.")

            temp_patterns = []
            temp_colors = []
            for i in range(num_tiles):
                pattern = [[0] * TILE_WIDTH for _ in range(TILE_HEIGHT)]
                colors = [(0, 0)] * TILE_HEIGHT
                for r in range(TILE_HEIGHT):
                    p_byte = pattern_bytes[i * TILE_HEIGHT + r]
                    c_byte = color_bytes[i * TILE_HEIGHT + r]
                    colors[r] = ((c_byte >> 4) & 0xF, c_byte & 0xF)
                    for c in range(TILE_WIDTH):
                        pattern[r][c] = (p_byte >> (7 - c)) & 1
                temp_patterns.append(pattern)
                temp_colors.append(colors)
            
            # --- Launch the selection dialog with the loaded data ---
            self._show_file_tile_selection_dialog(temp_patterns, temp_colors, self.active_msx_palette)

        except Exception as e:
            messagebox.showerror("Import Error", f"Could not read the selected tileset file:\n{e}", parent=self.root)

    def _show_file_tile_selection_dialog(self, temp_patterns, temp_colors, active_palette):
        """
        Displays a dialog for selecting tiles from a file. This is a clone of the
        image tile selection dialog but uses the current project's palette for rendering.
        """
        dialog = tk.Toplevel(self.root)
        dialog.title("Import Tiles - Select Tiles to Add")
        dialog.transient(self.root)
        dialog.grab_set()

        # Store the loaded data on the dialog instance
        dialog.temp_tileset_patterns = temp_patterns
        dialog.temp_tileset_colors = temp_colors
        dialog.temp_palette_hex = active_palette # Use the project's current palette for preview
        dialog.selection = {}
        dialog.anchor_idx = -1
        dialog.grid_cols = 16 # Fixed column count
        dialog.redraw_timer_id = None
        dialog.hover_info_text_var = tk.StringVar(value="Grid Index: N/A")
        dialog.selection_info_text_var = tk.StringVar(value="Tiles Selected: 0")

        main_frame = ttk.Frame(dialog, padding=5)
        main_frame.pack(expand=True, fill="both")
        main_frame.grid_columnconfigure(0, weight=1); main_frame.grid_rowconfigure(0, weight=1)

        # Left info panel
        left_frame = ttk.Frame(main_frame, padding=(5,0))
        left_frame.grid(row=0, column=0, sticky="nswe")
        ttk.Label(left_frame, textvariable=dialog.hover_info_text_var).pack(anchor="w")
        ttk.Label(left_frame, textvariable=dialog.selection_info_text_var).pack(anchor="w")
        
        # Main canvas view with fixed 16x16 size
        canvas_frame = ttk.Frame(main_frame); canvas_frame.grid(row=0, column=1, sticky="nswe")
        canvas_frame.grid_rowconfigure(0, weight=1); canvas_frame.grid_columnconfigure(0, weight=1)
        v_scroll = ttk.Scrollbar(canvas_frame, orient=tk.VERTICAL)
        
        fixed_size = VIEWER_TILE_SIZE
        fixed_padding = 1
        canvas_fixed_width = 16 * (fixed_size + fixed_padding) + fixed_padding
        canvas_fixed_height = 16 * (fixed_size + fixed_padding) + fixed_padding

        dialog.canvas = tk.Canvas(
            canvas_frame, bg="darkgrey", yscrollcommand=v_scroll.set, highlightthickness=0,
            width=canvas_fixed_width, height=canvas_fixed_height
        )
        v_scroll.config(command=lambda *args: self._on_image_importer_scroll(dialog, *args))
        dialog.canvas.grid(row=0, column=0, sticky="nsew")
        v_scroll.grid(row=0, column=1, sticky="ns")

        # Bottom buttons
        buttons_frame = ttk.Frame(main_frame, padding=(0, 10, 0, 0))
        buttons_frame.grid(row=1, column=0, columnspan=2, sticky="ew")
        buttons_frame.grid_columnconfigure(0, weight=1) # Center buttons
        
        btn_container = ttk.Frame(buttons_frame)
        btn_container.pack()

        dialog.import_button = ttk.Button(
            btn_container, text="Import", state=tk.DISABLED,
            command=lambda: self._execute_file_tile_import(dialog)
        )
        cancel_button = ttk.Button(
            btn_container, text="Cancel", command=dialog.destroy
        )
        dialog.import_button.pack(side=tk.LEFT, padx=5)
        cancel_button.pack(side=tk.LEFT, padx=5)

        # Bind events (reuses the robust handlers from the image importer)
        dialog.canvas.bind("<Configure>", lambda e: self._on_image_importer_canvas_configure(dialog))
        dialog.canvas.bind("<Motion>", lambda e: self._on_image_canvas_motion(e, dialog))
        dialog.canvas.bind("<Button-1>", lambda e: self._on_image_canvas_left_click(e, dialog))
        dialog.canvas.bind("<Escape>", lambda e: self._clear_image_import_selection(dialog))
        dialog.protocol("WM_DELETE_WINDOW", dialog.destroy)

        # Initial draw
        dialog.after(50, lambda: self._on_image_importer_canvas_configure(dialog))

    def _execute_file_tile_import(self, dialog):
        """
        Takes selected tiles from the file import dialog and appends them to the
        project in a single, undoable command.
        """
        global current_tile_index
        
        if not dialog.winfo_exists(): return
        
        selection = dialog.selection
        if not selection:
            messagebox.showwarning("Import Error", "No tiles were selected.", parent=dialog)
            return

        commands = []
        sorted_indices = sorted(selection.keys())
        first_new_tile_idx = len(tileset_patterns)
        num_actually_imported = 0
        
        for tile_idx_from_file in sorted_indices:
            current_project_size = len(tileset_patterns) + num_actually_imported
            if current_project_size >= self.project_tile_limit:
                messagebox.showinfo("Import Limit Reached", f"Project tileset limit of {self.project_tile_limit} reached. Imported {num_actually_imported} tiles.", parent=self.root)
                break
            
            new_idx_in_project = len(tileset_patterns) + num_actually_imported
            pattern_to_add = dialog.temp_tileset_patterns[tile_idx_from_file]
            colors_to_add = dialog.temp_tileset_colors[tile_idx_from_file]
            
            commands.append(ModifyListCommand("Import Tile", tileset_patterns, new_idx_in_project, pattern_to_add, is_insert=True))
            commands.append(ModifyListCommand("Import Tile", tileset_colors, new_idx_in_project, colors_to_add, is_insert=True))
            num_actually_imported += 1

        if num_actually_imported == 0:
             dialog.destroy()
             messagebox.showinfo("Import Notice", "No tiles were imported (limit may have been reached).", parent=self.root)
             return

        # Command to update selection state
        old_state = (current_tile_index,)
        new_state = (first_new_tile_idx,)
        def state_setter(state): global current_tile_index; current_tile_index = state[0]
        commands.append(SetDataCommand("Update App State", self, state_setter, new_state, old_state))
        
        # Post-import UI update hooks
        def post_import_hooks():
            self._mark_project_modified()
            self.clear_all_caches()
            self.invalidate_minimap_background_cache()
            self.update_all_displays(changed_level="all")
            self.scroll_viewers_to_tile(current_tile_index)
            self._update_editor_button_states()
            self._request_color_usage_refresh()
            self._request_tile_usage_refresh()

        composite = CompositeCommand(f"Import {num_actually_imported} Tiles", commands, app_ref=self, post_hooks=[post_import_hooks])
        
        dialog.destroy()
        self.undo_manager.execute(composite)
        
        messagebox.showinfo("Import Successful", f"Successfully imported {num_actually_imported} tile(s).", parent=self.root)

# print(dir(TileEditorApp))
# exit() # Stop before GUI starts for this test

# --- Main Execution ---
if __name__ == "__main__":
    import argparse
    import webbrowser # Import for the splash screen link
    import tkinter.font as font # Import for the splash screen link font

    parser = argparse.ArgumentParser(description="MSX Tile Forge - Tile and Map Editor.")
    parser.add_argument("--debug",action="store_true",help="Enable detailed debug console output.")
    args = parser.parse_args()
    
    root = tk.Tk()
    root.withdraw() # Hide main window initially
    root.app_debug_mode = args.debug
    if root.app_debug_mode:
        _info("Debug mode enabled via --debug flag.")

    splash_win = tk.Toplevel(root)
    splash_win.overrideredirect(True) # No window decorations
    splash_win.config(cursor="watch")

    splash_after_id = None # To store the ID of the 'after' job

    def destroy_splash_and_show_main():
        # This function is called either by timer or by Esc key
        global splash_after_id
        if tk.Toplevel.winfo_exists(splash_win): # Check if splash window still exists
            if splash_after_id: # If a timer was set
                try:
                    splash_win.after_cancel(splash_after_id) # Try to cancel it
                except tk.TclError:
                    pass # Timer might have already fired or window gone
            splash_after_id = None
            splash_win.destroy()
        
        if root.winfo_exists(): # Check if root window still exists
            app = TileEditorApp(root) # Create and show the main application
            app._cleanup_temp_dirs()
            root.deiconify()
            if hasattr(app, 'debug'): app._debug(" Main application initialized.")

    def handle_splash_escape(event=None): # Added event=None for binding
        destroy_splash_and_show_main()

    if not SPLASH_IMAGE or not isinstance(SPLASH_IMAGE, str) or len(SPLASH_IMAGE) < 20:
        _warning("SPLASH_IMAGE is invalid or not defined. Skipping splash image display.")
        if root.winfo_exists():
            splash_after_id = root.after(100, destroy_splash_and_show_main) # Very short delay if no image
        root.bind("<Escape>", handle_splash_escape) 
        raise RuntimeError("Splash image data invalid") # Go to except block for fallback

    image_data = base64.b64decode(SPLASH_IMAGE)
    splash_photo_ref = tk.PhotoImage(data=image_data) # Keep reference directly

    # Frame to hold image and text, to help with centering and layout
    content_frame = ttk.Frame(splash_win)
    content_frame.pack(expand=True, fill='both', padx=1, pady=1) # Add minimal padding if needed

    splash_image_label = ttk.Label(content_frame, image=splash_photo_ref, borderwidth=0)
    splash_image_label.pack(side=tk.TOP, padx=0, pady=0)
    splash_image_label.image = splash_photo_ref # Keep reference on label

    # Create a frame for the contribution links
    contrib_splash_frame = ttk.Frame(content_frame)
    contrib_splash_frame.pack(side=tk.BOTTOM, fill='x', pady=(2, 2))

    splash_link_font = font.Font(family="Segoe UI", size=8, underline=True)

    bmac_url = "https://www.buymeacoffee.com/DamnedAngel"
    bmac_splash_label = tk.Label(
        contrib_splash_frame, 
        text="Buy Me a Coffee", 
        font=splash_link_font, 
        fg="blue", 
        cursor="hand2"
    )
    bmac_splash_label.pack(side=tk.LEFT, padx=(5, 5))
    bmac_splash_label.bind("<Button-1>", lambda e: webbrowser.open_new(bmac_url))

    ttk.Label(
        contrib_splash_frame, 
        text="| PayPal / Pix: danilo@angelo.eng.br",
        font=("Segoe UI", 8)
    ).pack(side=tk.LEFT, padx=(0, 5))

    version_text_label = ttk.Label(
        content_frame, 
        text=f"v{APP_VERSION}", 
        font=("Segoe UI", 8), # Small font for version
    )
    version_text_label.pack(side=tk.BOTTOM, pady=(2, 0)) # Pack version above contrib links

    splash_win.update_idletasks()
    req_width = content_frame.winfo_reqwidth()
    req_height = content_frame.winfo_reqheight()
        
    # Ensure positive dimensions, fallback to image size if frame calculation is off
    img_w = splash_photo_ref.width() if splash_photo_ref else 100
    img_h = splash_photo_ref.height() if splash_photo_ref else 50
        
    final_width = max(req_width, img_w, 1) # At least image width, or 1
    final_height = max(req_height, img_h, 1) # At least image height + text, or 1

    screen_width = splash_win.winfo_screenwidth()
    screen_height = splash_win.winfo_screenheight()
    x_pos = (screen_width // 2) - (final_width // 2)
    y_pos = (screen_height // 2) - (final_height // 2)
        
    splash_win.geometry(f'{final_width}x{final_height}+{x_pos}+{y_pos}')

    splash_win.bind("<Escape>", handle_splash_escape)
    splash_win.focus_set() # Give splash window focus to receive Esc key

    if root.winfo_exists():
        splash_after_id = splash_win.after(3000, destroy_splash_and_show_main)
    else: # Root closed before timer set
        if tk.Toplevel.winfo_exists(splash_win): splash_win.destroy()

    root.mainloop()
